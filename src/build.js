(function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
        }
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = true;
        return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
            Object.defineProperty(exports, name, {
                configurable: false,
                enumerable: true,
                get: getter
            });
        }
    };
    __webpack_require__.r = function(exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
    };
    __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function getDefault() {
            return module["default"];
        } : function getModuleExports() {
            return module;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
    };
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = 480);
})([ function(module, exports, __webpack_require__) {
    if (false) {
        var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE;
    } else {
        module.exports = __webpack_require__(471)();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = assertString;
    function assertString(input) {
        var isString = typeof input === "string" || input instanceof String;
        if (!isString) {
            throw new TypeError("This library (validator.js) validates strings only");
        }
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    if (true) {
        module.exports = __webpack_require__(479);
    } else {}
}, function(module, exports) {
    if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(global) {
        var base64 = __webpack_require__(452);
        var ieee754 = __webpack_require__(451);
        var isArray = __webpack_require__(165);
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
        exports.kMaxLength = kMaxLength();
        function typedArraySupport() {
            try {
                var arr = new Uint8Array(1);
                arr.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42;
                    }
                };
                return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0;
            } catch (e) {
                return false;
            }
        }
        function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function createBuffer(that, length) {
            if (kMaxLength() < length) {
                throw new RangeError("Invalid typed array length");
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
            } else {
                if (that === null) {
                    that = new Buffer(length);
                }
                that.length = length;
            }
            return that;
        }
        function Buffer(arg, encodingOrOffset, length) {
            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length);
            }
            if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                    throw new Error("If encoding is specified then the first argument must be a string");
                }
                return allocUnsafe(this, arg);
            }
            return from(this, arg, encodingOrOffset, length);
        }
        Buffer.poolSize = 8192;
        Buffer._augment = function(arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
        };
        function from(that, value, encodingOrOffset, length) {
            if (typeof value === "number") {
                throw new TypeError('"value" argument must not be a number');
            }
            if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
                return fromArrayBuffer(that, value, encodingOrOffset, length);
            }
            if (typeof value === "string") {
                return fromString(that, value, encodingOrOffset);
            }
            return fromObject(that, value);
        }
        Buffer.from = function(value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
        };
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
            if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
                Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: true
                });
            }
        }
        function assertSize(size) {
            if (typeof size !== "number") {
                throw new TypeError('"size" argument must be a number');
            } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative');
            }
        }
        function alloc(that, size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
                return createBuffer(that, size);
            }
            if (fill !== undefined) {
                return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
            }
            return createBuffer(that, size);
        }
        Buffer.alloc = function(size, fill, encoding) {
            return alloc(null, size, fill, encoding);
        };
        function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                    that[i] = 0;
                }
            }
            return that;
        }
        Buffer.allocUnsafe = function(size) {
            return allocUnsafe(null, size);
        };
        Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(null, size);
        };
        function fromString(that, string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
            }
            if (!Buffer.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding');
            }
            var length = byteLength(string, encoding) | 0;
            that = createBuffer(that, length);
            var actual = that.write(string, encoding);
            if (actual !== length) {
                that = that.slice(0, actual);
            }
            return that;
        }
        function fromArrayLike(that, array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            that = createBuffer(that, length);
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
            }
            return that;
        }
        function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength;
            if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError("'offset' is out of bounds");
            }
            if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError("'length' is out of bounds");
            }
            if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
            } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
            } else {
                array = new Uint8Array(array, byteOffset, length);
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = array;
                that.__proto__ = Buffer.prototype;
            } else {
                that = fromArrayLike(that, array);
            }
            return that;
        }
        function fromObject(that, obj) {
            if (Buffer.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);
                if (that.length === 0) {
                    return that;
                }
                obj.copy(that, 0, 0, len);
                return that;
            }
            if (obj) {
                if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                    if (typeof obj.length !== "number" || isnan(obj.length)) {
                        return createBuffer(that, 0);
                    }
                    return fromArrayLike(that, obj);
                }
                if (obj.type === "Buffer" && isArray(obj.data)) {
                    return fromArrayLike(that, obj.data);
                }
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function checked(length) {
            if (length >= kMaxLength()) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes");
            }
            return length | 0;
        }
        function SlowBuffer(length) {
            if (+length != length) {
                length = 0;
            }
            return Buffer.alloc(+length);
        }
        Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
        };
        Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError("Arguments must be Buffers");
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;

              default:
                return false;
            }
        };
        Buffer.concat = function concat(list, length) {
            if (!isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
                return Buffer.alloc(0);
            }
            var i;
            if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                }
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!Buffer.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
            }
            return buffer;
        };
        function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
                return string.length;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength;
            }
            if (typeof string !== "string") {
                string = "" + string;
            }
            var len = string.length;
            if (len === 0) return 0;
            var loweredCase = false;
            for (;;) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;

                  case "utf8":
                  case "utf-8":
                  case undefined:
                    return utf8ToBytes(string).length;

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;

                  case "hex":
                    return len >>> 1;

                  case "base64":
                    return base64ToBytes(string).length;

                  default:
                    if (loweredCase) return utf8ToBytes(string).length;
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
            }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === undefined || start < 0) {
                start = 0;
            }
            if (start > this.length) {
                return "";
            }
            if (end === undefined || end > this.length) {
                end = this.length;
            }
            if (end <= 0) {
                return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
                return "";
            }
            if (!encoding) encoding = "utf8";
            while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
            }
        }
        Buffer.prototype._isBuffer = true;
        function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
        }
        Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
            }
            return this;
        };
        Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
            }
            return this;
        };
        Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
            }
            return this;
        };
        Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0) return "";
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
        };
        Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
                str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                if (this.length > max) str += " ... ";
            }
            return "<Buffer " + str + ">";
        };
        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) {
                throw new TypeError("Argument must be a Buffer");
            }
            if (start === undefined) {
                start = 0;
            }
            if (end === undefined) {
                end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
                thisStart = 0;
            }
            if (thisEnd === undefined) {
                thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
                return 0;
            }
            if (thisStart >= thisEnd) {
                return -1;
            }
            if (start >= end) {
                return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0) return -1;
            if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
            } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (isNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
                if (dir) return -1; else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
                if (dir) byteOffset = 0; else return -1;
            }
            if (typeof val === "string") {
                val = Buffer.from(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
                if (val.length === 0) {
                    return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
                val = val & 255;
                if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                        return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                }
            }
            function read(buf, i) {
                if (indexSize === 1) {
                    return buf[i];
                } else {
                    return buf.readUInt16BE(i * indexSize);
                }
            }
            var i;
            if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1) foundIndex = i;
                        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else {
                        if (foundIndex !== -1) i -= i - foundIndex;
                        foundIndex = -1;
                    }
                }
            } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                    var found = true;
                    for (var j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                            found = false;
                            break;
                        }
                    }
                    if (found) return i;
                }
            }
            return -1;
        }
        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = Number(length);
                if (length > remaining) {
                    length = remaining;
                }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
            if (length > strLen / 2) {
                length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i;
                buf[offset + i] = parsed;
            }
            return i;
        }
        function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === undefined) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
            } else if (length === undefined && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
            } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                    length = length | 0;
                    if (encoding === undefined) encoding = "utf8";
                } else {
                    encoding = length;
                    length = undefined;
                }
            } else {
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding) encoding = "utf8";
            var loweredCase = false;
            for (;;) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);

                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);

                  case "ascii":
                    return asciiWrite(this, string, offset, length);

                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);

                  case "base64":
                    return base64Write(this, string, offset, length);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
            }
        };
        Buffer.prototype.toJSON = function toJSON() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
            } else {
                return base64.fromByteArray(buf.slice(start, end));
            }
        }
        function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                            codePoint = firstByte;
                        }
                        break;

                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 192) === 128) {
                            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                            if (tempCodePoint > 127) {
                                codePoint = tempCodePoint;
                            }
                        }
                        break;

                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                                codePoint = tempCodePoint;
                            }
                        }
                        break;

                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                                codePoint = tempCodePoint;
                            }
                        }
                    }
                }
                if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
                res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
        }
        function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
        }
        function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
            }
            return ret;
        }
        function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
            }
            return out;
        }
        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
                start += len;
                if (start < 0) start = 0;
            } else if (start > len) {
                start = len;
            }
            if (end < 0) {
                end += len;
                if (end < 0) end = 0;
            } else if (end > len) {
                end = len;
            }
            if (end < start) end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
            } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                    newBuf[i] = this[i + start];
                }
            }
            return newBuf;
        };
        function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            return val;
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
                val += this[offset + --byteLength] * mul;
            }
            return val;
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
            } else {
                objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
            } else {
                objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 255;
            } else {
                objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
            } else {
                objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
            } else {
                objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
            } else {
                objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
            } else {
                objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
            } else {
                objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;
            if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
                for (i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start];
                }
            } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
                for (i = 0; i < len; ++i) {
                    target[i + targetStart] = this[i + start];
                }
            } else {
                Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            }
            return len;
        };
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
                if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                }
                if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (code < 256) {
                        val = code;
                    }
                }
                if (encoding !== undefined && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                }
            } else if (typeof val === "number") {
                val = val & 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
            }
            if (end <= start) {
                return this;
            }
            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;
            if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                    this[i] = val;
                }
            } else {
                var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                }
            }
            return this;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
        function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while (str.length % 4 !== 0) {
                str = str + "=";
            }
            return str;
        }
        function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
        }
        function toHex(n) {
            if (n < 16) return "0" + n.toString(16);
            return n.toString(16);
        }
        function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                        if (codePoint > 56319) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else if (i + 1 === length) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    if (codePoint < 56320) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                    throw new Error("Invalid code point");
                }
            }
            return bytes;
        }
        function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
        }
        function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
            }
            return byteArray;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
            }
            return i;
        }
        function isnan(val) {
            return val !== val;
        }
    }).call(this, __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var warning = function() {};
    if (false) {}
    module.exports = warning;
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory();
        } else {}
    })(this, function() {
        var CryptoJS = CryptoJS || function(Math, undefined) {
            var create = Object.create || function() {
                function F() {}
                return function(obj) {
                    var subtype;
                    F.prototype = obj;
                    subtype = new F();
                    F.prototype = null;
                    return subtype;
                };
            }();
            var C = {};
            var C_lib = C.lib = {};
            var Base = C_lib.Base = function() {
                return {
                    extend: function(overrides) {
                        var subtype = create(this);
                        if (overrides) {
                            subtype.mixIn(overrides);
                        }
                        if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                            subtype.init = function() {
                                subtype.$super.init.apply(this, arguments);
                            };
                        }
                        subtype.init.prototype = subtype;
                        subtype.$super = this;
                        return subtype;
                    },
                    create: function() {
                        var instance = this.extend();
                        instance.init.apply(instance, arguments);
                        return instance;
                    },
                    init: function() {},
                    mixIn: function(properties) {
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                                this[propertyName] = properties[propertyName];
                            }
                        }
                        if (properties.hasOwnProperty("toString")) {
                            this.toString = properties.toString;
                        }
                    },
                    clone: function() {
                        return this.init.prototype.extend(this);
                    }
                };
            }();
            var WordArray = C_lib.WordArray = Base.extend({
                init: function(words, sigBytes) {
                    words = this.words = words || [];
                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 4;
                    }
                },
                toString: function(encoder) {
                    return (encoder || Hex).stringify(this);
                },
                concat: function(wordArray) {
                    var thisWords = this.words;
                    var thatWords = wordArray.words;
                    var thisSigBytes = this.sigBytes;
                    var thatSigBytes = wordArray.sigBytes;
                    this.clamp();
                    if (thisSigBytes % 4) {
                        for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                        }
                    } else {
                        for (var i = 0; i < thatSigBytes; i += 4) {
                            thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
                        }
                    }
                    this.sigBytes += thatSigBytes;
                    return this;
                },
                clamp: function() {
                    var words = this.words;
                    var sigBytes = this.sigBytes;
                    words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                    words.length = Math.ceil(sigBytes / 4);
                },
                clone: function() {
                    var clone = Base.clone.call(this);
                    clone.words = this.words.slice(0);
                    return clone;
                },
                random: function(nBytes) {
                    var words = [];
                    var r = function(m_w) {
                        var m_w = m_w;
                        var m_z = 987654321;
                        var mask = 4294967295;
                        return function() {
                            m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                            m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                            var result = (m_z << 16) + m_w & mask;
                            result /= 4294967296;
                            result += .5;
                            return result * (Math.random() > .5 ? 1 : -1);
                        };
                    };
                    for (var i = 0, rcache; i < nBytes; i += 4) {
                        var _r = r((rcache || Math.random()) * 4294967296);
                        rcache = _r() * 987654071;
                        words.push(_r() * 4294967296 | 0);
                    }
                    return new WordArray.init(words, nBytes);
                }
            });
            var C_enc = C.enc = {};
            var Hex = C_enc.Hex = {
                stringify: function(wordArray) {
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var hexChars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        hexChars.push((bite >>> 4).toString(16));
                        hexChars.push((bite & 15).toString(16));
                    }
                    return hexChars.join("");
                },
                parse: function(hexStr) {
                    var hexStrLength = hexStr.length;
                    var words = [];
                    for (var i = 0; i < hexStrLength; i += 2) {
                        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                    }
                    return new WordArray.init(words, hexStrLength / 2);
                }
            };
            var Latin1 = C_enc.Latin1 = {
                stringify: function(wordArray) {
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var latin1Chars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        latin1Chars.push(String.fromCharCode(bite));
                    }
                    return latin1Chars.join("");
                },
                parse: function(latin1Str) {
                    var latin1StrLength = latin1Str.length;
                    var words = [];
                    for (var i = 0; i < latin1StrLength; i++) {
                        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                    }
                    return new WordArray.init(words, latin1StrLength);
                }
            };
            var Utf8 = C_enc.Utf8 = {
                stringify: function(wordArray) {
                    try {
                        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                    } catch (e) {
                        throw new Error("Malformed UTF-8 data");
                    }
                },
                parse: function(utf8Str) {
                    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
            };
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                reset: function() {
                    this._data = new WordArray.init();
                    this._nDataBytes = 0;
                },
                _append: function(data) {
                    if (typeof data == "string") {
                        data = Utf8.parse(data);
                    }
                    this._data.concat(data);
                    this._nDataBytes += data.sigBytes;
                },
                _process: function(doFlush) {
                    var data = this._data;
                    var dataWords = data.words;
                    var dataSigBytes = data.sigBytes;
                    var blockSize = this.blockSize;
                    var blockSizeBytes = blockSize * 4;
                    var nBlocksReady = dataSigBytes / blockSizeBytes;
                    if (doFlush) {
                        nBlocksReady = Math.ceil(nBlocksReady);
                    } else {
                        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                    }
                    var nWordsReady = nBlocksReady * blockSize;
                    var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
                    if (nWordsReady) {
                        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            this._doProcessBlock(dataWords, offset);
                        }
                        var processedWords = dataWords.splice(0, nWordsReady);
                        data.sigBytes -= nBytesReady;
                    }
                    return new WordArray.init(processedWords, nBytesReady);
                },
                clone: function() {
                    var clone = Base.clone.call(this);
                    clone._data = this._data.clone();
                    return clone;
                },
                _minBufferSize: 0
            });
            var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                cfg: Base.extend(),
                init: function(cfg) {
                    this.cfg = this.cfg.extend(cfg);
                    this.reset();
                },
                reset: function() {
                    BufferedBlockAlgorithm.reset.call(this);
                    this._doReset();
                },
                update: function(messageUpdate) {
                    this._append(messageUpdate);
                    this._process();
                    return this;
                },
                finalize: function(messageUpdate) {
                    if (messageUpdate) {
                        this._append(messageUpdate);
                    }
                    var hash = this._doFinalize();
                    return hash;
                },
                blockSize: 512 / 32,
                _createHelper: function(hasher) {
                    return function(message, cfg) {
                        return new hasher.init(cfg).finalize(message);
                    };
                },
                _createHmacHelper: function(hasher) {
                    return function(message, key) {
                        return new C_algo.HMAC.init(hasher, key).finalize(message);
                    };
                }
            });
            var C_algo = C.algo = {};
            return C;
        }(Math);
        return CryptoJS;
    });
}, function(module, exports, __webpack_require__) {
    var buffer = __webpack_require__(4);
    var Buffer = buffer.Buffer;
    function copyProps(src, dst) {
        for (var key in src) {
            dst[key] = src[key];
        }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module.exports = buffer;
    } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
    }
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
        }
        return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
        }
        var buf = Buffer(size);
        if (fill !== undefined) {
            if (typeof encoding === "string") {
                buf.fill(fill, encoding);
            } else {
                buf.fill(fill);
            }
        } else {
            buf.fill(0);
        }
        return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
        }
        return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
        if (false) {}
        if (!condition) {
            var error;
            if (format === undefined) {
                error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
            } else {
                var args = [ a, b, c, d, e, f ];
                var argIndex = 0;
                error = new Error(format.replace(/%s/g, function() {
                    return args[argIndex++];
                }));
                error.name = "Invariant Violation";
            }
            error.framesToPop = 1;
            throw error;
        }
    };
    module.exports = invariant;
}, function(module, exports, __webpack_require__) {
    (function(module) {
        (function(module, exports) {
            "use strict";
            function assert(val, msg) {
                if (!val) throw new Error(msg || "Assertion failed");
            }
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
                if (BN.isBN(number)) {
                    return number;
                }
                this.negative = 0;
                this.words = null;
                this.length = 0;
                this.red = null;
                if (number !== null) {
                    if (base === "le" || base === "be") {
                        endian = base;
                        base = 10;
                    }
                    this._init(number || 0, base || 10, endian || "be");
                }
            }
            if (typeof module === "object") {
                module.exports = BN;
            } else {
                exports.BN = BN;
            }
            BN.BN = BN;
            BN.wordSize = 26;
            var Buffer;
            try {
                Buffer = __webpack_require__(432).Buffer;
            } catch (e) {}
            BN.isBN = function isBN(num) {
                if (num instanceof BN) {
                    return true;
                }
                return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
            };
            BN.max = function max(left, right) {
                if (left.cmp(right) > 0) return left;
                return right;
            };
            BN.min = function min(left, right) {
                if (left.cmp(right) < 0) return left;
                return right;
            };
            BN.prototype._init = function init(number, base, endian) {
                if (typeof number === "number") {
                    return this._initNumber(number, base, endian);
                }
                if (typeof number === "object") {
                    return this._initArray(number, base, endian);
                }
                if (base === "hex") {
                    base = 16;
                }
                assert(base === (base | 0) && base >= 2 && base <= 36);
                number = number.toString().replace(/\s+/g, "");
                var start = 0;
                if (number[0] === "-") {
                    start++;
                }
                if (base === 16) {
                    this._parseHex(number, start);
                } else {
                    this._parseBase(number, base, start);
                }
                if (number[0] === "-") {
                    this.negative = 1;
                }
                this.strip();
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initNumber = function _initNumber(number, base, endian) {
                if (number < 0) {
                    this.negative = 1;
                    number = -number;
                }
                if (number < 67108864) {
                    this.words = [ number & 67108863 ];
                    this.length = 1;
                } else if (number < 4503599627370496) {
                    this.words = [ number & 67108863, number / 67108864 & 67108863 ];
                    this.length = 2;
                } else {
                    assert(number < 9007199254740992);
                    this.words = [ number & 67108863, number / 67108864 & 67108863, 1 ];
                    this.length = 3;
                }
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(number, base, endian) {
                assert(typeof number.length === "number");
                if (number.length <= 0) {
                    this.words = [ 0 ];
                    this.length = 1;
                    return this;
                }
                this.length = Math.ceil(number.length / 3);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    this.words[i] = 0;
                }
                var j, w;
                var off = 0;
                if (endian === "be") {
                    for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
                        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                } else if (endian === "le") {
                    for (i = 0, j = 0; i < number.length; i += 3) {
                        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                }
                return this.strip();
            };
            function parseHex(str, start, end) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r <<= 4;
                    if (c >= 49 && c <= 54) {
                        r |= c - 49 + 10;
                    } else if (c >= 17 && c <= 22) {
                        r |= c - 17 + 10;
                    } else {
                        r |= c & 15;
                    }
                }
                return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start) {
                this.length = Math.ceil((number.length - start) / 6);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    this.words[i] = 0;
                }
                var j, w;
                var off = 0;
                for (i = number.length - 6, j = 0; i >= start; i -= 6) {
                    w = parseHex(number, i, i + 6);
                    this.words[j] |= w << off & 67108863;
                    this.words[j + 1] |= w >>> 26 - off & 4194303;
                    off += 24;
                    if (off >= 26) {
                        off -= 26;
                        j++;
                    }
                }
                if (i + 6 !== start) {
                    w = parseHex(number, start, i + 6);
                    this.words[j] |= w << off & 67108863;
                    this.words[j + 1] |= w >>> 26 - off & 4194303;
                }
                this.strip();
            };
            function parseBase(str, start, end, mul) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r *= mul;
                    if (c >= 49) {
                        r += c - 49 + 10;
                    } else if (c >= 17) {
                        r += c - 17 + 10;
                    } else {
                        r += c;
                    }
                }
                return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
                this.words = [ 0 ];
                this.length = 1;
                for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
                    limbLen++;
                }
                limbLen--;
                limbPow = limbPow / base | 0;
                var total = number.length - start;
                var mod = total % limbLen;
                var end = Math.min(total, total - mod) + start;
                var word = 0;
                for (var i = start; i < end; i += limbLen) {
                    word = parseBase(number, i, i + limbLen, base);
                    this.imuln(limbPow);
                    if (this.words[0] + word < 67108864) {
                        this.words[0] += word;
                    } else {
                        this._iaddn(word);
                    }
                }
                if (mod !== 0) {
                    var pow = 1;
                    word = parseBase(number, i, number.length, base);
                    for (i = 0; i < mod; i++) {
                        pow *= base;
                    }
                    this.imuln(pow);
                    if (this.words[0] + word < 67108864) {
                        this.words[0] += word;
                    } else {
                        this._iaddn(word);
                    }
                }
            };
            BN.prototype.copy = function copy(dest) {
                dest.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    dest.words[i] = this.words[i];
                }
                dest.length = this.length;
                dest.negative = this.negative;
                dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
                var r = new BN(null);
                this.copy(r);
                return r;
            };
            BN.prototype._expand = function _expand(size) {
                while (this.length < size) {
                    this.words[this.length++] = 0;
                }
                return this;
            };
            BN.prototype.strip = function strip() {
                while (this.length > 1 && this.words[this.length - 1] === 0) {
                    this.length--;
                }
                return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
                if (this.length === 1 && this.words[0] === 0) {
                    this.negative = 0;
                }
                return this;
            };
            BN.prototype.inspect = function inspect() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var zeros = [ "", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000" ];
            var groupSizes = [ 0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ];
            var groupBases = [ 0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176 ];
            BN.prototype.toString = function toString(base, padding) {
                base = base || 10;
                padding = padding | 0 || 1;
                var out;
                if (base === 16 || base === "hex") {
                    out = "";
                    var off = 0;
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = this.words[i];
                        var word = ((w << off | carry) & 16777215).toString(16);
                        carry = w >>> 24 - off & 16777215;
                        if (carry !== 0 || i !== this.length - 1) {
                            out = zeros[6 - word.length] + word + out;
                        } else {
                            out = word + out;
                        }
                        off += 2;
                        if (off >= 26) {
                            off -= 26;
                            i--;
                        }
                    }
                    if (carry !== 0) {
                        out = carry.toString(16) + out;
                    }
                    while (out.length % padding !== 0) {
                        out = "0" + out;
                    }
                    if (this.negative !== 0) {
                        out = "-" + out;
                    }
                    return out;
                }
                if (base === (base | 0) && base >= 2 && base <= 36) {
                    var groupSize = groupSizes[base];
                    var groupBase = groupBases[base];
                    out = "";
                    var c = this.clone();
                    c.negative = 0;
                    while (!c.isZero()) {
                        var r = c.modn(groupBase).toString(base);
                        c = c.idivn(groupBase);
                        if (!c.isZero()) {
                            out = zeros[groupSize - r.length] + r + out;
                        } else {
                            out = r + out;
                        }
                    }
                    if (this.isZero()) {
                        out = "0" + out;
                    }
                    while (out.length % padding !== 0) {
                        out = "0" + out;
                    }
                    if (this.negative !== 0) {
                        out = "-" + out;
                    }
                    return out;
                }
                assert(false, "Base should be between 2 and 36");
            };
            BN.prototype.toNumber = function toNumber() {
                var ret = this.words[0];
                if (this.length === 2) {
                    ret += this.words[1] * 67108864;
                } else if (this.length === 3 && this.words[2] === 1) {
                    ret += 4503599627370496 + this.words[1] * 67108864;
                } else if (this.length > 2) {
                    assert(false, "Number can only safely store up to 53 bits");
                }
                return this.negative !== 0 ? -ret : ret;
            };
            BN.prototype.toJSON = function toJSON() {
                return this.toString(16);
            };
            BN.prototype.toBuffer = function toBuffer(endian, length) {
                assert(typeof Buffer !== "undefined");
                return this.toArrayLike(Buffer, endian, length);
            };
            BN.prototype.toArray = function toArray(endian, length) {
                return this.toArrayLike(Array, endian, length);
            };
            BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
                var byteLength = this.byteLength();
                var reqLength = length || Math.max(1, byteLength);
                assert(byteLength <= reqLength, "byte array longer than desired length");
                assert(reqLength > 0, "Requested array length <= 0");
                this.strip();
                var littleEndian = endian === "le";
                var res = new ArrayType(reqLength);
                var b, i;
                var q = this.clone();
                if (!littleEndian) {
                    for (i = 0; i < reqLength - byteLength; i++) {
                        res[i] = 0;
                    }
                    for (i = 0; !q.isZero(); i++) {
                        b = q.andln(255);
                        q.iushrn(8);
                        res[reqLength - i - 1] = b;
                    }
                } else {
                    for (i = 0; !q.isZero(); i++) {
                        b = q.andln(255);
                        q.iushrn(8);
                        res[i] = b;
                    }
                    for (;i < reqLength; i++) {
                        res[i] = 0;
                    }
                }
                return res;
            };
            if (Math.clz32) {
                BN.prototype._countBits = function _countBits(w) {
                    return 32 - Math.clz32(w);
                };
            } else {
                BN.prototype._countBits = function _countBits(w) {
                    var t = w;
                    var r = 0;
                    if (t >= 4096) {
                        r += 13;
                        t >>>= 13;
                    }
                    if (t >= 64) {
                        r += 7;
                        t >>>= 7;
                    }
                    if (t >= 8) {
                        r += 4;
                        t >>>= 4;
                    }
                    if (t >= 2) {
                        r += 2;
                        t >>>= 2;
                    }
                    return r + t;
                };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
                if (w === 0) return 26;
                var t = w;
                var r = 0;
                if ((t & 8191) === 0) {
                    r += 13;
                    t >>>= 13;
                }
                if ((t & 127) === 0) {
                    r += 7;
                    t >>>= 7;
                }
                if ((t & 15) === 0) {
                    r += 4;
                    t >>>= 4;
                }
                if ((t & 3) === 0) {
                    r += 2;
                    t >>>= 2;
                }
                if ((t & 1) === 0) {
                    r++;
                }
                return r;
            };
            BN.prototype.bitLength = function bitLength() {
                var w = this.words[this.length - 1];
                var hi = this._countBits(w);
                return (this.length - 1) * 26 + hi;
            };
            function toBitArray(num) {
                var w = new Array(num.bitLength());
                for (var bit = 0; bit < w.length; bit++) {
                    var off = bit / 26 | 0;
                    var wbit = bit % 26;
                    w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
                }
                return w;
            }
            BN.prototype.zeroBits = function zeroBits() {
                if (this.isZero()) return 0;
                var r = 0;
                for (var i = 0; i < this.length; i++) {
                    var b = this._zeroBits(this.words[i]);
                    r += b;
                    if (b !== 26) break;
                }
                return r;
            };
            BN.prototype.byteLength = function byteLength() {
                return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.toTwos = function toTwos(width) {
                if (this.negative !== 0) {
                    return this.abs().inotn(width).iaddn(1);
                }
                return this.clone();
            };
            BN.prototype.fromTwos = function fromTwos(width) {
                if (this.testn(width - 1)) {
                    return this.notn(width).iaddn(1).ineg();
                }
                return this.clone();
            };
            BN.prototype.isNeg = function isNeg() {
                return this.negative !== 0;
            };
            BN.prototype.neg = function neg() {
                return this.clone().ineg();
            };
            BN.prototype.ineg = function ineg() {
                if (!this.isZero()) {
                    this.negative ^= 1;
                }
                return this;
            };
            BN.prototype.iuor = function iuor(num) {
                while (this.length < num.length) {
                    this.words[this.length++] = 0;
                }
                for (var i = 0; i < num.length; i++) {
                    this.words[i] = this.words[i] | num.words[i];
                }
                return this.strip();
            };
            BN.prototype.ior = function ior(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuor(num);
            };
            BN.prototype.or = function or(num) {
                if (this.length > num.length) return this.clone().ior(num);
                return num.clone().ior(this);
            };
            BN.prototype.uor = function uor(num) {
                if (this.length > num.length) return this.clone().iuor(num);
                return num.clone().iuor(this);
            };
            BN.prototype.iuand = function iuand(num) {
                var b;
                if (this.length > num.length) {
                    b = num;
                } else {
                    b = this;
                }
                for (var i = 0; i < b.length; i++) {
                    this.words[i] = this.words[i] & num.words[i];
                }
                this.length = b.length;
                return this.strip();
            };
            BN.prototype.iand = function iand(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuand(num);
            };
            BN.prototype.and = function and(num) {
                if (this.length > num.length) return this.clone().iand(num);
                return num.clone().iand(this);
            };
            BN.prototype.uand = function uand(num) {
                if (this.length > num.length) return this.clone().iuand(num);
                return num.clone().iuand(this);
            };
            BN.prototype.iuxor = function iuxor(num) {
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                for (var i = 0; i < b.length; i++) {
                    this.words[i] = a.words[i] ^ b.words[i];
                }
                if (this !== a) {
                    for (;i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }
                this.length = a.length;
                return this.strip();
            };
            BN.prototype.ixor = function ixor(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuxor(num);
            };
            BN.prototype.xor = function xor(num) {
                if (this.length > num.length) return this.clone().ixor(num);
                return num.clone().ixor(this);
            };
            BN.prototype.uxor = function uxor(num) {
                if (this.length > num.length) return this.clone().iuxor(num);
                return num.clone().iuxor(this);
            };
            BN.prototype.inotn = function inotn(width) {
                assert(typeof width === "number" && width >= 0);
                var bytesNeeded = Math.ceil(width / 26) | 0;
                var bitsLeft = width % 26;
                this._expand(bytesNeeded);
                if (bitsLeft > 0) {
                    bytesNeeded--;
                }
                for (var i = 0; i < bytesNeeded; i++) {
                    this.words[i] = ~this.words[i] & 67108863;
                }
                if (bitsLeft > 0) {
                    this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
                }
                return this.strip();
            };
            BN.prototype.notn = function notn(width) {
                return this.clone().inotn(width);
            };
            BN.prototype.setn = function setn(bit, val) {
                assert(typeof bit === "number" && bit >= 0);
                var off = bit / 26 | 0;
                var wbit = bit % 26;
                this._expand(off + 1);
                if (val) {
                    this.words[off] = this.words[off] | 1 << wbit;
                } else {
                    this.words[off] = this.words[off] & ~(1 << wbit);
                }
                return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
                var r;
                if (this.negative !== 0 && num.negative === 0) {
                    this.negative = 0;
                    r = this.isub(num);
                    this.negative ^= 1;
                    return this._normSign();
                } else if (this.negative === 0 && num.negative !== 0) {
                    num.negative = 0;
                    r = this.isub(num);
                    num.negative = 1;
                    return r._normSign();
                }
                var a, b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    r = (a.words[i] | 0) + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                this.length = a.length;
                if (carry !== 0) {
                    this.words[this.length] = carry;
                    this.length++;
                } else if (a !== this) {
                    for (;i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }
                return this;
            };
            BN.prototype.add = function add(num) {
                var res;
                if (num.negative !== 0 && this.negative === 0) {
                    num.negative = 0;
                    res = this.sub(num);
                    num.negative ^= 1;
                    return res;
                } else if (num.negative === 0 && this.negative !== 0) {
                    this.negative = 0;
                    res = num.sub(this);
                    this.negative = 1;
                    return res;
                }
                if (this.length > num.length) return this.clone().iadd(num);
                return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
                if (num.negative !== 0) {
                    num.negative = 0;
                    var r = this.iadd(num);
                    num.negative = 1;
                    return r._normSign();
                } else if (this.negative !== 0) {
                    this.negative = 0;
                    this.iadd(num);
                    this.negative = 1;
                    return this._normSign();
                }
                var cmp = this.cmp(num);
                if (cmp === 0) {
                    this.negative = 0;
                    this.length = 1;
                    this.words[0] = 0;
                    return this;
                }
                var a, b;
                if (cmp > 0) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    r = (a.words[i] | 0) + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                if (carry === 0 && i < a.length && a !== this) {
                    for (;i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }
                this.length = Math.max(this.length, i);
                if (a !== this) {
                    this.negative = 1;
                }
                return this.strip();
            };
            BN.prototype.sub = function sub(num) {
                return this.clone().isub(num);
            };
            function smallMulTo(self, num, out) {
                out.negative = num.negative ^ self.negative;
                var len = self.length + num.length | 0;
                out.length = len;
                len = len - 1 | 0;
                var a = self.words[0] | 0;
                var b = num.words[0] | 0;
                var r = a * b;
                var lo = r & 67108863;
                var carry = r / 67108864 | 0;
                out.words[0] = lo;
                for (var k = 1; k < len; k++) {
                    var ncarry = carry >>> 26;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                        var i = k - j | 0;
                        a = self.words[i] | 0;
                        b = num.words[j] | 0;
                        r = a * b + rword;
                        ncarry += r / 67108864 | 0;
                        rword = r & 67108863;
                    }
                    out.words[k] = rword | 0;
                    carry = ncarry | 0;
                }
                if (carry !== 0) {
                    out.words[k] = carry | 0;
                } else {
                    out.length--;
                }
                return out.strip();
            }
            var comb10MulTo = function comb10MulTo(self, num, out) {
                var a = self.words;
                var b = num.words;
                var o = out.words;
                var c = 0;
                var lo;
                var mid;
                var hi;
                var a0 = a[0] | 0;
                var al0 = a0 & 8191;
                var ah0 = a0 >>> 13;
                var a1 = a[1] | 0;
                var al1 = a1 & 8191;
                var ah1 = a1 >>> 13;
                var a2 = a[2] | 0;
                var al2 = a2 & 8191;
                var ah2 = a2 >>> 13;
                var a3 = a[3] | 0;
                var al3 = a3 & 8191;
                var ah3 = a3 >>> 13;
                var a4 = a[4] | 0;
                var al4 = a4 & 8191;
                var ah4 = a4 >>> 13;
                var a5 = a[5] | 0;
                var al5 = a5 & 8191;
                var ah5 = a5 >>> 13;
                var a6 = a[6] | 0;
                var al6 = a6 & 8191;
                var ah6 = a6 >>> 13;
                var a7 = a[7] | 0;
                var al7 = a7 & 8191;
                var ah7 = a7 >>> 13;
                var a8 = a[8] | 0;
                var al8 = a8 & 8191;
                var ah8 = a8 >>> 13;
                var a9 = a[9] | 0;
                var al9 = a9 & 8191;
                var ah9 = a9 >>> 13;
                var b0 = b[0] | 0;
                var bl0 = b0 & 8191;
                var bh0 = b0 >>> 13;
                var b1 = b[1] | 0;
                var bl1 = b1 & 8191;
                var bh1 = b1 >>> 13;
                var b2 = b[2] | 0;
                var bl2 = b2 & 8191;
                var bh2 = b2 >>> 13;
                var b3 = b[3] | 0;
                var bl3 = b3 & 8191;
                var bh3 = b3 >>> 13;
                var b4 = b[4] | 0;
                var bl4 = b4 & 8191;
                var bh4 = b4 >>> 13;
                var b5 = b[5] | 0;
                var bl5 = b5 & 8191;
                var bh5 = b5 >>> 13;
                var b6 = b[6] | 0;
                var bl6 = b6 & 8191;
                var bh6 = b6 >>> 13;
                var b7 = b[7] | 0;
                var bl7 = b7 & 8191;
                var bh7 = b7 >>> 13;
                var b8 = b[8] | 0;
                var bl8 = b8 & 8191;
                var bh8 = b8 >>> 13;
                var b9 = b[9] | 0;
                var bl9 = b9 & 8191;
                var bh9 = b9 >>> 13;
                out.negative = self.negative ^ num.negative;
                out.length = 19;
                lo = Math.imul(al0, bl0);
                mid = Math.imul(al0, bh0);
                mid = mid + Math.imul(ah0, bl0) | 0;
                hi = Math.imul(ah0, bh0);
                var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
                w0 &= 67108863;
                lo = Math.imul(al1, bl0);
                mid = Math.imul(al1, bh0);
                mid = mid + Math.imul(ah1, bl0) | 0;
                hi = Math.imul(ah1, bh0);
                lo = lo + Math.imul(al0, bl1) | 0;
                mid = mid + Math.imul(al0, bh1) | 0;
                mid = mid + Math.imul(ah0, bl1) | 0;
                hi = hi + Math.imul(ah0, bh1) | 0;
                var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
                w1 &= 67108863;
                lo = Math.imul(al2, bl0);
                mid = Math.imul(al2, bh0);
                mid = mid + Math.imul(ah2, bl0) | 0;
                hi = Math.imul(ah2, bh0);
                lo = lo + Math.imul(al1, bl1) | 0;
                mid = mid + Math.imul(al1, bh1) | 0;
                mid = mid + Math.imul(ah1, bl1) | 0;
                hi = hi + Math.imul(ah1, bh1) | 0;
                lo = lo + Math.imul(al0, bl2) | 0;
                mid = mid + Math.imul(al0, bh2) | 0;
                mid = mid + Math.imul(ah0, bl2) | 0;
                hi = hi + Math.imul(ah0, bh2) | 0;
                var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
                w2 &= 67108863;
                lo = Math.imul(al3, bl0);
                mid = Math.imul(al3, bh0);
                mid = mid + Math.imul(ah3, bl0) | 0;
                hi = Math.imul(ah3, bh0);
                lo = lo + Math.imul(al2, bl1) | 0;
                mid = mid + Math.imul(al2, bh1) | 0;
                mid = mid + Math.imul(ah2, bl1) | 0;
                hi = hi + Math.imul(ah2, bh1) | 0;
                lo = lo + Math.imul(al1, bl2) | 0;
                mid = mid + Math.imul(al1, bh2) | 0;
                mid = mid + Math.imul(ah1, bl2) | 0;
                hi = hi + Math.imul(ah1, bh2) | 0;
                lo = lo + Math.imul(al0, bl3) | 0;
                mid = mid + Math.imul(al0, bh3) | 0;
                mid = mid + Math.imul(ah0, bl3) | 0;
                hi = hi + Math.imul(ah0, bh3) | 0;
                var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
                w3 &= 67108863;
                lo = Math.imul(al4, bl0);
                mid = Math.imul(al4, bh0);
                mid = mid + Math.imul(ah4, bl0) | 0;
                hi = Math.imul(ah4, bh0);
                lo = lo + Math.imul(al3, bl1) | 0;
                mid = mid + Math.imul(al3, bh1) | 0;
                mid = mid + Math.imul(ah3, bl1) | 0;
                hi = hi + Math.imul(ah3, bh1) | 0;
                lo = lo + Math.imul(al2, bl2) | 0;
                mid = mid + Math.imul(al2, bh2) | 0;
                mid = mid + Math.imul(ah2, bl2) | 0;
                hi = hi + Math.imul(ah2, bh2) | 0;
                lo = lo + Math.imul(al1, bl3) | 0;
                mid = mid + Math.imul(al1, bh3) | 0;
                mid = mid + Math.imul(ah1, bl3) | 0;
                hi = hi + Math.imul(ah1, bh3) | 0;
                lo = lo + Math.imul(al0, bl4) | 0;
                mid = mid + Math.imul(al0, bh4) | 0;
                mid = mid + Math.imul(ah0, bl4) | 0;
                hi = hi + Math.imul(ah0, bh4) | 0;
                var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
                w4 &= 67108863;
                lo = Math.imul(al5, bl0);
                mid = Math.imul(al5, bh0);
                mid = mid + Math.imul(ah5, bl0) | 0;
                hi = Math.imul(ah5, bh0);
                lo = lo + Math.imul(al4, bl1) | 0;
                mid = mid + Math.imul(al4, bh1) | 0;
                mid = mid + Math.imul(ah4, bl1) | 0;
                hi = hi + Math.imul(ah4, bh1) | 0;
                lo = lo + Math.imul(al3, bl2) | 0;
                mid = mid + Math.imul(al3, bh2) | 0;
                mid = mid + Math.imul(ah3, bl2) | 0;
                hi = hi + Math.imul(ah3, bh2) | 0;
                lo = lo + Math.imul(al2, bl3) | 0;
                mid = mid + Math.imul(al2, bh3) | 0;
                mid = mid + Math.imul(ah2, bl3) | 0;
                hi = hi + Math.imul(ah2, bh3) | 0;
                lo = lo + Math.imul(al1, bl4) | 0;
                mid = mid + Math.imul(al1, bh4) | 0;
                mid = mid + Math.imul(ah1, bl4) | 0;
                hi = hi + Math.imul(ah1, bh4) | 0;
                lo = lo + Math.imul(al0, bl5) | 0;
                mid = mid + Math.imul(al0, bh5) | 0;
                mid = mid + Math.imul(ah0, bl5) | 0;
                hi = hi + Math.imul(ah0, bh5) | 0;
                var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
                w5 &= 67108863;
                lo = Math.imul(al6, bl0);
                mid = Math.imul(al6, bh0);
                mid = mid + Math.imul(ah6, bl0) | 0;
                hi = Math.imul(ah6, bh0);
                lo = lo + Math.imul(al5, bl1) | 0;
                mid = mid + Math.imul(al5, bh1) | 0;
                mid = mid + Math.imul(ah5, bl1) | 0;
                hi = hi + Math.imul(ah5, bh1) | 0;
                lo = lo + Math.imul(al4, bl2) | 0;
                mid = mid + Math.imul(al4, bh2) | 0;
                mid = mid + Math.imul(ah4, bl2) | 0;
                hi = hi + Math.imul(ah4, bh2) | 0;
                lo = lo + Math.imul(al3, bl3) | 0;
                mid = mid + Math.imul(al3, bh3) | 0;
                mid = mid + Math.imul(ah3, bl3) | 0;
                hi = hi + Math.imul(ah3, bh3) | 0;
                lo = lo + Math.imul(al2, bl4) | 0;
                mid = mid + Math.imul(al2, bh4) | 0;
                mid = mid + Math.imul(ah2, bl4) | 0;
                hi = hi + Math.imul(ah2, bh4) | 0;
                lo = lo + Math.imul(al1, bl5) | 0;
                mid = mid + Math.imul(al1, bh5) | 0;
                mid = mid + Math.imul(ah1, bl5) | 0;
                hi = hi + Math.imul(ah1, bh5) | 0;
                lo = lo + Math.imul(al0, bl6) | 0;
                mid = mid + Math.imul(al0, bh6) | 0;
                mid = mid + Math.imul(ah0, bl6) | 0;
                hi = hi + Math.imul(ah0, bh6) | 0;
                var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
                w6 &= 67108863;
                lo = Math.imul(al7, bl0);
                mid = Math.imul(al7, bh0);
                mid = mid + Math.imul(ah7, bl0) | 0;
                hi = Math.imul(ah7, bh0);
                lo = lo + Math.imul(al6, bl1) | 0;
                mid = mid + Math.imul(al6, bh1) | 0;
                mid = mid + Math.imul(ah6, bl1) | 0;
                hi = hi + Math.imul(ah6, bh1) | 0;
                lo = lo + Math.imul(al5, bl2) | 0;
                mid = mid + Math.imul(al5, bh2) | 0;
                mid = mid + Math.imul(ah5, bl2) | 0;
                hi = hi + Math.imul(ah5, bh2) | 0;
                lo = lo + Math.imul(al4, bl3) | 0;
                mid = mid + Math.imul(al4, bh3) | 0;
                mid = mid + Math.imul(ah4, bl3) | 0;
                hi = hi + Math.imul(ah4, bh3) | 0;
                lo = lo + Math.imul(al3, bl4) | 0;
                mid = mid + Math.imul(al3, bh4) | 0;
                mid = mid + Math.imul(ah3, bl4) | 0;
                hi = hi + Math.imul(ah3, bh4) | 0;
                lo = lo + Math.imul(al2, bl5) | 0;
                mid = mid + Math.imul(al2, bh5) | 0;
                mid = mid + Math.imul(ah2, bl5) | 0;
                hi = hi + Math.imul(ah2, bh5) | 0;
                lo = lo + Math.imul(al1, bl6) | 0;
                mid = mid + Math.imul(al1, bh6) | 0;
                mid = mid + Math.imul(ah1, bl6) | 0;
                hi = hi + Math.imul(ah1, bh6) | 0;
                lo = lo + Math.imul(al0, bl7) | 0;
                mid = mid + Math.imul(al0, bh7) | 0;
                mid = mid + Math.imul(ah0, bl7) | 0;
                hi = hi + Math.imul(ah0, bh7) | 0;
                var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
                w7 &= 67108863;
                lo = Math.imul(al8, bl0);
                mid = Math.imul(al8, bh0);
                mid = mid + Math.imul(ah8, bl0) | 0;
                hi = Math.imul(ah8, bh0);
                lo = lo + Math.imul(al7, bl1) | 0;
                mid = mid + Math.imul(al7, bh1) | 0;
                mid = mid + Math.imul(ah7, bl1) | 0;
                hi = hi + Math.imul(ah7, bh1) | 0;
                lo = lo + Math.imul(al6, bl2) | 0;
                mid = mid + Math.imul(al6, bh2) | 0;
                mid = mid + Math.imul(ah6, bl2) | 0;
                hi = hi + Math.imul(ah6, bh2) | 0;
                lo = lo + Math.imul(al5, bl3) | 0;
                mid = mid + Math.imul(al5, bh3) | 0;
                mid = mid + Math.imul(ah5, bl3) | 0;
                hi = hi + Math.imul(ah5, bh3) | 0;
                lo = lo + Math.imul(al4, bl4) | 0;
                mid = mid + Math.imul(al4, bh4) | 0;
                mid = mid + Math.imul(ah4, bl4) | 0;
                hi = hi + Math.imul(ah4, bh4) | 0;
                lo = lo + Math.imul(al3, bl5) | 0;
                mid = mid + Math.imul(al3, bh5) | 0;
                mid = mid + Math.imul(ah3, bl5) | 0;
                hi = hi + Math.imul(ah3, bh5) | 0;
                lo = lo + Math.imul(al2, bl6) | 0;
                mid = mid + Math.imul(al2, bh6) | 0;
                mid = mid + Math.imul(ah2, bl6) | 0;
                hi = hi + Math.imul(ah2, bh6) | 0;
                lo = lo + Math.imul(al1, bl7) | 0;
                mid = mid + Math.imul(al1, bh7) | 0;
                mid = mid + Math.imul(ah1, bl7) | 0;
                hi = hi + Math.imul(ah1, bh7) | 0;
                lo = lo + Math.imul(al0, bl8) | 0;
                mid = mid + Math.imul(al0, bh8) | 0;
                mid = mid + Math.imul(ah0, bl8) | 0;
                hi = hi + Math.imul(ah0, bh8) | 0;
                var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
                w8 &= 67108863;
                lo = Math.imul(al9, bl0);
                mid = Math.imul(al9, bh0);
                mid = mid + Math.imul(ah9, bl0) | 0;
                hi = Math.imul(ah9, bh0);
                lo = lo + Math.imul(al8, bl1) | 0;
                mid = mid + Math.imul(al8, bh1) | 0;
                mid = mid + Math.imul(ah8, bl1) | 0;
                hi = hi + Math.imul(ah8, bh1) | 0;
                lo = lo + Math.imul(al7, bl2) | 0;
                mid = mid + Math.imul(al7, bh2) | 0;
                mid = mid + Math.imul(ah7, bl2) | 0;
                hi = hi + Math.imul(ah7, bh2) | 0;
                lo = lo + Math.imul(al6, bl3) | 0;
                mid = mid + Math.imul(al6, bh3) | 0;
                mid = mid + Math.imul(ah6, bl3) | 0;
                hi = hi + Math.imul(ah6, bh3) | 0;
                lo = lo + Math.imul(al5, bl4) | 0;
                mid = mid + Math.imul(al5, bh4) | 0;
                mid = mid + Math.imul(ah5, bl4) | 0;
                hi = hi + Math.imul(ah5, bh4) | 0;
                lo = lo + Math.imul(al4, bl5) | 0;
                mid = mid + Math.imul(al4, bh5) | 0;
                mid = mid + Math.imul(ah4, bl5) | 0;
                hi = hi + Math.imul(ah4, bh5) | 0;
                lo = lo + Math.imul(al3, bl6) | 0;
                mid = mid + Math.imul(al3, bh6) | 0;
                mid = mid + Math.imul(ah3, bl6) | 0;
                hi = hi + Math.imul(ah3, bh6) | 0;
                lo = lo + Math.imul(al2, bl7) | 0;
                mid = mid + Math.imul(al2, bh7) | 0;
                mid = mid + Math.imul(ah2, bl7) | 0;
                hi = hi + Math.imul(ah2, bh7) | 0;
                lo = lo + Math.imul(al1, bl8) | 0;
                mid = mid + Math.imul(al1, bh8) | 0;
                mid = mid + Math.imul(ah1, bl8) | 0;
                hi = hi + Math.imul(ah1, bh8) | 0;
                lo = lo + Math.imul(al0, bl9) | 0;
                mid = mid + Math.imul(al0, bh9) | 0;
                mid = mid + Math.imul(ah0, bl9) | 0;
                hi = hi + Math.imul(ah0, bh9) | 0;
                var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
                w9 &= 67108863;
                lo = Math.imul(al9, bl1);
                mid = Math.imul(al9, bh1);
                mid = mid + Math.imul(ah9, bl1) | 0;
                hi = Math.imul(ah9, bh1);
                lo = lo + Math.imul(al8, bl2) | 0;
                mid = mid + Math.imul(al8, bh2) | 0;
                mid = mid + Math.imul(ah8, bl2) | 0;
                hi = hi + Math.imul(ah8, bh2) | 0;
                lo = lo + Math.imul(al7, bl3) | 0;
                mid = mid + Math.imul(al7, bh3) | 0;
                mid = mid + Math.imul(ah7, bl3) | 0;
                hi = hi + Math.imul(ah7, bh3) | 0;
                lo = lo + Math.imul(al6, bl4) | 0;
                mid = mid + Math.imul(al6, bh4) | 0;
                mid = mid + Math.imul(ah6, bl4) | 0;
                hi = hi + Math.imul(ah6, bh4) | 0;
                lo = lo + Math.imul(al5, bl5) | 0;
                mid = mid + Math.imul(al5, bh5) | 0;
                mid = mid + Math.imul(ah5, bl5) | 0;
                hi = hi + Math.imul(ah5, bh5) | 0;
                lo = lo + Math.imul(al4, bl6) | 0;
                mid = mid + Math.imul(al4, bh6) | 0;
                mid = mid + Math.imul(ah4, bl6) | 0;
                hi = hi + Math.imul(ah4, bh6) | 0;
                lo = lo + Math.imul(al3, bl7) | 0;
                mid = mid + Math.imul(al3, bh7) | 0;
                mid = mid + Math.imul(ah3, bl7) | 0;
                hi = hi + Math.imul(ah3, bh7) | 0;
                lo = lo + Math.imul(al2, bl8) | 0;
                mid = mid + Math.imul(al2, bh8) | 0;
                mid = mid + Math.imul(ah2, bl8) | 0;
                hi = hi + Math.imul(ah2, bh8) | 0;
                lo = lo + Math.imul(al1, bl9) | 0;
                mid = mid + Math.imul(al1, bh9) | 0;
                mid = mid + Math.imul(ah1, bl9) | 0;
                hi = hi + Math.imul(ah1, bh9) | 0;
                var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
                w10 &= 67108863;
                lo = Math.imul(al9, bl2);
                mid = Math.imul(al9, bh2);
                mid = mid + Math.imul(ah9, bl2) | 0;
                hi = Math.imul(ah9, bh2);
                lo = lo + Math.imul(al8, bl3) | 0;
                mid = mid + Math.imul(al8, bh3) | 0;
                mid = mid + Math.imul(ah8, bl3) | 0;
                hi = hi + Math.imul(ah8, bh3) | 0;
                lo = lo + Math.imul(al7, bl4) | 0;
                mid = mid + Math.imul(al7, bh4) | 0;
                mid = mid + Math.imul(ah7, bl4) | 0;
                hi = hi + Math.imul(ah7, bh4) | 0;
                lo = lo + Math.imul(al6, bl5) | 0;
                mid = mid + Math.imul(al6, bh5) | 0;
                mid = mid + Math.imul(ah6, bl5) | 0;
                hi = hi + Math.imul(ah6, bh5) | 0;
                lo = lo + Math.imul(al5, bl6) | 0;
                mid = mid + Math.imul(al5, bh6) | 0;
                mid = mid + Math.imul(ah5, bl6) | 0;
                hi = hi + Math.imul(ah5, bh6) | 0;
                lo = lo + Math.imul(al4, bl7) | 0;
                mid = mid + Math.imul(al4, bh7) | 0;
                mid = mid + Math.imul(ah4, bl7) | 0;
                hi = hi + Math.imul(ah4, bh7) | 0;
                lo = lo + Math.imul(al3, bl8) | 0;
                mid = mid + Math.imul(al3, bh8) | 0;
                mid = mid + Math.imul(ah3, bl8) | 0;
                hi = hi + Math.imul(ah3, bh8) | 0;
                lo = lo + Math.imul(al2, bl9) | 0;
                mid = mid + Math.imul(al2, bh9) | 0;
                mid = mid + Math.imul(ah2, bl9) | 0;
                hi = hi + Math.imul(ah2, bh9) | 0;
                var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
                w11 &= 67108863;
                lo = Math.imul(al9, bl3);
                mid = Math.imul(al9, bh3);
                mid = mid + Math.imul(ah9, bl3) | 0;
                hi = Math.imul(ah9, bh3);
                lo = lo + Math.imul(al8, bl4) | 0;
                mid = mid + Math.imul(al8, bh4) | 0;
                mid = mid + Math.imul(ah8, bl4) | 0;
                hi = hi + Math.imul(ah8, bh4) | 0;
                lo = lo + Math.imul(al7, bl5) | 0;
                mid = mid + Math.imul(al7, bh5) | 0;
                mid = mid + Math.imul(ah7, bl5) | 0;
                hi = hi + Math.imul(ah7, bh5) | 0;
                lo = lo + Math.imul(al6, bl6) | 0;
                mid = mid + Math.imul(al6, bh6) | 0;
                mid = mid + Math.imul(ah6, bl6) | 0;
                hi = hi + Math.imul(ah6, bh6) | 0;
                lo = lo + Math.imul(al5, bl7) | 0;
                mid = mid + Math.imul(al5, bh7) | 0;
                mid = mid + Math.imul(ah5, bl7) | 0;
                hi = hi + Math.imul(ah5, bh7) | 0;
                lo = lo + Math.imul(al4, bl8) | 0;
                mid = mid + Math.imul(al4, bh8) | 0;
                mid = mid + Math.imul(ah4, bl8) | 0;
                hi = hi + Math.imul(ah4, bh8) | 0;
                lo = lo + Math.imul(al3, bl9) | 0;
                mid = mid + Math.imul(al3, bh9) | 0;
                mid = mid + Math.imul(ah3, bl9) | 0;
                hi = hi + Math.imul(ah3, bh9) | 0;
                var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
                w12 &= 67108863;
                lo = Math.imul(al9, bl4);
                mid = Math.imul(al9, bh4);
                mid = mid + Math.imul(ah9, bl4) | 0;
                hi = Math.imul(ah9, bh4);
                lo = lo + Math.imul(al8, bl5) | 0;
                mid = mid + Math.imul(al8, bh5) | 0;
                mid = mid + Math.imul(ah8, bl5) | 0;
                hi = hi + Math.imul(ah8, bh5) | 0;
                lo = lo + Math.imul(al7, bl6) | 0;
                mid = mid + Math.imul(al7, bh6) | 0;
                mid = mid + Math.imul(ah7, bl6) | 0;
                hi = hi + Math.imul(ah7, bh6) | 0;
                lo = lo + Math.imul(al6, bl7) | 0;
                mid = mid + Math.imul(al6, bh7) | 0;
                mid = mid + Math.imul(ah6, bl7) | 0;
                hi = hi + Math.imul(ah6, bh7) | 0;
                lo = lo + Math.imul(al5, bl8) | 0;
                mid = mid + Math.imul(al5, bh8) | 0;
                mid = mid + Math.imul(ah5, bl8) | 0;
                hi = hi + Math.imul(ah5, bh8) | 0;
                lo = lo + Math.imul(al4, bl9) | 0;
                mid = mid + Math.imul(al4, bh9) | 0;
                mid = mid + Math.imul(ah4, bl9) | 0;
                hi = hi + Math.imul(ah4, bh9) | 0;
                var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
                w13 &= 67108863;
                lo = Math.imul(al9, bl5);
                mid = Math.imul(al9, bh5);
                mid = mid + Math.imul(ah9, bl5) | 0;
                hi = Math.imul(ah9, bh5);
                lo = lo + Math.imul(al8, bl6) | 0;
                mid = mid + Math.imul(al8, bh6) | 0;
                mid = mid + Math.imul(ah8, bl6) | 0;
                hi = hi + Math.imul(ah8, bh6) | 0;
                lo = lo + Math.imul(al7, bl7) | 0;
                mid = mid + Math.imul(al7, bh7) | 0;
                mid = mid + Math.imul(ah7, bl7) | 0;
                hi = hi + Math.imul(ah7, bh7) | 0;
                lo = lo + Math.imul(al6, bl8) | 0;
                mid = mid + Math.imul(al6, bh8) | 0;
                mid = mid + Math.imul(ah6, bl8) | 0;
                hi = hi + Math.imul(ah6, bh8) | 0;
                lo = lo + Math.imul(al5, bl9) | 0;
                mid = mid + Math.imul(al5, bh9) | 0;
                mid = mid + Math.imul(ah5, bl9) | 0;
                hi = hi + Math.imul(ah5, bh9) | 0;
                var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
                w14 &= 67108863;
                lo = Math.imul(al9, bl6);
                mid = Math.imul(al9, bh6);
                mid = mid + Math.imul(ah9, bl6) | 0;
                hi = Math.imul(ah9, bh6);
                lo = lo + Math.imul(al8, bl7) | 0;
                mid = mid + Math.imul(al8, bh7) | 0;
                mid = mid + Math.imul(ah8, bl7) | 0;
                hi = hi + Math.imul(ah8, bh7) | 0;
                lo = lo + Math.imul(al7, bl8) | 0;
                mid = mid + Math.imul(al7, bh8) | 0;
                mid = mid + Math.imul(ah7, bl8) | 0;
                hi = hi + Math.imul(ah7, bh8) | 0;
                lo = lo + Math.imul(al6, bl9) | 0;
                mid = mid + Math.imul(al6, bh9) | 0;
                mid = mid + Math.imul(ah6, bl9) | 0;
                hi = hi + Math.imul(ah6, bh9) | 0;
                var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
                w15 &= 67108863;
                lo = Math.imul(al9, bl7);
                mid = Math.imul(al9, bh7);
                mid = mid + Math.imul(ah9, bl7) | 0;
                hi = Math.imul(ah9, bh7);
                lo = lo + Math.imul(al8, bl8) | 0;
                mid = mid + Math.imul(al8, bh8) | 0;
                mid = mid + Math.imul(ah8, bl8) | 0;
                hi = hi + Math.imul(ah8, bh8) | 0;
                lo = lo + Math.imul(al7, bl9) | 0;
                mid = mid + Math.imul(al7, bh9) | 0;
                mid = mid + Math.imul(ah7, bl9) | 0;
                hi = hi + Math.imul(ah7, bh9) | 0;
                var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
                w16 &= 67108863;
                lo = Math.imul(al9, bl8);
                mid = Math.imul(al9, bh8);
                mid = mid + Math.imul(ah9, bl8) | 0;
                hi = Math.imul(ah9, bh8);
                lo = lo + Math.imul(al8, bl9) | 0;
                mid = mid + Math.imul(al8, bh9) | 0;
                mid = mid + Math.imul(ah8, bl9) | 0;
                hi = hi + Math.imul(ah8, bh9) | 0;
                var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
                w17 &= 67108863;
                lo = Math.imul(al9, bl9);
                mid = Math.imul(al9, bh9);
                mid = mid + Math.imul(ah9, bl9) | 0;
                hi = Math.imul(ah9, bh9);
                var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
                w18 &= 67108863;
                o[0] = w0;
                o[1] = w1;
                o[2] = w2;
                o[3] = w3;
                o[4] = w4;
                o[5] = w5;
                o[6] = w6;
                o[7] = w7;
                o[8] = w8;
                o[9] = w9;
                o[10] = w10;
                o[11] = w11;
                o[12] = w12;
                o[13] = w13;
                o[14] = w14;
                o[15] = w15;
                o[16] = w16;
                o[17] = w17;
                o[18] = w18;
                if (c !== 0) {
                    o[19] = c;
                    out.length++;
                }
                return out;
            };
            if (!Math.imul) {
                comb10MulTo = smallMulTo;
            }
            function bigMulTo(self, num, out) {
                out.negative = num.negative ^ self.negative;
                out.length = self.length + num.length;
                var carry = 0;
                var hncarry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    var ncarry = hncarry;
                    hncarry = 0;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = self.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                        hncarry += ncarry >>> 26;
                        ncarry &= 67108863;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                    ncarry = hncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }
                return out.strip();
            }
            function jumboMulTo(self, num, out) {
                var fftm = new FFTM();
                return fftm.mulp(self, num, out);
            }
            BN.prototype.mulTo = function mulTo(num, out) {
                var res;
                var len = this.length + num.length;
                if (this.length === 10 && num.length === 10) {
                    res = comb10MulTo(this, num, out);
                } else if (len < 63) {
                    res = smallMulTo(this, num, out);
                } else if (len < 1024) {
                    res = bigMulTo(this, num, out);
                } else {
                    res = jumboMulTo(this, num, out);
                }
                return res;
            };
            function FFTM(x, y) {
                this.x = x;
                this.y = y;
            }
            FFTM.prototype.makeRBT = function makeRBT(N) {
                var t = new Array(N);
                var l = BN.prototype._countBits(N) - 1;
                for (var i = 0; i < N; i++) {
                    t[i] = this.revBin(i, l, N);
                }
                return t;
            };
            FFTM.prototype.revBin = function revBin(x, l, N) {
                if (x === 0 || x === N - 1) return x;
                var rb = 0;
                for (var i = 0; i < l; i++) {
                    rb |= (x & 1) << l - i - 1;
                    x >>= 1;
                }
                return rb;
            };
            FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
                for (var i = 0; i < N; i++) {
                    rtws[i] = rws[rbt[i]];
                    itws[i] = iws[rbt[i]];
                }
            };
            FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
                this.permute(rbt, rws, iws, rtws, itws, N);
                for (var s = 1; s < N; s <<= 1) {
                    var l = s << 1;
                    var rtwdf = Math.cos(2 * Math.PI / l);
                    var itwdf = Math.sin(2 * Math.PI / l);
                    for (var p = 0; p < N; p += l) {
                        var rtwdf_ = rtwdf;
                        var itwdf_ = itwdf;
                        for (var j = 0; j < s; j++) {
                            var re = rtws[p + j];
                            var ie = itws[p + j];
                            var ro = rtws[p + j + s];
                            var io = itws[p + j + s];
                            var rx = rtwdf_ * ro - itwdf_ * io;
                            io = rtwdf_ * io + itwdf_ * ro;
                            ro = rx;
                            rtws[p + j] = re + ro;
                            itws[p + j] = ie + io;
                            rtws[p + j + s] = re - ro;
                            itws[p + j + s] = ie - io;
                            if (j !== l) {
                                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                                rtwdf_ = rx;
                            }
                        }
                    }
                }
            };
            FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
                var N = Math.max(m, n) | 1;
                var odd = N & 1;
                var i = 0;
                for (N = N / 2 | 0; N; N = N >>> 1) {
                    i++;
                }
                return 1 << i + 1 + odd;
            };
            FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
                if (N <= 1) return;
                for (var i = 0; i < N / 2; i++) {
                    var t = rws[i];
                    rws[i] = rws[N - i - 1];
                    rws[N - i - 1] = t;
                    t = iws[i];
                    iws[i] = -iws[N - i - 1];
                    iws[N - i - 1] = -t;
                }
            };
            FFTM.prototype.normalize13b = function normalize13b(ws, N) {
                var carry = 0;
                for (var i = 0; i < N / 2; i++) {
                    var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
                    ws[i] = w & 67108863;
                    if (w < 67108864) {
                        carry = 0;
                    } else {
                        carry = w / 67108864 | 0;
                    }
                }
                return ws;
            };
            FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
                var carry = 0;
                for (var i = 0; i < len; i++) {
                    carry = carry + (ws[i] | 0);
                    rws[2 * i] = carry & 8191;
                    carry = carry >>> 13;
                    rws[2 * i + 1] = carry & 8191;
                    carry = carry >>> 13;
                }
                for (i = 2 * len; i < N; ++i) {
                    rws[i] = 0;
                }
                assert(carry === 0);
                assert((carry & ~8191) === 0);
            };
            FFTM.prototype.stub = function stub(N) {
                var ph = new Array(N);
                for (var i = 0; i < N; i++) {
                    ph[i] = 0;
                }
                return ph;
            };
            FFTM.prototype.mulp = function mulp(x, y, out) {
                var N = 2 * this.guessLen13b(x.length, y.length);
                var rbt = this.makeRBT(N);
                var _ = this.stub(N);
                var rws = new Array(N);
                var rwst = new Array(N);
                var iwst = new Array(N);
                var nrws = new Array(N);
                var nrwst = new Array(N);
                var niwst = new Array(N);
                var rmws = out.words;
                rmws.length = N;
                this.convert13b(x.words, x.length, rws, N);
                this.convert13b(y.words, y.length, nrws, N);
                this.transform(rws, _, rwst, iwst, N, rbt);
                this.transform(nrws, _, nrwst, niwst, N, rbt);
                for (var i = 0; i < N; i++) {
                    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
                    rwst[i] = rx;
                }
                this.conjugate(rwst, iwst, N);
                this.transform(rwst, iwst, rmws, _, N, rbt);
                this.conjugate(rmws, _, N);
                this.normalize13b(rmws, N);
                out.negative = x.negative ^ y.negative;
                out.length = x.length + y.length;
                return out.strip();
            };
            BN.prototype.mul = function mul(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return this.mulTo(num, out);
            };
            BN.prototype.mulf = function mulf(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return jumboMulTo(this, num, out);
            };
            BN.prototype.imul = function imul(num) {
                return this.clone().mulTo(num, this);
            };
            BN.prototype.imuln = function imuln(num) {
                assert(typeof num === "number");
                assert(num < 67108864);
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = (this.words[i] | 0) * num;
                    var lo = (w & 67108863) + (carry & 67108863);
                    carry >>= 26;
                    carry += w / 67108864 | 0;
                    carry += lo >>> 26;
                    this.words[i] = lo & 67108863;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.muln = function muln(num) {
                return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
                return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
                return this.imul(this.clone());
            };
            BN.prototype.pow = function pow(num) {
                var w = toBitArray(num);
                if (w.length === 0) return new BN(1);
                var res = this;
                for (var i = 0; i < w.length; i++, res = res.sqr()) {
                    if (w[i] !== 0) break;
                }
                if (++i < w.length) {
                    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                        if (w[i] === 0) continue;
                        res = res.mul(q);
                    }
                }
                return res;
            };
            BN.prototype.iushln = function iushln(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                var carryMask = 67108863 >>> 26 - r << 26 - r;
                var i;
                if (r !== 0) {
                    var carry = 0;
                    for (i = 0; i < this.length; i++) {
                        var newCarry = this.words[i] & carryMask;
                        var c = (this.words[i] | 0) - newCarry << r;
                        this.words[i] = c | carry;
                        carry = newCarry >>> 26 - r;
                    }
                    if (carry) {
                        this.words[i] = carry;
                        this.length++;
                    }
                }
                if (s !== 0) {
                    for (i = this.length - 1; i >= 0; i--) {
                        this.words[i + s] = this.words[i];
                    }
                    for (i = 0; i < s; i++) {
                        this.words[i] = 0;
                    }
                    this.length += s;
                }
                return this.strip();
            };
            BN.prototype.ishln = function ishln(bits) {
                assert(this.negative === 0);
                return this.iushln(bits);
            };
            BN.prototype.iushrn = function iushrn(bits, hint, extended) {
                assert(typeof bits === "number" && bits >= 0);
                var h;
                if (hint) {
                    h = (hint - hint % 26) / 26;
                } else {
                    h = 0;
                }
                var r = bits % 26;
                var s = Math.min((bits - r) / 26, this.length);
                var mask = 67108863 ^ 67108863 >>> r << r;
                var maskedWords = extended;
                h -= s;
                h = Math.max(0, h);
                if (maskedWords) {
                    for (var i = 0; i < s; i++) {
                        maskedWords.words[i] = this.words[i];
                    }
                    maskedWords.length = s;
                }
                if (s === 0) {} else if (this.length > s) {
                    this.length -= s;
                    for (i = 0; i < this.length; i++) {
                        this.words[i] = this.words[i + s];
                    }
                } else {
                    this.words[0] = 0;
                    this.length = 1;
                }
                var carry = 0;
                for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                    var word = this.words[i] | 0;
                    this.words[i] = carry << 26 - r | word >>> r;
                    carry = word & mask;
                }
                if (maskedWords && carry !== 0) {
                    maskedWords.words[maskedWords.length++] = carry;
                }
                if (this.length === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                }
                return this.strip();
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                assert(this.negative === 0);
                return this.iushrn(bits, hint, extended);
            };
            BN.prototype.shln = function shln(bits) {
                return this.clone().ishln(bits);
            };
            BN.prototype.ushln = function ushln(bits) {
                return this.clone().iushln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
                return this.clone().ishrn(bits);
            };
            BN.prototype.ushrn = function ushrn(bits) {
                return this.clone().iushrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
                assert(typeof bit === "number" && bit >= 0);
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) return false;
                var w = this.words[s];
                return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                assert(this.negative === 0, "imaskn works only with positive numbers");
                if (this.length <= s) {
                    return this;
                }
                if (r !== 0) {
                    s++;
                }
                this.length = Math.min(s, this.length);
                if (r !== 0) {
                    var mask = 67108863 ^ 67108863 >>> r << r;
                    this.words[this.length - 1] &= mask;
                }
                return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
                return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
                assert(typeof num === "number");
                assert(num < 67108864);
                if (num < 0) return this.isubn(-num);
                if (this.negative !== 0) {
                    if (this.length === 1 && (this.words[0] | 0) < num) {
                        this.words[0] = num - (this.words[0] | 0);
                        this.negative = 0;
                        return this;
                    }
                    this.negative = 0;
                    this.isubn(num);
                    this.negative = 1;
                    return this;
                }
                return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
                this.words[0] += num;
                for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
                    this.words[i] -= 67108864;
                    if (i === this.length - 1) {
                        this.words[i + 1] = 1;
                    } else {
                        this.words[i + 1]++;
                    }
                }
                this.length = Math.max(this.length, i + 1);
                return this;
            };
            BN.prototype.isubn = function isubn(num) {
                assert(typeof num === "number");
                assert(num < 67108864);
                if (num < 0) return this.iaddn(-num);
                if (this.negative !== 0) {
                    this.negative = 0;
                    this.iaddn(num);
                    this.negative = 1;
                    return this;
                }
                this.words[0] -= num;
                if (this.length === 1 && this.words[0] < 0) {
                    this.words[0] = -this.words[0];
                    this.negative = 1;
                } else {
                    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                        this.words[i] += 67108864;
                        this.words[i + 1] -= 1;
                    }
                }
                return this.strip();
            };
            BN.prototype.addn = function addn(num) {
                return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
                return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
                this.negative = 0;
                return this;
            };
            BN.prototype.abs = function abs() {
                return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                var len = num.length + shift;
                var i;
                this._expand(len);
                var w;
                var carry = 0;
                for (i = 0; i < num.length; i++) {
                    w = (this.words[i + shift] | 0) + carry;
                    var right = (num.words[i] | 0) * mul;
                    w -= right & 67108863;
                    carry = (w >> 26) - (right / 67108864 | 0);
                    this.words[i + shift] = w & 67108863;
                }
                for (;i < this.length - shift; i++) {
                    w = (this.words[i + shift] | 0) + carry;
                    carry = w >> 26;
                    this.words[i + shift] = w & 67108863;
                }
                if (carry === 0) return this.strip();
                assert(carry === -1);
                carry = 0;
                for (i = 0; i < this.length; i++) {
                    w = -(this.words[i] | 0) + carry;
                    carry = w >> 26;
                    this.words[i] = w & 67108863;
                }
                this.negative = 1;
                return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
                var shift = this.length - num.length;
                var a = this.clone();
                var b = num;
                var bhi = b.words[b.length - 1] | 0;
                var bhiBits = this._countBits(bhi);
                shift = 26 - bhiBits;
                if (shift !== 0) {
                    b = b.ushln(shift);
                    a.iushln(shift);
                    bhi = b.words[b.length - 1] | 0;
                }
                var m = a.length - b.length;
                var q;
                if (mode !== "mod") {
                    q = new BN(null);
                    q.length = m + 1;
                    q.words = new Array(q.length);
                    for (var i = 0; i < q.length; i++) {
                        q.words[i] = 0;
                    }
                }
                var diff = a.clone()._ishlnsubmul(b, 1, m);
                if (diff.negative === 0) {
                    a = diff;
                    if (q) {
                        q.words[m] = 1;
                    }
                }
                for (var j = m - 1; j >= 0; j--) {
                    var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
                    qj = Math.min(qj / bhi | 0, 67108863);
                    a._ishlnsubmul(b, qj, j);
                    while (a.negative !== 0) {
                        qj--;
                        a.negative = 0;
                        a._ishlnsubmul(b, 1, j);
                        if (!a.isZero()) {
                            a.negative ^= 1;
                        }
                    }
                    if (q) {
                        q.words[j] = qj;
                    }
                }
                if (q) {
                    q.strip();
                }
                a.strip();
                if (mode !== "div" && shift !== 0) {
                    a.iushrn(shift);
                }
                return {
                    div: q || null,
                    mod: a
                };
            };
            BN.prototype.divmod = function divmod(num, mode, positive) {
                assert(!num.isZero());
                if (this.isZero()) {
                    return {
                        div: new BN(0),
                        mod: new BN(0)
                    };
                }
                var div, mod, res;
                if (this.negative !== 0 && num.negative === 0) {
                    res = this.neg().divmod(num, mode);
                    if (mode !== "mod") {
                        div = res.div.neg();
                    }
                    if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                            mod.iadd(num);
                        }
                    }
                    return {
                        div,
                        mod
                    };
                }
                if (this.negative === 0 && num.negative !== 0) {
                    res = this.divmod(num.neg(), mode);
                    if (mode !== "mod") {
                        div = res.div.neg();
                    }
                    return {
                        div,
                        mod: res.mod
                    };
                }
                if ((this.negative & num.negative) !== 0) {
                    res = this.neg().divmod(num.neg(), mode);
                    if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                            mod.isub(num);
                        }
                    }
                    return {
                        div: res.div,
                        mod
                    };
                }
                if (num.length > this.length || this.cmp(num) < 0) {
                    return {
                        div: new BN(0),
                        mod: this
                    };
                }
                if (num.length === 1) {
                    if (mode === "div") {
                        return {
                            div: this.divn(num.words[0]),
                            mod: null
                        };
                    }
                    if (mode === "mod") {
                        return {
                            div: null,
                            mod: new BN(this.modn(num.words[0]))
                        };
                    }
                    return {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    };
                }
                return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
                return this.divmod(num, "div", false).div;
            };
            BN.prototype.mod = function mod(num) {
                return this.divmod(num, "mod", false).mod;
            };
            BN.prototype.umod = function umod(num) {
                return this.divmod(num, "mod", true).mod;
            };
            BN.prototype.divRound = function divRound(num) {
                var dm = this.divmod(num);
                if (dm.mod.isZero()) return dm.div;
                var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
                var half = num.ushrn(1);
                var r2 = num.andln(1);
                var cmp = mod.cmp(half);
                if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
                return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
                assert(num <= 67108863);
                var p = (1 << 26) % num;
                var acc = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    acc = (p * acc + (this.words[i] | 0)) % num;
                }
                return acc;
            };
            BN.prototype.idivn = function idivn(num) {
                assert(num <= 67108863);
                var carry = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var w = (this.words[i] | 0) + carry * 67108864;
                    this.words[i] = w / num | 0;
                    carry = w % num;
                }
                return this.strip();
            };
            BN.prototype.divn = function divn(num) {
                return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
                assert(p.negative === 0);
                assert(!p.isZero());
                var x = this;
                var y = p.clone();
                if (x.negative !== 0) {
                    x = x.umod(p);
                } else {
                    x = x.clone();
                }
                var A = new BN(1);
                var B = new BN(0);
                var C = new BN(0);
                var D = new BN(1);
                var g = 0;
                while (x.isEven() && y.isEven()) {
                    x.iushrn(1);
                    y.iushrn(1);
                    ++g;
                }
                var yp = y.clone();
                var xp = x.clone();
                while (!x.isZero()) {
                    for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                    if (i > 0) {
                        x.iushrn(i);
                        while (i-- > 0) {
                            if (A.isOdd() || B.isOdd()) {
                                A.iadd(yp);
                                B.isub(xp);
                            }
                            A.iushrn(1);
                            B.iushrn(1);
                        }
                    }
                    for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                    if (j > 0) {
                        y.iushrn(j);
                        while (j-- > 0) {
                            if (C.isOdd() || D.isOdd()) {
                                C.iadd(yp);
                                D.isub(xp);
                            }
                            C.iushrn(1);
                            D.iushrn(1);
                        }
                    }
                    if (x.cmp(y) >= 0) {
                        x.isub(y);
                        A.isub(C);
                        B.isub(D);
                    } else {
                        y.isub(x);
                        C.isub(A);
                        D.isub(B);
                    }
                }
                return {
                    a: C,
                    b: D,
                    gcd: y.iushln(g)
                };
            };
            BN.prototype._invmp = function _invmp(p) {
                assert(p.negative === 0);
                assert(!p.isZero());
                var a = this;
                var b = p.clone();
                if (a.negative !== 0) {
                    a = a.umod(p);
                } else {
                    a = a.clone();
                }
                var x1 = new BN(1);
                var x2 = new BN(0);
                var delta = b.clone();
                while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                    for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                    if (i > 0) {
                        a.iushrn(i);
                        while (i-- > 0) {
                            if (x1.isOdd()) {
                                x1.iadd(delta);
                            }
                            x1.iushrn(1);
                        }
                    }
                    for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                    if (j > 0) {
                        b.iushrn(j);
                        while (j-- > 0) {
                            if (x2.isOdd()) {
                                x2.iadd(delta);
                            }
                            x2.iushrn(1);
                        }
                    }
                    if (a.cmp(b) >= 0) {
                        a.isub(b);
                        x1.isub(x2);
                    } else {
                        b.isub(a);
                        x2.isub(x1);
                    }
                }
                var res;
                if (a.cmpn(1) === 0) {
                    res = x1;
                } else {
                    res = x2;
                }
                if (res.cmpn(0) < 0) {
                    res.iadd(p);
                }
                return res;
            };
            BN.prototype.gcd = function gcd(num) {
                if (this.isZero()) return num.abs();
                if (num.isZero()) return this.abs();
                var a = this.clone();
                var b = num.clone();
                a.negative = 0;
                b.negative = 0;
                for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                    a.iushrn(1);
                    b.iushrn(1);
                }
                do {
                    while (a.isEven()) {
                        a.iushrn(1);
                    }
                    while (b.isEven()) {
                        b.iushrn(1);
                    }
                    var r = a.cmp(b);
                    if (r < 0) {
                        var t = a;
                        a = b;
                        b = t;
                    } else if (r === 0 || b.cmpn(1) === 0) {
                        break;
                    }
                    a.isub(b);
                } while (true);
                return b.iushln(shift);
            };
            BN.prototype.invm = function invm(num) {
                return this.egcd(num).a.umod(num);
            };
            BN.prototype.isEven = function isEven() {
                return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
                return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
                return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
                assert(typeof bit === "number");
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) {
                    this._expand(s + 1);
                    this.words[s] |= q;
                    return this;
                }
                var carry = q;
                for (var i = s; carry !== 0 && i < this.length; i++) {
                    var w = this.words[i] | 0;
                    w += carry;
                    carry = w >>> 26;
                    w &= 67108863;
                    this.words[i] = w;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.isZero = function isZero() {
                return this.length === 1 && this.words[0] === 0;
            };
            BN.prototype.cmpn = function cmpn(num) {
                var negative = num < 0;
                if (this.negative !== 0 && !negative) return -1;
                if (this.negative === 0 && negative) return 1;
                this.strip();
                var res;
                if (this.length > 1) {
                    res = 1;
                } else {
                    if (negative) {
                        num = -num;
                    }
                    assert(num <= 67108863, "Number is too big");
                    var w = this.words[0] | 0;
                    res = w === num ? 0 : w < num ? -1 : 1;
                }
                if (this.negative !== 0) return -res | 0;
                return res;
            };
            BN.prototype.cmp = function cmp(num) {
                if (this.negative !== 0 && num.negative === 0) return -1;
                if (this.negative === 0 && num.negative !== 0) return 1;
                var res = this.ucmp(num);
                if (this.negative !== 0) return -res | 0;
                return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
                if (this.length > num.length) return 1;
                if (this.length < num.length) return -1;
                var res = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var a = this.words[i] | 0;
                    var b = num.words[i] | 0;
                    if (a === b) continue;
                    if (a < b) {
                        res = -1;
                    } else if (a > b) {
                        res = 1;
                    }
                    break;
                }
                return res;
            };
            BN.prototype.gtn = function gtn(num) {
                return this.cmpn(num) === 1;
            };
            BN.prototype.gt = function gt(num) {
                return this.cmp(num) === 1;
            };
            BN.prototype.gten = function gten(num) {
                return this.cmpn(num) >= 0;
            };
            BN.prototype.gte = function gte(num) {
                return this.cmp(num) >= 0;
            };
            BN.prototype.ltn = function ltn(num) {
                return this.cmpn(num) === -1;
            };
            BN.prototype.lt = function lt(num) {
                return this.cmp(num) === -1;
            };
            BN.prototype.lten = function lten(num) {
                return this.cmpn(num) <= 0;
            };
            BN.prototype.lte = function lte(num) {
                return this.cmp(num) <= 0;
            };
            BN.prototype.eqn = function eqn(num) {
                return this.cmpn(num) === 0;
            };
            BN.prototype.eq = function eq(num) {
                return this.cmp(num) === 0;
            };
            BN.red = function red(num) {
                return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                assert(this.negative === 0, "red works only with positives");
                return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
                assert(this.red, "fromRed works only with numbers in reduction context");
                return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
                this.red = ctx;
                return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
                assert(this.red, "redAdd works only with red numbers");
                return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
                assert(this.red, "redIAdd works only with red numbers");
                return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
                assert(this.red, "redSub works only with red numbers");
                return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
                assert(this.red, "redISub works only with red numbers");
                return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
                assert(this.red, "redShl works only with red numbers");
                return this.red.shl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
                assert(this.red, "redSqr works only with red numbers");
                this.red._verify1(this);
                return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
                assert(this.red, "redISqr works only with red numbers");
                this.red._verify1(this);
                return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
                assert(this.red, "redSqrt works only with red numbers");
                this.red._verify1(this);
                return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
                assert(this.red, "redInvm works only with red numbers");
                this.red._verify1(this);
                return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
                assert(this.red, "redNeg works only with red numbers");
                this.red._verify1(this);
                return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
                assert(this.red && !num.red, "redPow(normalNum)");
                this.red._verify1(this);
                return this.red.pow(this, num);
            };
            var primes = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function MPrime(name, p) {
                this.name = name;
                this.p = new BN(p, 16);
                this.n = this.p.bitLength();
                this.k = new BN(1).iushln(this.n).isub(this.p);
                this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
                var tmp = new BN(null);
                tmp.words = new Array(Math.ceil(this.n / 13));
                return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
                var r = num;
                var rlen;
                do {
                    this.split(r, this.tmp);
                    r = this.imulK(r);
                    r = r.iadd(this.tmp);
                    rlen = r.bitLength();
                } while (rlen > this.n);
                var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                if (cmp === 0) {
                    r.words[0] = 0;
                    r.length = 1;
                } else if (cmp > 0) {
                    r.isub(this.p);
                } else {
                    r.strip();
                }
                return r;
            };
            MPrime.prototype.split = function split(input, out) {
                input.iushrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
                return num.imul(this.k);
            };
            function K256() {
                MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
                var mask = 4194303;
                var outLen = Math.min(input.length, 9);
                for (var i = 0; i < outLen; i++) {
                    output.words[i] = input.words[i];
                }
                output.length = outLen;
                if (input.length <= 9) {
                    input.words[0] = 0;
                    input.length = 1;
                    return;
                }
                var prev = input.words[9];
                output.words[output.length++] = prev & mask;
                for (i = 10; i < input.length; i++) {
                    var next = input.words[i] | 0;
                    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
                    prev = next;
                }
                prev >>>= 22;
                input.words[i - 10] = prev;
                if (prev === 0 && input.length > 10) {
                    input.length -= 10;
                } else {
                    input.length -= 9;
                }
            };
            K256.prototype.imulK = function imulK(num) {
                num.words[num.length] = 0;
                num.words[num.length + 1] = 0;
                num.length += 2;
                var lo = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = num.words[i] | 0;
                    lo += w * 977;
                    num.words[i] = lo & 67108863;
                    lo = w * 64 + (lo / 67108864 | 0);
                }
                if (num.words[num.length - 1] === 0) {
                    num.length--;
                    if (num.words[num.length - 1] === 0) {
                        num.length--;
                    }
                }
                return num;
            };
            function P224() {
                MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            inherits(P224, MPrime);
            function P192() {
                MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            inherits(P192, MPrime);
            function P25519() {
                MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var hi = (num.words[i] | 0) * 19 + carry;
                    var lo = hi & 67108863;
                    hi >>>= 26;
                    num.words[i] = lo;
                    carry = hi;
                }
                if (carry !== 0) {
                    num.words[num.length++] = carry;
                }
                return num;
            };
            BN._prime = function prime(name) {
                if (primes[name]) return primes[name];
                var prime;
                if (name === "k256") {
                    prime = new K256();
                } else if (name === "p224") {
                    prime = new P224();
                } else if (name === "p192") {
                    prime = new P192();
                } else if (name === "p25519") {
                    prime = new P25519();
                } else {
                    throw new Error("Unknown prime " + name);
                }
                primes[name] = prime;
                return prime;
            };
            function Red(m) {
                if (typeof m === "string") {
                    var prime = BN._prime(m);
                    this.m = prime.p;
                    this.prime = prime;
                } else {
                    assert(m.gtn(1), "modulus must be greater than 1");
                    this.m = m;
                    this.prime = null;
                }
            }
            Red.prototype._verify1 = function _verify1(a) {
                assert(a.negative === 0, "red works only with positives");
                assert(a.red, "red works only with red numbers");
            };
            Red.prototype._verify2 = function _verify2(a, b) {
                assert((a.negative | b.negative) === 0, "red works only with positives");
                assert(a.red && a.red === b.red, "red works only with red numbers");
            };
            Red.prototype.imod = function imod(a) {
                if (this.prime) return this.prime.ireduce(a)._forceRed(this);
                return a.umod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
                if (a.isZero()) {
                    return a.clone();
                }
                return this.m.sub(a)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
                this._verify2(a, b);
                var res = a.add(b);
                if (res.cmp(this.m) >= 0) {
                    res.isub(this.m);
                }
                return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
                this._verify2(a, b);
                var res = a.iadd(b);
                if (res.cmp(this.m) >= 0) {
                    res.isub(this.m);
                }
                return res;
            };
            Red.prototype.sub = function sub(a, b) {
                this._verify2(a, b);
                var res = a.sub(b);
                if (res.cmpn(0) < 0) {
                    res.iadd(this.m);
                }
                return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
                this._verify2(a, b);
                var res = a.isub(b);
                if (res.cmpn(0) < 0) {
                    res.iadd(this.m);
                }
                return res;
            };
            Red.prototype.shl = function shl(a, num) {
                this._verify1(a);
                return this.imod(a.ushln(num));
            };
            Red.prototype.imul = function imul(a, b) {
                this._verify2(a, b);
                return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
                this._verify2(a, b);
                return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
                return this.imul(a, a.clone());
            };
            Red.prototype.sqr = function sqr(a) {
                return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
                if (a.isZero()) return a.clone();
                var mod3 = this.m.andln(3);
                assert(mod3 % 2 === 1);
                if (mod3 === 3) {
                    var pow = this.m.add(new BN(1)).iushrn(2);
                    return this.pow(a, pow);
                }
                var q = this.m.subn(1);
                var s = 0;
                while (!q.isZero() && q.andln(1) === 0) {
                    s++;
                    q.iushrn(1);
                }
                assert(!q.isZero());
                var one = new BN(1).toRed(this);
                var nOne = one.redNeg();
                var lpow = this.m.subn(1).iushrn(1);
                var z = this.m.bitLength();
                z = new BN(2 * z * z).toRed(this);
                while (this.pow(z, lpow).cmp(nOne) !== 0) {
                    z.redIAdd(nOne);
                }
                var c = this.pow(z, q);
                var r = this.pow(a, q.addn(1).iushrn(1));
                var t = this.pow(a, q);
                var m = s;
                while (t.cmp(one) !== 0) {
                    var tmp = t;
                    for (var i = 0; tmp.cmp(one) !== 0; i++) {
                        tmp = tmp.redSqr();
                    }
                    assert(i < m);
                    var b = this.pow(c, new BN(1).iushln(m - i - 1));
                    r = r.redMul(b);
                    c = b.redSqr();
                    t = t.redMul(c);
                    m = i;
                }
                return r;
            };
            Red.prototype.invm = function invm(a) {
                var inv = a._invmp(this.m);
                if (inv.negative !== 0) {
                    inv.negative = 0;
                    return this.imod(inv).redNeg();
                } else {
                    return this.imod(inv);
                }
            };
            Red.prototype.pow = function pow(a, num) {
                if (num.isZero()) return new BN(1).toRed(this);
                if (num.cmpn(1) === 0) return a.clone();
                var windowSize = 4;
                var wnd = new Array(1 << windowSize);
                wnd[0] = new BN(1).toRed(this);
                wnd[1] = a;
                for (var i = 2; i < wnd.length; i++) {
                    wnd[i] = this.mul(wnd[i - 1], a);
                }
                var res = wnd[0];
                var current = 0;
                var currentLen = 0;
                var start = num.bitLength() % 26;
                if (start === 0) {
                    start = 26;
                }
                for (i = num.length - 1; i >= 0; i--) {
                    var word = num.words[i];
                    for (var j = start - 1; j >= 0; j--) {
                        var bit = word >> j & 1;
                        if (res !== wnd[0]) {
                            res = this.sqr(res);
                        }
                        if (bit === 0 && current === 0) {
                            currentLen = 0;
                            continue;
                        }
                        current <<= 1;
                        current |= bit;
                        currentLen++;
                        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                        res = this.mul(res, wnd[current]);
                        currentLen = 0;
                        current = 0;
                    }
                    start = 26;
                }
                return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
                var r = num.umod(this.m);
                return r === num ? r.clone() : r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
                var res = num.clone();
                res.red = null;
                return res;
            };
            BN.mont = function mont(num) {
                return new Mont(num);
            };
            function Mont(m) {
                Red.call(this, m);
                this.shift = this.m.bitLength();
                if (this.shift % 26 !== 0) {
                    this.shift += 26 - this.shift % 26;
                }
                this.r = new BN(1).iushln(this.shift);
                this.r2 = this.imod(this.r.sqr());
                this.rinv = this.r._invmp(this.m);
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                this.minv = this.minv.umod(this.r);
                this.minv = this.r.sub(this.minv);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
                return this.imod(num.ushln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
                var r = this.imod(num.mul(this.rinv));
                r.red = null;
                return r;
            };
            Mont.prototype.imul = function imul(a, b) {
                if (a.isZero() || b.isZero()) {
                    a.words[0] = 0;
                    a.length = 1;
                    return a;
                }
                var t = a.imul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) {
                    res = u.isub(this.m);
                } else if (u.cmpn(0) < 0) {
                    res = u.iadd(this.m);
                }
                return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
                if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
                var t = a.mul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) {
                    res = u.isub(this.m);
                } else if (u.cmpn(0) < 0) {
                    res = u.iadd(this.m);
                }
                return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
                var res = this.imod(a._invmp(this.m).mul(this.r2));
                return res._forceRed(this);
            };
        })(typeof module === "undefined" || module, this);
    }).call(this, __webpack_require__(46)(module));
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.lib.Cipher || function(undefined) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var Base64 = C_enc.Base64;
            var C_algo = C.algo;
            var EvpKDF = C_algo.EvpKDF;
            var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                cfg: Base.extend(),
                createEncryptor: function(key, cfg) {
                    return this.create(this._ENC_XFORM_MODE, key, cfg);
                },
                createDecryptor: function(key, cfg) {
                    return this.create(this._DEC_XFORM_MODE, key, cfg);
                },
                init: function(xformMode, key, cfg) {
                    this.cfg = this.cfg.extend(cfg);
                    this._xformMode = xformMode;
                    this._key = key;
                    this.reset();
                },
                reset: function() {
                    BufferedBlockAlgorithm.reset.call(this);
                    this._doReset();
                },
                process: function(dataUpdate) {
                    this._append(dataUpdate);
                    return this._process();
                },
                finalize: function(dataUpdate) {
                    if (dataUpdate) {
                        this._append(dataUpdate);
                    }
                    var finalProcessedData = this._doFinalize();
                    return finalProcessedData;
                },
                keySize: 128 / 32,
                ivSize: 128 / 32,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: function() {
                    function selectCipherStrategy(key) {
                        if (typeof key == "string") {
                            return PasswordBasedCipher;
                        } else {
                            return SerializableCipher;
                        }
                    }
                    return function(cipher) {
                        return {
                            encrypt: function(message, key, cfg) {
                                return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                            },
                            decrypt: function(ciphertext, key, cfg) {
                                return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                            }
                        };
                    };
                }()
            });
            var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                _doFinalize: function() {
                    var finalProcessedBlocks = this._process(!!"flush");
                    return finalProcessedBlocks;
                },
                blockSize: 1
            });
            var C_mode = C.mode = {};
            var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                createEncryptor: function(cipher, iv) {
                    return this.Encryptor.create(cipher, iv);
                },
                createDecryptor: function(cipher, iv) {
                    return this.Decryptor.create(cipher, iv);
                },
                init: function(cipher, iv) {
                    this._cipher = cipher;
                    this._iv = iv;
                }
            });
            var CBC = C_mode.CBC = function() {
                var CBC = BlockCipherMode.extend();
                CBC.Encryptor = CBC.extend({
                    processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        xorBlock.call(this, words, offset, blockSize);
                        cipher.encryptBlock(words, offset);
                        this._prevBlock = words.slice(offset, offset + blockSize);
                    }
                });
                CBC.Decryptor = CBC.extend({
                    processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var thisBlock = words.slice(offset, offset + blockSize);
                        cipher.decryptBlock(words, offset);
                        xorBlock.call(this, words, offset, blockSize);
                        this._prevBlock = thisBlock;
                    }
                });
                function xorBlock(words, offset, blockSize) {
                    var iv = this._iv;
                    if (iv) {
                        var block = iv;
                        this._iv = undefined;
                    } else {
                        var block = this._prevBlock;
                    }
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= block[i];
                    }
                }
                return CBC;
            }();
            var C_pad = C.pad = {};
            var Pkcs7 = C_pad.Pkcs7 = {
                pad: function(data, blockSize) {
                    var blockSizeBytes = blockSize * 4;
                    var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                    var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                    var paddingWords = [];
                    for (var i = 0; i < nPaddingBytes; i += 4) {
                        paddingWords.push(paddingWord);
                    }
                    var padding = WordArray.create(paddingWords, nPaddingBytes);
                    data.concat(padding);
                },
                unpad: function(data) {
                    var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                    data.sigBytes -= nPaddingBytes;
                }
            };
            var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                cfg: Cipher.cfg.extend({
                    mode: CBC,
                    padding: Pkcs7
                }),
                reset: function() {
                    Cipher.reset.call(this);
                    var cfg = this.cfg;
                    var iv = cfg.iv;
                    var mode = cfg.mode;
                    if (this._xformMode == this._ENC_XFORM_MODE) {
                        var modeCreator = mode.createEncryptor;
                    } else {
                        var modeCreator = mode.createDecryptor;
                        this._minBufferSize = 1;
                    }
                    this._mode = modeCreator.call(mode, this, iv && iv.words);
                },
                _doProcessBlock: function(words, offset) {
                    this._mode.processBlock(words, offset);
                },
                _doFinalize: function() {
                    var padding = this.cfg.padding;
                    if (this._xformMode == this._ENC_XFORM_MODE) {
                        padding.pad(this._data, this.blockSize);
                        var finalProcessedBlocks = this._process(!!"flush");
                    } else {
                        var finalProcessedBlocks = this._process(!!"flush");
                        padding.unpad(finalProcessedBlocks);
                    }
                    return finalProcessedBlocks;
                },
                blockSize: 128 / 32
            });
            var CipherParams = C_lib.CipherParams = Base.extend({
                init: function(cipherParams) {
                    this.mixIn(cipherParams);
                },
                toString: function(formatter) {
                    return (formatter || this.formatter).stringify(this);
                }
            });
            var C_format = C.format = {};
            var OpenSSLFormatter = C_format.OpenSSL = {
                stringify: function(cipherParams) {
                    var ciphertext = cipherParams.ciphertext;
                    var salt = cipherParams.salt;
                    if (salt) {
                        var wordArray = WordArray.create([ 1398893684, 1701076831 ]).concat(salt).concat(ciphertext);
                    } else {
                        var wordArray = ciphertext;
                    }
                    return wordArray.toString(Base64);
                },
                parse: function(openSSLStr) {
                    var ciphertext = Base64.parse(openSSLStr);
                    var ciphertextWords = ciphertext.words;
                    if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                        var salt = WordArray.create(ciphertextWords.slice(2, 4));
                        ciphertextWords.splice(0, 4);
                        ciphertext.sigBytes -= 16;
                    }
                    return CipherParams.create({
                        ciphertext,
                        salt
                    });
                }
            };
            var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                cfg: Base.extend({
                    format: OpenSSLFormatter
                }),
                encrypt: function(cipher, message, key, cfg) {
                    cfg = this.cfg.extend(cfg);
                    var encryptor = cipher.createEncryptor(key, cfg);
                    var ciphertext = encryptor.finalize(message);
                    var cipherCfg = encryptor.cfg;
                    return CipherParams.create({
                        ciphertext,
                        key,
                        iv: cipherCfg.iv,
                        algorithm: cipher,
                        mode: cipherCfg.mode,
                        padding: cipherCfg.padding,
                        blockSize: cipher.blockSize,
                        formatter: cfg.format
                    });
                },
                decrypt: function(cipher, ciphertext, key, cfg) {
                    cfg = this.cfg.extend(cfg);
                    ciphertext = this._parse(ciphertext, cfg.format);
                    var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                    return plaintext;
                },
                _parse: function(ciphertext, format) {
                    if (typeof ciphertext == "string") {
                        return format.parse(ciphertext, this);
                    } else {
                        return ciphertext;
                    }
                }
            });
            var C_kdf = C.kdf = {};
            var OpenSSLKdf = C_kdf.OpenSSL = {
                execute: function(password, keySize, ivSize, salt) {
                    if (!salt) {
                        salt = WordArray.random(64 / 8);
                    }
                    var key = EvpKDF.create({
                        keySize: keySize + ivSize
                    }).compute(password, salt);
                    var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                    key.sigBytes = keySize * 4;
                    return CipherParams.create({
                        key,
                        iv,
                        salt
                    });
                }
            };
            var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                cfg: SerializableCipher.cfg.extend({
                    kdf: OpenSSLKdf
                }),
                encrypt: function(cipher, message, password, cfg) {
                    cfg = this.cfg.extend(cfg);
                    var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
                    cfg.iv = derivedParams.iv;
                    var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                    ciphertext.mixIn(derivedParams);
                    return ciphertext;
                },
                decrypt: function(cipher, ciphertext, password, cfg) {
                    cfg = this.cfg.extend(cfg);
                    ciphertext = this._parse(ciphertext, cfg.format);
                    var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
                    cfg.iv = derivedParams.iv;
                    var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                    return plaintext;
                }
            });
        }();
    });
}, function(module, exports, __webpack_require__) {
    var BigNumber = __webpack_require__(38);
    var sha3 = __webpack_require__(37);
    var utf8 = __webpack_require__(235);
    var unitMap = {
        noether: "0",
        wei: "1",
        kwei: "1000",
        Kwei: "1000",
        babbage: "1000",
        femtoether: "1000",
        mwei: "1000000",
        Mwei: "1000000",
        lovelace: "1000000",
        picoether: "1000000",
        gwei: "1000000000",
        Gwei: "1000000000",
        shannon: "1000000000",
        nanoether: "1000000000",
        nano: "1000000000",
        szabo: "1000000000000",
        microether: "1000000000000",
        micro: "1000000000000",
        finney: "1000000000000000",
        milliether: "1000000000000000",
        milli: "1000000000000000",
        ether: "1000000000000000000",
        kether: "1000000000000000000000",
        grand: "1000000000000000000000",
        mether: "1000000000000000000000000",
        gether: "1000000000000000000000000000",
        tether: "1000000000000000000000000000000"
    };
    var padLeft = function(string, chars, sign) {
        return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
    };
    var padRight = function(string, chars, sign) {
        return string + new Array(chars - string.length + 1).join(sign ? sign : "0");
    };
    var toUtf8 = function(hex) {
        var str = "";
        var i = 0, l = hex.length;
        if (hex.substring(0, 2) === "0x") {
            i = 2;
        }
        for (;i < l; i += 2) {
            var code = parseInt(hex.substr(i, 2), 16);
            if (code === 0) break;
            str += String.fromCharCode(code);
        }
        return utf8.decode(str);
    };
    var toAscii = function(hex) {
        var str = "";
        var i = 0, l = hex.length;
        if (hex.substring(0, 2) === "0x") {
            i = 2;
        }
        for (;i < l; i += 2) {
            var code = parseInt(hex.substr(i, 2), 16);
            str += String.fromCharCode(code);
        }
        return str;
    };
    var fromUtf8 = function(str) {
        str = utf8.encode(str);
        var hex = "";
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            if (code === 0) break;
            var n = code.toString(16);
            hex += n.length < 2 ? "0" + n : n;
        }
        return "0x" + hex;
    };
    var fromAscii = function(str) {
        var hex = "";
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            var n = code.toString(16);
            hex += n.length < 2 ? "0" + n : n;
        }
        return "0x" + hex;
    };
    var transformToFullName = function(json) {
        if (json.name.indexOf("(") !== -1) {
            return json.name;
        }
        var typeName = json.inputs.map(function(i) {
            return i.type;
        }).join();
        return json.name + "(" + typeName + ")";
    };
    var extractDisplayName = function(name) {
        var length = name.indexOf("(");
        return length !== -1 ? name.substr(0, length) : name;
    };
    var extractTypeName = function(name) {
        var length = name.indexOf("(");
        return length !== -1 ? name.substr(length + 1, name.length - 1 - (length + 1)).replace(" ", "") : "";
    };
    var toDecimal = function(value) {
        return toBigNumber(value).toNumber();
    };
    var fromDecimal = function(value) {
        var number = toBigNumber(value);
        var result = number.toString(16);
        return number.lessThan(0) ? "-0x" + result.substr(1) : "0x" + result;
    };
    var toHex = function(val) {
        if (isBoolean(val)) return fromDecimal(+val);
        if (isBigNumber(val)) return fromDecimal(val);
        if (typeof val === "object") return fromUtf8(JSON.stringify(val));
        if (isString(val)) {
            if (val.indexOf("-0x") === 0) return fromDecimal(val); else if (val.indexOf("0x") === 0) return val; else if (!isFinite(val)) return fromAscii(val);
        }
        return fromDecimal(val);
    };
    var getValueOfUnit = function(unit) {
        unit = unit ? unit.toLowerCase() : "ether";
        var unitValue = unitMap[unit];
        if (unitValue === undefined) {
            throw new Error("This unit doesn't exists, please use the one of the following units" + JSON.stringify(unitMap, null, 2));
        }
        return new BigNumber(unitValue, 10);
    };
    var fromWei = function(number, unit) {
        var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));
        return isBigNumber(number) ? returnValue : returnValue.toString(10);
    };
    var toWei = function(number, unit) {
        var returnValue = toBigNumber(number).times(getValueOfUnit(unit));
        return isBigNumber(number) ? returnValue : returnValue.toString(10);
    };
    var toBigNumber = function(number) {
        number = number || 0;
        if (isBigNumber(number)) return number;
        if (isString(number) && (number.indexOf("0x") === 0 || number.indexOf("-0x") === 0)) {
            return new BigNumber(number.replace("0x", ""), 16);
        }
        return new BigNumber(number.toString(10), 10);
    };
    var toTwosComplement = function(number) {
        var bigNumber = toBigNumber(number).round();
        if (bigNumber.lessThan(0)) {
            return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
        }
        return bigNumber;
    };
    var isStrictAddress = function(address) {
        return /^0x[0-9a-f]{40}$/i.test(address);
    };
    var isAddress = function(address) {
        if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
            return false;
        } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
            return true;
        } else {
            return isChecksumAddress(address);
        }
    };
    var isChecksumAddress = function(address) {
        address = address.replace("0x", "");
        var addressHash = sha3(address.toLowerCase());
        for (var i = 0; i < 40; i++) {
            if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
                return false;
            }
        }
        return true;
    };
    var toChecksumAddress = function(address) {
        if (typeof address === "undefined") return "";
        address = address.toLowerCase().replace("0x", "");
        var addressHash = sha3(address);
        var checksumAddress = "0x";
        for (var i = 0; i < address.length; i++) {
            if (parseInt(addressHash[i], 16) > 7) {
                checksumAddress += address[i].toUpperCase();
            } else {
                checksumAddress += address[i];
            }
        }
        return checksumAddress;
    };
    var toAddress = function(address) {
        if (isStrictAddress(address)) {
            return address;
        }
        if (/^[0-9a-f]{40}$/.test(address)) {
            return "0x" + address;
        }
        return "0x" + padLeft(toHex(address).substr(2), 40);
    };
    var isBigNumber = function(object) {
        return object instanceof BigNumber || object && object.constructor && object.constructor.name === "BigNumber";
    };
    var isString = function(object) {
        return typeof object === "string" || object && object.constructor && object.constructor.name === "String";
    };
    var isFunction = function(object) {
        return typeof object === "function";
    };
    var isObject = function(object) {
        return object !== null && !(object instanceof Array) && typeof object === "object";
    };
    var isBoolean = function(object) {
        return typeof object === "boolean";
    };
    var isArray = function(object) {
        return object instanceof Array;
    };
    var isJson = function(str) {
        try {
            return !!JSON.parse(str);
        } catch (e) {
            return false;
        }
    };
    var isBloom = function(bloom) {
        if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
            return false;
        } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
            return true;
        }
        return false;
    };
    var isTopic = function(topic) {
        if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
            return false;
        } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
            return true;
        }
        return false;
    };
    module.exports = {
        padLeft,
        padRight,
        toHex,
        toDecimal,
        fromDecimal,
        toUtf8,
        toAscii,
        fromUtf8,
        fromAscii,
        transformToFullName,
        extractDisplayName,
        extractTypeName,
        toWei,
        fromWei,
        toBigNumber,
        toTwosComplement,
        toAddress,
        isBigNumber,
        isStrictAddress,
        isAddress,
        isChecksumAddress,
        toChecksumAddress,
        isFunction,
        isString,
        isObject,
        isBoolean,
        isArray,
        isJson,
        isBloom,
        isTopic
    };
}, function(module, exports) {
    var g;
    g = function() {
        return this;
    }();
    try {
        g = g || Function("return this")() || (1, eval)("this");
    } catch (e) {
        if (typeof window === "object") g = window;
    }
    module.exports = g;
}, function(module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
    }
    (function() {
        try {
            if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function() {
        this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
        return [];
    };
    process.binding = function(name) {
        throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
        return "/";
    };
    process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
        return 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var elliptic = exports;
    elliptic.version = __webpack_require__(434).version;
    elliptic.utils = __webpack_require__(433);
    elliptic.rand = __webpack_require__(84);
    elliptic.curve = __webpack_require__(63);
    elliptic.curves = __webpack_require__(426);
    elliptic.ec = __webpack_require__(418);
    elliptic.eddsa = __webpack_require__(414);
}, function(module, exports) {
    module.exports = assert;
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
        if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var elliptic = exports;
    elliptic.version = __webpack_require__(341).version;
    elliptic.utils = __webpack_require__(340);
    elliptic.rand = __webpack_require__(84);
    elliptic.hmacDRBG = __webpack_require__(339);
    elliptic.curve = __webpack_require__(57);
    elliptic.curves = __webpack_require__(334);
    elliptic.ec = __webpack_require__(332);
    elliptic.eddsa = __webpack_require__(329);
}, function(module, exports, __webpack_require__) {
    var BigNumber = __webpack_require__(38);
    var utils = __webpack_require__(11);
    var c = __webpack_require__(52);
    var SolidityParam = __webpack_require__(103);
    var formatInputInt = function(value) {
        BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
        var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
        return new SolidityParam(result);
    };
    var formatInputBytes = function(value) {
        var result = utils.toHex(value).substr(2);
        var l = Math.floor((result.length + 63) / 64);
        result = utils.padRight(result, l * 64);
        return new SolidityParam(result);
    };
    var formatInputDynamicBytes = function(value) {
        var result = utils.toHex(value).substr(2);
        var length = result.length / 2;
        var l = Math.floor((result.length + 63) / 64);
        result = utils.padRight(result, l * 64);
        return new SolidityParam(formatInputInt(length).value + result);
    };
    var formatInputString = function(value) {
        var result = utils.fromUtf8(value).substr(2);
        var length = result.length / 2;
        var l = Math.floor((result.length + 63) / 64);
        result = utils.padRight(result, l * 64);
        return new SolidityParam(formatInputInt(length).value + result);
    };
    var formatInputBool = function(value) {
        var result = "000000000000000000000000000000000000000000000000000000000000000" + (value ? "1" : "0");
        return new SolidityParam(result);
    };
    var formatInputReal = function(value) {
        return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
    };
    var signedIsNegative = function(value) {
        return new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1) === "1";
    };
    var formatOutputInt = function(param) {
        var value = param.staticPart() || "0";
        if (signedIsNegative(value)) {
            return new BigNumber(value, 16).minus(new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)).minus(1);
        }
        return new BigNumber(value, 16);
    };
    var formatOutputUInt = function(param) {
        var value = param.staticPart() || "0";
        return new BigNumber(value, 16);
    };
    var formatOutputReal = function(param) {
        return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
    };
    var formatOutputUReal = function(param) {
        return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
    };
    var formatOutputBool = function(param) {
        return param.staticPart() === "0000000000000000000000000000000000000000000000000000000000000001" ? true : false;
    };
    var formatOutputBytes = function(param, name) {
        var matches = name.match(/^bytes([0-9]*)/);
        var size = parseInt(matches[1]);
        return "0x" + param.staticPart().slice(0, 2 * size);
    };
    var formatOutputDynamicBytes = function(param) {
        var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;
        return "0x" + param.dynamicPart().substr(64, length);
    };
    var formatOutputString = function(param) {
        var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;
        return utils.toUtf8(param.dynamicPart().substr(64, length));
    };
    var formatOutputAddress = function(param) {
        var value = param.staticPart();
        return "0x" + value.slice(value.length - 40, value.length);
    };
    module.exports = {
        formatInputInt,
        formatInputBytes,
        formatInputDynamicBytes,
        formatInputString,
        formatInputBool,
        formatInputReal,
        formatOutputInt,
        formatOutputUInt,
        formatOutputReal,
        formatOutputUReal,
        formatOutputBool,
        formatOutputBytes,
        formatOutputDynamicBytes,
        formatOutputString,
        formatOutputAddress
    };
}, function(module, exports, __webpack_require__) {
    (function(module) {
        (function(module, exports) {
            "use strict";
            function assert(val, msg) {
                if (!val) throw new Error(msg || "Assertion failed");
            }
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
                if (number !== null && typeof number === "object" && Array.isArray(number.words)) {
                    return number;
                }
                this.sign = false;
                this.words = null;
                this.length = 0;
                this.red = null;
                if (base === "le" || base === "be") {
                    endian = base;
                    base = 10;
                }
                if (number !== null) this._init(number || 0, base || 10, endian || "be");
            }
            if (typeof module === "object") module.exports = BN; else exports.BN = BN;
            BN.BN = BN;
            BN.wordSize = 26;
            BN.max = function max(left, right) {
                if (left.cmp(right) > 0) return left; else return right;
            };
            BN.min = function min(left, right) {
                if (left.cmp(right) < 0) return left; else return right;
            };
            BN.prototype._init = function init(number, base, endian) {
                if (typeof number === "number") {
                    return this._initNumber(number, base, endian);
                } else if (typeof number === "object") {
                    return this._initArray(number, base, endian);
                }
                if (base === "hex") base = 16;
                assert(base === (base | 0) && base >= 2 && base <= 36);
                number = number.toString().replace(/\s+/g, "");
                var start = 0;
                if (number[0] === "-") start++;
                if (base === 16) this._parseHex(number, start); else this._parseBase(number, base, start);
                if (number[0] === "-") this.sign = true;
                this.strip();
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initNumber = function _initNumber(number, base, endian) {
                if (number < 0) {
                    this.sign = true;
                    number = -number;
                }
                if (number < 67108864) {
                    this.words = [ number & 67108863 ];
                    this.length = 1;
                } else if (number < 4503599627370496) {
                    this.words = [ number & 67108863, number / 67108864 & 67108863 ];
                    this.length = 2;
                } else {
                    assert(number < 9007199254740992);
                    this.words = [ number & 67108863, number / 67108864 & 67108863, 1 ];
                    this.length = 3;
                }
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(number, base, endian) {
                assert(typeof number.length === "number");
                if (number.length <= 0) {
                    this.words = [ 0 ];
                    this.length = 1;
                    return this;
                }
                this.length = Math.ceil(number.length / 3);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) this.words[i] = 0;
                var off = 0;
                if (endian === "be") {
                    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                        var w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                } else if (endian === "le") {
                    for (var i = 0, j = 0; i < number.length; i += 3) {
                        var w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                }
                return this.strip();
            };
            function parseHex(str, start, end) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r <<= 4;
                    if (c >= 49 && c <= 54) r |= c - 49 + 10; else if (c >= 17 && c <= 22) r |= c - 17 + 10; else r |= c & 15;
                }
                return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start) {
                this.length = Math.ceil((number.length - start) / 6);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) this.words[i] = 0;
                var off = 0;
                for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
                    var w = parseHex(number, i, i + 6);
                    this.words[j] |= w << off & 67108863;
                    this.words[j + 1] |= w >>> 26 - off & 4194303;
                    off += 24;
                    if (off >= 26) {
                        off -= 26;
                        j++;
                    }
                }
                if (i + 6 !== start) {
                    var w = parseHex(number, start, i + 6);
                    this.words[j] |= w << off & 67108863;
                    this.words[j + 1] |= w >>> 26 - off & 4194303;
                }
                this.strip();
            };
            function parseBase(str, start, end, mul) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r *= mul;
                    if (c >= 49) r += c - 49 + 10; else if (c >= 17) r += c - 17 + 10; else r += c;
                }
                return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
                this.words = [ 0 ];
                this.length = 1;
                for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) limbLen++;
                limbLen--;
                limbPow = limbPow / base | 0;
                var total = number.length - start;
                var mod = total % limbLen;
                var end = Math.min(total, total - mod) + start;
                var word = 0;
                for (var i = start; i < end; i += limbLen) {
                    word = parseBase(number, i, i + limbLen, base);
                    this.imuln(limbPow);
                    if (this.words[0] + word < 67108864) this.words[0] += word; else this._iaddn(word);
                }
                if (mod !== 0) {
                    var pow = 1;
                    var word = parseBase(number, i, number.length, base);
                    for (var i = 0; i < mod; i++) pow *= base;
                    this.imuln(pow);
                    if (this.words[0] + word < 67108864) this.words[0] += word; else this._iaddn(word);
                }
            };
            BN.prototype.copy = function copy(dest) {
                dest.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) dest.words[i] = this.words[i];
                dest.length = this.length;
                dest.sign = this.sign;
                dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
                var r = new BN(null);
                this.copy(r);
                return r;
            };
            BN.prototype.strip = function strip() {
                while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
                return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
                if (this.length === 1 && this.words[0] === 0) this.sign = false;
                return this;
            };
            BN.prototype.inspect = function inspect() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var zeros = [ "", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000" ];
            var groupSizes = [ 0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ];
            var groupBases = [ 0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176 ];
            BN.prototype.toString = function toString(base, padding) {
                base = base || 10;
                var padding = padding | 0 || 1;
                if (base === 16 || base === "hex") {
                    var out = "";
                    var off = 0;
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = this.words[i];
                        var word = ((w << off | carry) & 16777215).toString(16);
                        carry = w >>> 24 - off & 16777215;
                        if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out; else out = word + out;
                        off += 2;
                        if (off >= 26) {
                            off -= 26;
                            i--;
                        }
                    }
                    if (carry !== 0) out = carry.toString(16) + out;
                    while (out.length % padding !== 0) out = "0" + out;
                    if (this.sign) out = "-" + out;
                    return out;
                } else if (base === (base | 0) && base >= 2 && base <= 36) {
                    var groupSize = groupSizes[base];
                    var groupBase = groupBases[base];
                    var out = "";
                    var c = this.clone();
                    c.sign = false;
                    while (c.cmpn(0) !== 0) {
                        var r = c.modn(groupBase).toString(base);
                        c = c.idivn(groupBase);
                        if (c.cmpn(0) !== 0) out = zeros[groupSize - r.length] + r + out; else out = r + out;
                    }
                    if (this.cmpn(0) === 0) out = "0" + out;
                    while (out.length % padding !== 0) out = "0" + out;
                    if (this.sign) out = "-" + out;
                    return out;
                } else {
                    assert(false, "Base should be between 2 and 36");
                }
            };
            BN.prototype.toJSON = function toJSON() {
                return this.toString(16);
            };
            BN.prototype.toArray = function toArray(endian, length) {
                this.strip();
                var littleEndian = endian === "le";
                var res = new Array(this.byteLength());
                res[0] = 0;
                var q = this.clone();
                if (!littleEndian) {
                    for (var i = 0; q.cmpn(0) !== 0; i++) {
                        var b = q.andln(255);
                        q.iushrn(8);
                        res[res.length - i - 1] = b;
                    }
                } else {
                    for (var i = 0; q.cmpn(0) !== 0; i++) {
                        var b = q.andln(255);
                        q.iushrn(8);
                        res[i] = b;
                    }
                }
                if (length) {
                    assert(res.length <= length, "byte array longer than desired length");
                    while (res.length < length) {
                        if (littleEndian) res.push(0); else res.unshift(0);
                    }
                }
                return res;
            };
            if (Math.clz32) {
                BN.prototype._countBits = function _countBits(w) {
                    return 32 - Math.clz32(w);
                };
            } else {
                BN.prototype._countBits = function _countBits(w) {
                    var t = w;
                    var r = 0;
                    if (t >= 4096) {
                        r += 13;
                        t >>>= 13;
                    }
                    if (t >= 64) {
                        r += 7;
                        t >>>= 7;
                    }
                    if (t >= 8) {
                        r += 4;
                        t >>>= 4;
                    }
                    if (t >= 2) {
                        r += 2;
                        t >>>= 2;
                    }
                    return r + t;
                };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
                if (w === 0) return 26;
                var t = w;
                var r = 0;
                if ((t & 8191) === 0) {
                    r += 13;
                    t >>>= 13;
                }
                if ((t & 127) === 0) {
                    r += 7;
                    t >>>= 7;
                }
                if ((t & 15) === 0) {
                    r += 4;
                    t >>>= 4;
                }
                if ((t & 3) === 0) {
                    r += 2;
                    t >>>= 2;
                }
                if ((t & 1) === 0) r++;
                return r;
            };
            BN.prototype.bitLength = function bitLength() {
                var hi = 0;
                var w = this.words[this.length - 1];
                var hi = this._countBits(w);
                return (this.length - 1) * 26 + hi;
            };
            function toBitArray(num) {
                var w = new Array(num.bitLength());
                for (var bit = 0; bit < w.length; bit++) {
                    var off = bit / 26 | 0;
                    var wbit = bit % 26;
                    w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
                }
                return w;
            }
            BN.prototype.zeroBits = function zeroBits() {
                if (this.cmpn(0) === 0) return 0;
                var r = 0;
                for (var i = 0; i < this.length; i++) {
                    var b = this._zeroBits(this.words[i]);
                    r += b;
                    if (b !== 26) break;
                }
                return r;
            };
            BN.prototype.byteLength = function byteLength() {
                return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.neg = function neg() {
                if (this.cmpn(0) === 0) return this.clone();
                var r = this.clone();
                r.sign = !this.sign;
                return r;
            };
            BN.prototype.iuor = function iuor(num) {
                while (this.length < num.length) this.words[this.length++] = 0;
                for (var i = 0; i < num.length; i++) this.words[i] = this.words[i] | num.words[i];
                return this.strip();
            };
            BN.prototype.ior = function ior(num) {
                assert(!this.sign && !num.sign);
                return this.iuor(num);
            };
            BN.prototype.or = function or(num) {
                if (this.length > num.length) return this.clone().ior(num); else return num.clone().ior(this);
            };
            BN.prototype.uor = function uor(num) {
                if (this.length > num.length) return this.clone().iuor(num); else return num.clone().iuor(this);
            };
            BN.prototype.iuand = function iuand(num) {
                var b;
                if (this.length > num.length) b = num; else b = this;
                for (var i = 0; i < b.length; i++) this.words[i] = this.words[i] & num.words[i];
                this.length = b.length;
                return this.strip();
            };
            BN.prototype.iand = function iand(num) {
                assert(!this.sign && !num.sign);
                return this.iuand(num);
            };
            BN.prototype.and = function and(num) {
                if (this.length > num.length) return this.clone().iand(num); else return num.clone().iand(this);
            };
            BN.prototype.uand = function uand(num) {
                if (this.length > num.length) return this.clone().iuand(num); else return num.clone().iuand(this);
            };
            BN.prototype.iuxor = function iuxor(num) {
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                for (var i = 0; i < b.length; i++) this.words[i] = a.words[i] ^ b.words[i];
                if (this !== a) for (;i < a.length; i++) this.words[i] = a.words[i];
                this.length = a.length;
                return this.strip();
            };
            BN.prototype.ixor = function ixor(num) {
                assert(!this.sign && !num.sign);
                return this.iuxor(num);
            };
            BN.prototype.xor = function xor(num) {
                if (this.length > num.length) return this.clone().ixor(num); else return num.clone().ixor(this);
            };
            BN.prototype.uxor = function uxor(num) {
                if (this.length > num.length) return this.clone().iuxor(num); else return num.clone().iuxor(this);
            };
            BN.prototype.setn = function setn(bit, val) {
                assert(typeof bit === "number" && bit >= 0);
                var off = bit / 26 | 0;
                var wbit = bit % 26;
                while (this.length <= off) this.words[this.length++] = 0;
                if (val) this.words[off] = this.words[off] | 1 << wbit; else this.words[off] = this.words[off] & ~(1 << wbit);
                return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
                if (this.sign && !num.sign) {
                    this.sign = false;
                    var r = this.isub(num);
                    this.sign = !this.sign;
                    return this._normSign();
                } else if (!this.sign && num.sign) {
                    num.sign = false;
                    var r = this.isub(num);
                    num.sign = true;
                    return r._normSign();
                }
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    var r = a.words[i] + b.words[i] + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    var r = a.words[i] + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                this.length = a.length;
                if (carry !== 0) {
                    this.words[this.length] = carry;
                    this.length++;
                } else if (a !== this) {
                    for (;i < a.length; i++) this.words[i] = a.words[i];
                }
                return this;
            };
            BN.prototype.add = function add(num) {
                if (num.sign && !this.sign) {
                    num.sign = false;
                    var res = this.sub(num);
                    num.sign = true;
                    return res;
                } else if (!num.sign && this.sign) {
                    this.sign = false;
                    var res = num.sub(this);
                    this.sign = true;
                    return res;
                }
                if (this.length > num.length) return this.clone().iadd(num); else return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
                if (num.sign) {
                    num.sign = false;
                    var r = this.iadd(num);
                    num.sign = true;
                    return r._normSign();
                } else if (this.sign) {
                    this.sign = false;
                    this.iadd(num);
                    this.sign = true;
                    return this._normSign();
                }
                var cmp = this.cmp(num);
                if (cmp === 0) {
                    this.sign = false;
                    this.length = 1;
                    this.words[0] = 0;
                    return this;
                }
                var a;
                var b;
                if (cmp > 0) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    var r = a.words[i] - b.words[i] + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    var r = a.words[i] + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                if (carry === 0 && i < a.length && a !== this) for (;i < a.length; i++) this.words[i] = a.words[i];
                this.length = Math.max(this.length, i);
                if (a !== this) this.sign = true;
                return this.strip();
            };
            BN.prototype.sub = function sub(num) {
                return this.clone().isub(num);
            };
            BN.prototype._smallMulTo = function _smallMulTo(num, out) {
                out.sign = num.sign !== this.sign;
                out.length = this.length + num.length;
                var carry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    var ncarry = carry >>> 26;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = this.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }
                return out.strip();
            };
            BN.prototype._bigMulTo = function _bigMulTo(num, out) {
                out.sign = num.sign !== this.sign;
                out.length = this.length + num.length;
                var carry = 0;
                var hncarry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    var ncarry = hncarry;
                    hncarry = 0;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = this.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                        hncarry += ncarry >>> 26;
                        ncarry &= 67108863;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                    ncarry = hncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }
                return out.strip();
            };
            BN.prototype.mulTo = function mulTo(num, out) {
                var res;
                if (this.length + num.length < 63) res = this._smallMulTo(num, out); else res = this._bigMulTo(num, out);
                return res;
            };
            BN.prototype.mul = function mul(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return this.mulTo(num, out);
            };
            BN.prototype.imul = function imul(num) {
                if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                    return this;
                }
                var tlen = this.length;
                var nlen = num.length;
                this.sign = num.sign !== this.sign;
                this.length = this.length + num.length;
                this.words[this.length - 1] = 0;
                for (var k = this.length - 2; k >= 0; k--) {
                    var carry = 0;
                    var rword = 0;
                    var maxJ = Math.min(k, nlen - 1);
                    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = this.words[i];
                        var b = num.words[j];
                        var r = a * b;
                        var lo = r & 67108863;
                        carry += r / 67108864 | 0;
                        lo += rword;
                        rword = lo & 67108863;
                        carry += lo >>> 26;
                    }
                    this.words[k] = rword;
                    this.words[k + 1] += carry;
                    carry = 0;
                }
                var carry = 0;
                for (var i = 1; i < this.length; i++) {
                    var w = this.words[i] + carry;
                    this.words[i] = w & 67108863;
                    carry = w >>> 26;
                }
                return this.strip();
            };
            BN.prototype.imuln = function imuln(num) {
                assert(typeof num === "number");
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = this.words[i] * num;
                    var lo = (w & 67108863) + (carry & 67108863);
                    carry >>= 26;
                    carry += w / 67108864 | 0;
                    carry += lo >>> 26;
                    this.words[i] = lo & 67108863;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.muln = function muln(num) {
                return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
                return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
                return this.mul(this);
            };
            BN.prototype.pow = function pow(num) {
                var w = toBitArray(num);
                if (w.length === 0) return new BN(1);
                var res = this;
                for (var i = 0; i < w.length; i++, res = res.sqr()) if (w[i] !== 0) break;
                if (++i < w.length) {
                    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                        if (w[i] === 0) continue;
                        res = res.mul(q);
                    }
                }
                return res;
            };
            BN.prototype.iushln = function iushln(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                var carryMask = 67108863 >>> 26 - r << 26 - r;
                if (r !== 0) {
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var newCarry = this.words[i] & carryMask;
                        var c = this.words[i] - newCarry << r;
                        this.words[i] = c | carry;
                        carry = newCarry >>> 26 - r;
                    }
                    if (carry) {
                        this.words[i] = carry;
                        this.length++;
                    }
                }
                if (s !== 0) {
                    for (var i = this.length - 1; i >= 0; i--) this.words[i + s] = this.words[i];
                    for (var i = 0; i < s; i++) this.words[i] = 0;
                    this.length += s;
                }
                return this.strip();
            };
            BN.prototype.ishln = function ishln(bits) {
                assert(!this.sign);
                return this.iushln(bits);
            };
            BN.prototype.iushrn = function iushrn(bits, hint, extended) {
                assert(typeof bits === "number" && bits >= 0);
                var h;
                if (hint) h = (hint - hint % 26) / 26; else h = 0;
                var r = bits % 26;
                var s = Math.min((bits - r) / 26, this.length);
                var mask = 67108863 ^ 67108863 >>> r << r;
                var maskedWords = extended;
                h -= s;
                h = Math.max(0, h);
                if (maskedWords) {
                    for (var i = 0; i < s; i++) maskedWords.words[i] = this.words[i];
                    maskedWords.length = s;
                }
                if (s === 0) {} else if (this.length > s) {
                    this.length -= s;
                    for (var i = 0; i < this.length; i++) this.words[i] = this.words[i + s];
                } else {
                    this.words[0] = 0;
                    this.length = 1;
                }
                var carry = 0;
                for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                    var word = this.words[i];
                    this.words[i] = carry << 26 - r | word >>> r;
                    carry = word & mask;
                }
                if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
                if (this.length === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                }
                this.strip();
                return this;
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                assert(!this.sign);
                return this.iushrn(bits, hint, extended);
            };
            BN.prototype.shln = function shln(bits) {
                return this.clone().ishln(bits);
            };
            BN.prototype.ushln = function ushln(bits) {
                return this.clone().iushln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
                return this.clone().ishrn(bits);
            };
            BN.prototype.ushrn = function ushrn(bits) {
                return this.clone().iushrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
                assert(typeof bit === "number" && bit >= 0);
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) {
                    return false;
                }
                var w = this.words[s];
                return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                assert(!this.sign, "imaskn works only with positive numbers");
                if (r !== 0) s++;
                this.length = Math.min(s, this.length);
                if (r !== 0) {
                    var mask = 67108863 ^ 67108863 >>> r << r;
                    this.words[this.length - 1] &= mask;
                }
                return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
                return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
                assert(typeof num === "number");
                if (num < 0) return this.isubn(-num);
                if (this.sign) {
                    if (this.length === 1 && this.words[0] < num) {
                        this.words[0] = num - this.words[0];
                        this.sign = false;
                        return this;
                    }
                    this.sign = false;
                    this.isubn(num);
                    this.sign = true;
                    return this;
                }
                return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
                this.words[0] += num;
                for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
                    this.words[i] -= 67108864;
                    if (i === this.length - 1) this.words[i + 1] = 1; else this.words[i + 1]++;
                }
                this.length = Math.max(this.length, i + 1);
                return this;
            };
            BN.prototype.isubn = function isubn(num) {
                assert(typeof num === "number");
                if (num < 0) return this.iaddn(-num);
                if (this.sign) {
                    this.sign = false;
                    this.iaddn(num);
                    this.sign = true;
                    return this;
                }
                this.words[0] -= num;
                for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                    this.words[i] += 67108864;
                    this.words[i + 1] -= 1;
                }
                return this.strip();
            };
            BN.prototype.addn = function addn(num) {
                return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
                return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
                this.sign = false;
                return this;
            };
            BN.prototype.abs = function abs() {
                return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                var len = num.length + shift;
                var i;
                if (this.words.length < len) {
                    var t = new Array(len);
                    for (var i = 0; i < this.length; i++) t[i] = this.words[i];
                    this.words = t;
                } else {
                    i = this.length;
                }
                this.length = Math.max(this.length, len);
                for (;i < this.length; i++) this.words[i] = 0;
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = this.words[i + shift] + carry;
                    var right = num.words[i] * mul;
                    w -= right & 67108863;
                    carry = (w >> 26) - (right / 67108864 | 0);
                    this.words[i + shift] = w & 67108863;
                }
                for (;i < this.length - shift; i++) {
                    var w = this.words[i + shift] + carry;
                    carry = w >> 26;
                    this.words[i + shift] = w & 67108863;
                }
                if (carry === 0) return this.strip();
                assert(carry === -1);
                carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = -this.words[i] + carry;
                    carry = w >> 26;
                    this.words[i] = w & 67108863;
                }
                this.sign = true;
                return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
                var shift = this.length - num.length;
                var a = this.clone();
                var b = num;
                var bhi = b.words[b.length - 1];
                var bhiBits = this._countBits(bhi);
                shift = 26 - bhiBits;
                if (shift !== 0) {
                    b = b.ushln(shift);
                    a.iushln(shift);
                    bhi = b.words[b.length - 1];
                }
                var m = a.length - b.length;
                var q;
                if (mode !== "mod") {
                    q = new BN(null);
                    q.length = m + 1;
                    q.words = new Array(q.length);
                    for (var i = 0; i < q.length; i++) q.words[i] = 0;
                }
                var diff = a.clone()._ishlnsubmul(b, 1, m);
                if (!diff.sign) {
                    a = diff;
                    if (q) q.words[m] = 1;
                }
                for (var j = m - 1; j >= 0; j--) {
                    var qj = a.words[b.length + j] * 67108864 + a.words[b.length + j - 1];
                    qj = Math.min(qj / bhi | 0, 67108863);
                    a._ishlnsubmul(b, qj, j);
                    while (a.sign) {
                        qj--;
                        a.sign = false;
                        a._ishlnsubmul(b, 1, j);
                        if (a.cmpn(0) !== 0) a.sign = !a.sign;
                    }
                    if (q) q.words[j] = qj;
                }
                if (q) q.strip();
                a.strip();
                if (mode !== "div" && shift !== 0) a.iushrn(shift);
                return {
                    div: q ? q : null,
                    mod: a
                };
            };
            BN.prototype.divmod = function divmod(num, mode, positive) {
                assert(num.cmpn(0) !== 0);
                if (this.sign && !num.sign) {
                    var res = this.neg().divmod(num, mode);
                    var div;
                    var mod;
                    if (mode !== "mod") div = res.div.neg();
                    if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.neg) mod = mod.add(num);
                    }
                    return {
                        div,
                        mod
                    };
                } else if (!this.sign && num.sign) {
                    var res = this.divmod(num.neg(), mode);
                    var div;
                    if (mode !== "mod") div = res.div.neg();
                    return {
                        div,
                        mod: res.mod
                    };
                } else if (this.sign && num.sign) {
                    var res = this.neg().divmod(num.neg(), mode);
                    var mod;
                    if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.neg) mod = mod.isub(num);
                    }
                    return {
                        div: res.div,
                        mod
                    };
                }
                if (num.length > this.length || this.cmp(num) < 0) return {
                    div: new BN(0),
                    mod: this
                };
                if (num.length === 1) {
                    if (mode === "div") return {
                        div: this.divn(num.words[0]),
                        mod: null
                    }; else if (mode === "mod") return {
                        div: null,
                        mod: new BN(this.modn(num.words[0]))
                    };
                    return {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    };
                }
                return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
                return this.divmod(num, "div", false).div;
            };
            BN.prototype.mod = function mod(num) {
                return this.divmod(num, "mod", false).mod;
            };
            BN.prototype.umod = function umod(num) {
                return this.divmod(num, "mod", true).mod;
            };
            BN.prototype.divRound = function divRound(num) {
                var dm = this.divmod(num);
                if (dm.mod.cmpn(0) === 0) return dm.div;
                var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
                var half = num.ushrn(1);
                var r2 = num.andln(1);
                var cmp = mod.cmp(half);
                if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
                return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
                assert(num <= 67108863);
                var p = (1 << 26) % num;
                var acc = 0;
                for (var i = this.length - 1; i >= 0; i--) acc = (p * acc + this.words[i]) % num;
                return acc;
            };
            BN.prototype.idivn = function idivn(num) {
                assert(num <= 67108863);
                var carry = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var w = this.words[i] + carry * 67108864;
                    this.words[i] = w / num | 0;
                    carry = w % num;
                }
                return this.strip();
            };
            BN.prototype.divn = function divn(num) {
                return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
                assert(!p.sign);
                assert(p.cmpn(0) !== 0);
                var x = this;
                var y = p.clone();
                if (x.sign) x = x.umod(p); else x = x.clone();
                var A = new BN(1);
                var B = new BN(0);
                var C = new BN(0);
                var D = new BN(1);
                var g = 0;
                while (x.isEven() && y.isEven()) {
                    x.iushrn(1);
                    y.iushrn(1);
                    ++g;
                }
                var yp = y.clone();
                var xp = x.clone();
                while (x.cmpn(0) !== 0) {
                    while (x.isEven()) {
                        x.iushrn(1);
                        if (A.isEven() && B.isEven()) {
                            A.iushrn(1);
                            B.iushrn(1);
                        } else {
                            A.iadd(yp).iushrn(1);
                            B.isub(xp).iushrn(1);
                        }
                    }
                    while (y.isEven()) {
                        y.iushrn(1);
                        if (C.isEven() && D.isEven()) {
                            C.iushrn(1);
                            D.iushrn(1);
                        } else {
                            C.iadd(yp).iushrn(1);
                            D.isub(xp).iushrn(1);
                        }
                    }
                    if (x.cmp(y) >= 0) {
                        x.isub(y);
                        A.isub(C);
                        B.isub(D);
                    } else {
                        y.isub(x);
                        C.isub(A);
                        D.isub(B);
                    }
                }
                return {
                    a: C,
                    b: D,
                    gcd: y.iushln(g)
                };
            };
            BN.prototype._invmp = function _invmp(p) {
                assert(!p.sign);
                assert(p.cmpn(0) !== 0);
                var a = this;
                var b = p.clone();
                if (a.sign) a = a.umod(p); else a = a.clone();
                var x1 = new BN(1);
                var x2 = new BN(0);
                var delta = b.clone();
                while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                    while (a.isEven()) {
                        a.iushrn(1);
                        if (x1.isEven()) x1.iushrn(1); else x1.iadd(delta).iushrn(1);
                    }
                    while (b.isEven()) {
                        b.iushrn(1);
                        if (x2.isEven()) x2.iushrn(1); else x2.iadd(delta).iushrn(1);
                    }
                    if (a.cmp(b) >= 0) {
                        a.isub(b);
                        x1.isub(x2);
                    } else {
                        b.isub(a);
                        x2.isub(x1);
                    }
                }
                var res;
                if (a.cmpn(1) === 0) res = x1; else res = x2;
                if (res.cmpn(0) < 0) res.iadd(p);
                return res;
            };
            BN.prototype.gcd = function gcd(num) {
                if (this.cmpn(0) === 0) return num.clone();
                if (num.cmpn(0) === 0) return this.clone();
                var a = this.clone();
                var b = num.clone();
                a.sign = false;
                b.sign = false;
                for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                    a.iushrn(1);
                    b.iushrn(1);
                }
                do {
                    while (a.isEven()) a.iushrn(1);
                    while (b.isEven()) b.iushrn(1);
                    var r = a.cmp(b);
                    if (r < 0) {
                        var t = a;
                        a = b;
                        b = t;
                    } else if (r === 0 || b.cmpn(1) === 0) {
                        break;
                    }
                    a.isub(b);
                } while (true);
                return b.iushln(shift);
            };
            BN.prototype.invm = function invm(num) {
                return this.egcd(num).a.umod(num);
            };
            BN.prototype.isEven = function isEven() {
                return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
                return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
                return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
                assert(typeof bit === "number");
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) {
                    for (var i = this.length; i < s + 1; i++) this.words[i] = 0;
                    this.words[s] |= q;
                    this.length = s + 1;
                    return this;
                }
                var carry = q;
                for (var i = s; carry !== 0 && i < this.length; i++) {
                    var w = this.words[i];
                    w += carry;
                    carry = w >>> 26;
                    w &= 67108863;
                    this.words[i] = w;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.cmpn = function cmpn(num) {
                var sign = num < 0;
                if (sign) num = -num;
                if (this.sign && !sign) return -1; else if (!this.sign && sign) return 1;
                num &= 67108863;
                this.strip();
                var res;
                if (this.length > 1) {
                    res = 1;
                } else {
                    var w = this.words[0];
                    res = w === num ? 0 : w < num ? -1 : 1;
                }
                if (this.sign) res = -res;
                return res;
            };
            BN.prototype.cmp = function cmp(num) {
                if (this.sign && !num.sign) return -1; else if (!this.sign && num.sign) return 1;
                var res = this.ucmp(num);
                if (this.sign) return -res; else return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
                if (this.length > num.length) return 1; else if (this.length < num.length) return -1;
                var res = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var a = this.words[i];
                    var b = num.words[i];
                    if (a === b) continue;
                    if (a < b) res = -1; else if (a > b) res = 1;
                    break;
                }
                return res;
            };
            BN.red = function red(num) {
                return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                assert(!this.sign, "red works only with positives");
                return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
                assert(this.red, "fromRed works only with numbers in reduction context");
                return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
                this.red = ctx;
                return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
                assert(this.red, "redAdd works only with red numbers");
                return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
                assert(this.red, "redIAdd works only with red numbers");
                return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
                assert(this.red, "redSub works only with red numbers");
                return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
                assert(this.red, "redISub works only with red numbers");
                return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
                assert(this.red, "redShl works only with red numbers");
                return this.red.ushl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
                assert(this.red, "redSqr works only with red numbers");
                this.red._verify1(this);
                return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
                assert(this.red, "redISqr works only with red numbers");
                this.red._verify1(this);
                return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
                assert(this.red, "redSqrt works only with red numbers");
                this.red._verify1(this);
                return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
                assert(this.red, "redInvm works only with red numbers");
                this.red._verify1(this);
                return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
                assert(this.red, "redNeg works only with red numbers");
                this.red._verify1(this);
                return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
                assert(this.red && !num.red, "redPow(normalNum)");
                this.red._verify1(this);
                return this.red.pow(this, num);
            };
            var primes = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function MPrime(name, p) {
                this.name = name;
                this.p = new BN(p, 16);
                this.n = this.p.bitLength();
                this.k = new BN(1).iushln(this.n).isub(this.p);
                this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
                var tmp = new BN(null);
                tmp.words = new Array(Math.ceil(this.n / 13));
                return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
                var r = num;
                var rlen;
                do {
                    this.split(r, this.tmp);
                    r = this.imulK(r);
                    r = r.iadd(this.tmp);
                    rlen = r.bitLength();
                } while (rlen > this.n);
                var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                if (cmp === 0) {
                    r.words[0] = 0;
                    r.length = 1;
                } else if (cmp > 0) {
                    r.isub(this.p);
                } else {
                    r.strip();
                }
                return r;
            };
            MPrime.prototype.split = function split(input, out) {
                input.iushrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
                return num.imul(this.k);
            };
            function K256() {
                MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
                var mask = 4194303;
                var outLen = Math.min(input.length, 9);
                for (var i = 0; i < outLen; i++) output.words[i] = input.words[i];
                output.length = outLen;
                if (input.length <= 9) {
                    input.words[0] = 0;
                    input.length = 1;
                    return;
                }
                var prev = input.words[9];
                output.words[output.length++] = prev & mask;
                for (var i = 10; i < input.length; i++) {
                    var next = input.words[i];
                    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
                    prev = next;
                }
                input.words[i - 10] = prev >>> 22;
                input.length -= 9;
            };
            K256.prototype.imulK = function imulK(num) {
                num.words[num.length] = 0;
                num.words[num.length + 1] = 0;
                num.length += 2;
                var hi;
                var lo = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = num.words[i];
                    hi = w * 64;
                    lo += w * 977;
                    hi += lo / 67108864 | 0;
                    lo &= 67108863;
                    num.words[i] = lo;
                    lo = hi;
                }
                if (num.words[num.length - 1] === 0) {
                    num.length--;
                    if (num.words[num.length - 1] === 0) num.length--;
                }
                return num;
            };
            function P224() {
                MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            inherits(P224, MPrime);
            function P192() {
                MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            inherits(P192, MPrime);
            function P25519() {
                MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var hi = num.words[i] * 19 + carry;
                    var lo = hi & 67108863;
                    hi >>>= 26;
                    num.words[i] = lo;
                    carry = hi;
                }
                if (carry !== 0) num.words[num.length++] = carry;
                return num;
            };
            BN._prime = function prime(name) {
                if (primes[name]) return primes[name];
                var prime;
                if (name === "k256") prime = new K256(); else if (name === "p224") prime = new P224(); else if (name === "p192") prime = new P192(); else if (name === "p25519") prime = new P25519(); else throw new Error("Unknown prime " + name);
                primes[name] = prime;
                return prime;
            };
            function Red(m) {
                if (typeof m === "string") {
                    var prime = BN._prime(m);
                    this.m = prime.p;
                    this.prime = prime;
                } else {
                    this.m = m;
                    this.prime = null;
                }
            }
            Red.prototype._verify1 = function _verify1(a) {
                assert(!a.sign, "red works only with positives");
                assert(a.red, "red works only with red numbers");
            };
            Red.prototype._verify2 = function _verify2(a, b) {
                assert(!a.sign && !b.sign, "red works only with positives");
                assert(a.red && a.red === b.red, "red works only with red numbers");
            };
            Red.prototype.imod = function imod(a) {
                if (this.prime) return this.prime.ireduce(a)._forceRed(this);
                return a.umod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
                var r = a.clone();
                r.sign = !r.sign;
                return r.iadd(this.m)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
                this._verify2(a, b);
                var res = a.add(b);
                if (res.cmp(this.m) >= 0) res.isub(this.m);
                return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
                this._verify2(a, b);
                var res = a.iadd(b);
                if (res.cmp(this.m) >= 0) res.isub(this.m);
                return res;
            };
            Red.prototype.sub = function sub(a, b) {
                this._verify2(a, b);
                var res = a.sub(b);
                if (res.cmpn(0) < 0) res.iadd(this.m);
                return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
                this._verify2(a, b);
                var res = a.isub(b);
                if (res.cmpn(0) < 0) res.iadd(this.m);
                return res;
            };
            Red.prototype.shl = function shl(a, num) {
                this._verify1(a);
                return this.imod(a.ushln(num));
            };
            Red.prototype.imul = function imul(a, b) {
                this._verify2(a, b);
                return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
                this._verify2(a, b);
                return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
                return this.imul(a, a);
            };
            Red.prototype.sqr = function sqr(a) {
                return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
                if (a.cmpn(0) === 0) return a.clone();
                var mod3 = this.m.andln(3);
                assert(mod3 % 2 === 1);
                if (mod3 === 3) {
                    var pow = this.m.add(new BN(1)).iushrn(2);
                    var r = this.pow(a, pow);
                    return r;
                }
                var q = this.m.subn(1);
                var s = 0;
                while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
                    s++;
                    q.iushrn(1);
                }
                assert(q.cmpn(0) !== 0);
                var one = new BN(1).toRed(this);
                var nOne = one.redNeg();
                var lpow = this.m.subn(1).iushrn(1);
                var z = this.m.bitLength();
                z = new BN(2 * z * z).toRed(this);
                while (this.pow(z, lpow).cmp(nOne) !== 0) z.redIAdd(nOne);
                var c = this.pow(z, q);
                var r = this.pow(a, q.addn(1).iushrn(1));
                var t = this.pow(a, q);
                var m = s;
                while (t.cmp(one) !== 0) {
                    var tmp = t;
                    for (var i = 0; tmp.cmp(one) !== 0; i++) tmp = tmp.redSqr();
                    assert(i < m);
                    var b = this.pow(c, new BN(1).iushln(m - i - 1));
                    r = r.redMul(b);
                    c = b.redSqr();
                    t = t.redMul(c);
                    m = i;
                }
                return r;
            };
            Red.prototype.invm = function invm(a) {
                var inv = a._invmp(this.m);
                if (inv.sign) {
                    inv.sign = false;
                    return this.imod(inv).redNeg();
                } else {
                    return this.imod(inv);
                }
            };
            Red.prototype.pow = function pow(a, num) {
                var w = toBitArray(num);
                if (w.length === 0) return new BN(1);
                var res = a;
                for (var i = 0; i < w.length; i++, res = this.sqr(res)) if (w[i] !== 0) break;
                if (++i < w.length) {
                    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
                        if (w[i] === 0) continue;
                        res = this.mul(res, q);
                    }
                }
                return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
                var r = num.umod(this.m);
                if (r === num) return r.clone(); else return r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
                var res = num.clone();
                res.red = null;
                return res;
            };
            BN.mont = function mont(num) {
                return new Mont(num);
            };
            function Mont(m) {
                Red.call(this, m);
                this.shift = this.m.bitLength();
                if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
                this.r = new BN(1).iushln(this.shift);
                this.r2 = this.imod(this.r.sqr());
                this.rinv = this.r._invmp(this.m);
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                this.minv = this.minv.umod(this.r);
                this.minv = this.r.sub(this.minv);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
                return this.imod(num.ushln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
                var r = this.imod(num.mul(this.rinv));
                r.red = null;
                return r;
            };
            Mont.prototype.imul = function imul(a, b) {
                if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
                    a.words[0] = 0;
                    a.length = 1;
                    return a;
                }
                var t = a.imul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) res = u.isub(this.m); else if (u.cmpn(0) < 0) res = u.iadd(this.m);
                return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
                if (a.cmpn(0) === 0 || b.cmpn(0) === 0) return new BN(0)._forceRed(this);
                var t = a.mul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) res = u.isub(this.m); else if (u.cmpn(0) < 0) res = u.iadd(this.m);
                return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
                var res = this.imod(a._invmp(this.m).mul(this.r2));
                return res._forceRed(this);
            };
        })(typeof module === "undefined" || module, this);
    }).call(this, __webpack_require__(46)(module));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assert = __webpack_require__(15);
    var inherits = __webpack_require__(3);
    exports.inherits = inherits;
    function toArray(msg, enc) {
        if (Array.isArray(msg)) return msg.slice();
        if (!msg) return [];
        var res = [];
        if (typeof msg === "string") {
            if (!enc) {
                for (var i = 0; i < msg.length; i++) {
                    var c = msg.charCodeAt(i);
                    var hi = c >> 8;
                    var lo = c & 255;
                    if (hi) res.push(hi, lo); else res.push(lo);
                }
            } else if (enc === "hex") {
                msg = msg.replace(/[^a-z0-9]+/gi, "");
                if (msg.length % 2 !== 0) msg = "0" + msg;
                for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
        } else {
            for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
        }
        return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
        return res;
    }
    exports.toHex = toHex;
    function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
            var w = msg[i];
            if (endian === "little") w = htonl(w);
            res += zero8(w.toString(16));
        }
        return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
        if (word.length === 1) return "0" + word; else return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
        if (word.length === 7) return "0" + word; else if (word.length === 6) return "00" + word; else if (word.length === 5) return "000" + word; else if (word.length === 4) return "0000" + word; else if (word.length === 3) return "00000" + word; else if (word.length === 2) return "000000" + word; else if (word.length === 1) return "0000000" + word; else return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
            var w;
            if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3]; else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
            res[i] = w >>> 0;
        }
        return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
            var m = msg[i];
            if (endian === "big") {
                res[k] = m >>> 24;
                res[k + 1] = m >>> 16 & 255;
                res[k + 2] = m >>> 8 & 255;
                res[k + 3] = m & 255;
            } else {
                res[k + 3] = m >>> 24;
                res[k + 2] = m >>> 16 & 255;
                res[k + 1] = m >>> 8 & 255;
                res[k] = m & 255;
            }
        }
        return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
        return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
        return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
        return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
        return a + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
        return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
        return path.charAt(0) === "/" ? path : "/" + path;
    };
    var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
        return path.charAt(0) === "/" ? path.substr(1) : path;
    };
    var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
        return new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path);
    };
    var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
        return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
    };
    var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
        return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
    };
    var parsePath = exports.parsePath = function parsePath(path) {
        var pathname = path || "/";
        var search = "";
        var hash = "";
        var hashIndex = pathname.indexOf("#");
        if (hashIndex !== -1) {
            hash = pathname.substr(hashIndex);
            pathname = pathname.substr(0, hashIndex);
        }
        var searchIndex = pathname.indexOf("?");
        if (searchIndex !== -1) {
            search = pathname.substr(searchIndex);
            pathname = pathname.substr(0, searchIndex);
        }
        return {
            pathname,
            search: search === "?" ? "" : search,
            hash: hash === "#" ? "" : hash
        };
    };
    var createPath = exports.createPath = function createPath(location) {
        var pathname = location.pathname, search = location.search, hash = location.hash;
        var path = pathname || "/";
        if (search && search !== "?") path += search.charAt(0) === "?" ? search : "?" + search;
        if (hash && hash !== "#") path += hash.charAt(0) === "#" ? hash : "#" + hash;
        return path;
    };
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityParam = __webpack_require__(103);
    var SolidityType = function(config) {
        this._inputFormatter = config.inputFormatter;
        this._outputFormatter = config.outputFormatter;
    };
    SolidityType.prototype.isType = function(name) {
        throw "this method should be overrwritten for type " + name;
    };
    SolidityType.prototype.staticPartLength = function(name) {
        return (this.nestedTypes(name) || [ "[1]" ]).map(function(type) {
            return parseInt(type.slice(1, -1), 10) || 1;
        }).reduce(function(previous, current) {
            return previous * current;
        }, 32);
    };
    SolidityType.prototype.isDynamicArray = function(name) {
        var nestedTypes = this.nestedTypes(name);
        return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
    };
    SolidityType.prototype.isStaticArray = function(name) {
        var nestedTypes = this.nestedTypes(name);
        return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
    };
    SolidityType.prototype.staticArrayLength = function(name) {
        var nestedTypes = this.nestedTypes(name);
        if (nestedTypes) {
            return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
        }
        return 1;
    };
    SolidityType.prototype.nestedName = function(name) {
        var nestedTypes = this.nestedTypes(name);
        if (!nestedTypes) {
            return name;
        }
        return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
    };
    SolidityType.prototype.isDynamicType = function() {
        return false;
    };
    SolidityType.prototype.nestedTypes = function(name) {
        return name.match(/(\[[0-9]*\])/g);
    };
    SolidityType.prototype.encode = function(value, name) {
        var self = this;
        if (this.isDynamicArray(name)) {
            return function() {
                var length = value.length;
                var nestedName = self.nestedName(name);
                var result = [];
                result.push(f.formatInputInt(length).encode());
                value.forEach(function(v) {
                    result.push(self.encode(v, nestedName));
                });
                return result;
            }();
        } else if (this.isStaticArray(name)) {
            return function() {
                var length = self.staticArrayLength(name);
                var nestedName = self.nestedName(name);
                var result = [];
                for (var i = 0; i < length; i++) {
                    result.push(self.encode(value[i], nestedName));
                }
                return result;
            }();
        }
        return this._inputFormatter(value, name).encode();
    };
    SolidityType.prototype.decode = function(bytes, offset, name) {
        var self = this;
        if (this.isDynamicArray(name)) {
            return function() {
                var arrayOffset = parseInt("0x" + bytes.substr(offset * 2, 64));
                var length = parseInt("0x" + bytes.substr(arrayOffset * 2, 64));
                var arrayStart = arrayOffset + 32;
                var nestedName = self.nestedName(name);
                var nestedStaticPartLength = self.staticPartLength(nestedName);
                var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
                var result = [];
                for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                    result.push(self.decode(bytes, arrayStart + i, nestedName));
                }
                return result;
            }();
        } else if (this.isStaticArray(name)) {
            return function() {
                var length = self.staticArrayLength(name);
                var arrayStart = offset;
                var nestedName = self.nestedName(name);
                var nestedStaticPartLength = self.staticPartLength(nestedName);
                var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
                var result = [];
                for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                    result.push(self.decode(bytes, arrayStart + i, nestedName));
                }
                return result;
            }();
        } else if (this.isDynamicType(name)) {
            return function() {
                var dynamicOffset = parseInt("0x" + bytes.substr(offset * 2, 64));
                var length = parseInt("0x" + bytes.substr(dynamicOffset * 2, 64));
                var roundedLength = Math.floor((length + 31) / 32);
                var param = new SolidityParam(bytes.substr(dynamicOffset * 2, (1 + roundedLength) * 64), 0);
                return self._outputFormatter(param, name);
            }();
        }
        var length = this.staticPartLength(name);
        var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
        return this._outputFormatter(param, name);
    };
    module.exports = SolidityType;
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var config = __webpack_require__(52);
    var Iban = __webpack_require__(51);
    var outputBigNumberFormatter = function(number) {
        return utils.toBigNumber(number);
    };
    var isPredefinedBlockNumber = function(blockNumber) {
        return blockNumber === "latest" || blockNumber === "pending" || blockNumber === "earliest";
    };
    var inputDefaultBlockNumberFormatter = function(blockNumber) {
        if (blockNumber === undefined) {
            return config.defaultBlock;
        }
        return inputBlockNumberFormatter(blockNumber);
    };
    var inputBlockNumberFormatter = function(blockNumber) {
        if (blockNumber === undefined) {
            return undefined;
        } else if (isPredefinedBlockNumber(blockNumber)) {
            return blockNumber;
        }
        return utils.toHex(blockNumber);
    };
    var inputCallFormatter = function(options) {
        options.from = options.from || config.defaultAccount;
        if (options.from) {
            options.from = inputAddressFormatter(options.from);
        }
        if (options.to) {
            options.to = inputAddressFormatter(options.to);
        }
        [ "gasPrice", "gas", "value", "nonce" ].filter(function(key) {
            return options[key] !== undefined;
        }).forEach(function(key) {
            options[key] = utils.fromDecimal(options[key]);
        });
        return options;
    };
    var inputTransactionFormatter = function(options) {
        options.from = options.from || config.defaultAccount;
        options.from = inputAddressFormatter(options.from);
        if (options.to) {
            options.to = inputAddressFormatter(options.to);
        }
        [ "gasPrice", "gas", "value", "nonce" ].filter(function(key) {
            return options[key] !== undefined;
        }).forEach(function(key) {
            options[key] = utils.fromDecimal(options[key]);
        });
        return options;
    };
    var outputTransactionFormatter = function(tx) {
        if (tx.blockNumber !== null) tx.blockNumber = utils.toDecimal(tx.blockNumber);
        if (tx.transactionIndex !== null) tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
        tx.nonce = utils.toDecimal(tx.nonce);
        tx.gas = utils.toDecimal(tx.gas);
        tx.gasPrice = utils.toBigNumber(tx.gasPrice);
        tx.value = utils.toBigNumber(tx.value);
        return tx;
    };
    var outputTransactionReceiptFormatter = function(receipt) {
        if (receipt.blockNumber !== null) receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
        if (receipt.transactionIndex !== null) receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
        receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
        receipt.gasUsed = utils.toDecimal(receipt.gasUsed);
        if (utils.isArray(receipt.logs)) {
            receipt.logs = receipt.logs.map(function(log) {
                return outputLogFormatter(log);
            });
        }
        return receipt;
    };
    var outputBlockFormatter = function(block) {
        block.gasLimit = utils.toDecimal(block.gasLimit);
        block.gasUsed = utils.toDecimal(block.gasUsed);
        block.size = utils.toDecimal(block.size);
        block.timestamp = utils.toDecimal(block.timestamp);
        if (block.number !== null) block.number = utils.toDecimal(block.number);
        block.difficulty = utils.toBigNumber(block.difficulty);
        block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);
        if (utils.isArray(block.transactions)) {
            block.transactions.forEach(function(item) {
                if (!utils.isString(item)) return outputTransactionFormatter(item);
            });
        }
        return block;
    };
    var outputLogFormatter = function(log) {
        if (log.blockNumber !== null) log.blockNumber = utils.toDecimal(log.blockNumber);
        if (log.transactionIndex !== null) log.transactionIndex = utils.toDecimal(log.transactionIndex);
        if (log.logIndex !== null) log.logIndex = utils.toDecimal(log.logIndex);
        return log;
    };
    var inputPostFormatter = function(post) {
        post.ttl = utils.fromDecimal(post.ttl);
        post.workToProve = utils.fromDecimal(post.workToProve);
        post.priority = utils.fromDecimal(post.priority);
        if (!utils.isArray(post.topics)) {
            post.topics = post.topics ? [ post.topics ] : [];
        }
        post.topics = post.topics.map(function(topic) {
            return topic.indexOf("0x") === 0 ? topic : utils.fromUtf8(topic);
        });
        return post;
    };
    var outputPostFormatter = function(post) {
        post.expiry = utils.toDecimal(post.expiry);
        post.sent = utils.toDecimal(post.sent);
        post.ttl = utils.toDecimal(post.ttl);
        post.workProved = utils.toDecimal(post.workProved);
        if (!post.topics) {
            post.topics = [];
        }
        post.topics = post.topics.map(function(topic) {
            return utils.toAscii(topic);
        });
        return post;
    };
    var inputAddressFormatter = function(address) {
        var iban = new Iban(address);
        if (iban.isValid() && iban.isDirect()) {
            return "0x" + iban.address();
        } else if (utils.isStrictAddress(address)) {
            return address;
        } else if (utils.isAddress(address)) {
            return "0x" + address;
        }
        throw new Error("invalid address");
    };
    var outputSyncingFormatter = function(result) {
        result.startingBlock = utils.toDecimal(result.startingBlock);
        result.currentBlock = utils.toDecimal(result.currentBlock);
        result.highestBlock = utils.toDecimal(result.highestBlock);
        if (result.knownStates) {
            result.knownStates = utils.toDecimal(result.knownStates);
            result.pulledStates = utils.toDecimal(result.pulledStates);
        }
        return result;
    };
    module.exports = {
        inputDefaultBlockNumberFormatter,
        inputBlockNumberFormatter,
        inputCallFormatter,
        inputTransactionFormatter,
        inputAddressFormatter,
        inputPostFormatter,
        outputBigNumberFormatter,
        outputTransactionFormatter,
        outputTransactionReceiptFormatter,
        outputBlockFormatter,
        outputLogFormatter,
        outputPostFormatter,
        outputSyncingFormatter
    };
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    var Transform = __webpack_require__(43).Transform;
    var StringDecoder = __webpack_require__(79).StringDecoder;
    var inherits = __webpack_require__(3);
    function CipherBase(hashMode) {
        Transform.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
            this[hashMode] = this._finalOrDigest;
        } else {
            this.final = this._finalOrDigest;
        }
        if (this._final) {
            this.__final = this._final;
            this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
    }
    inherits(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
            data = Buffer.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode) return this;
        if (outputEnc) {
            outData = this._toString(outData, outputEnc);
        }
        return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {};
    CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
            if (this.hashMode) {
                this._update(data);
            } else {
                this.push(this._update(data));
            }
        } catch (e) {
            err = e;
        } finally {
            next(err);
        }
    };
    CipherBase.prototype._flush = function(done) {
        var err;
        try {
            this.push(this.__final());
        } catch (e) {
            err = e;
        }
        done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer.alloc(0);
        if (outputEnc) {
            outData = this._toString(outData, outputEnc, true);
        }
        return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
            this._decoder = new StringDecoder(enc);
            this._encoding = enc;
        }
        if (this._encoding !== enc) throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
            out += this._decoder.end();
        }
        return out;
    };
    module.exports = CipherBase;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, "createStore", function() {
        return createStore;
    });
    __webpack_require__.d(__webpack_exports__, "combineReducers", function() {
        return combineReducers;
    });
    __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() {
        return bindActionCreators;
    });
    __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() {
        return applyMiddleware;
    });
    __webpack_require__.d(__webpack_exports__, "compose", function() {
        return compose;
    });
    __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() {
        return ActionTypes;
    });
    var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);
    var ActionTypes = {
        INIT: "@@redux/INIT" + Math.random().toString(36).substring(7).split("").join("."),
        REPLACE: "@@redux/REPLACE" + Math.random().toString(36).substring(7).split("").join(".")
    };
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function isPlainObject(obj) {
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object" || obj === null) return false;
        var proto = obj;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(obj) === proto;
    }
    function createStore(reducer, preloadedState, enhancer) {
        var _ref2;
        if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
            enhancer = preloadedState;
            preloadedState = undefined;
        }
        if (typeof enhancer !== "undefined") {
            if (typeof enhancer !== "function") {
                throw new Error("Expected the enhancer to be a function.");
            }
            return enhancer(createStore)(reducer, preloadedState);
        }
        if (typeof reducer !== "function") {
            throw new Error("Expected the reducer to be a function.");
        }
        var currentReducer = reducer;
        var currentState = preloadedState;
        var currentListeners = [];
        var nextListeners = currentListeners;
        var isDispatching = false;
        function ensureCanMutateNextListeners() {
            if (nextListeners === currentListeners) {
                nextListeners = currentListeners.slice();
            }
        }
        function getState() {
            if (isDispatching) {
                throw new Error("You may not call store.getState() while the reducer is executing. " + "The reducer has already received the state as an argument. " + "Pass it down from the top reducer instead of reading it from the store.");
            }
            return currentState;
        }
        function subscribe(listener) {
            if (typeof listener !== "function") {
                throw new Error("Expected the listener to be a function.");
            }
            if (isDispatching) {
                throw new Error("You may not call store.subscribe() while the reducer is executing. " + "If you would like to be notified after the store has been updated, subscribe from a " + "component and invoke store.getState() in the callback to access the latest state. " + "See https://redux.js.org/api-reference/store#subscribe(listener) for more details.");
            }
            var isSubscribed = true;
            ensureCanMutateNextListeners();
            nextListeners.push(listener);
            return function unsubscribe() {
                if (!isSubscribed) {
                    return;
                }
                if (isDispatching) {
                    throw new Error("You may not unsubscribe from a store listener while the reducer is executing. " + "See https://redux.js.org/api-reference/store#subscribe(listener) for more details.");
                }
                isSubscribed = false;
                ensureCanMutateNextListeners();
                var index = nextListeners.indexOf(listener);
                nextListeners.splice(index, 1);
            };
        }
        function dispatch(action) {
            if (!isPlainObject(action)) {
                throw new Error("Actions must be plain objects. " + "Use custom middleware for async actions.");
            }
            if (typeof action.type === "undefined") {
                throw new Error('Actions may not have an undefined "type" property. ' + "Have you misspelled a constant?");
            }
            if (isDispatching) {
                throw new Error("Reducers may not dispatch actions.");
            }
            try {
                isDispatching = true;
                currentState = currentReducer(currentState, action);
            } finally {
                isDispatching = false;
            }
            var listeners = currentListeners = nextListeners;
            for (var i = 0; i < listeners.length; i++) {
                var listener = listeners[i];
                listener();
            }
            return action;
        }
        function replaceReducer(nextReducer) {
            if (typeof nextReducer !== "function") {
                throw new Error("Expected the nextReducer to be a function.");
            }
            currentReducer = nextReducer;
            dispatch({
                type: ActionTypes.REPLACE
            });
        }
        function observable() {
            var _ref;
            var outerSubscribe = subscribe;
            return _ref = {
                subscribe: function subscribe(observer) {
                    if ((typeof observer === "undefined" ? "undefined" : _typeof(observer)) !== "object" || observer === null) {
                        throw new TypeError("Expected the observer to be an object.");
                    }
                    function observeState() {
                        if (observer.next) {
                            observer.next(getState());
                        }
                    }
                    observeState();
                    var unsubscribe = outerSubscribe(observeState);
                    return {
                        unsubscribe
                    };
                }
            }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["a"]] = function() {
                return this;
            }, _ref;
        }
        dispatch({
            type: ActionTypes.INIT
        });
        return _ref2 = {
            dispatch,
            subscribe,
            getState,
            replaceReducer
        }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["a"]] = observable, _ref2;
    }
    function warning(message) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(message);
        }
        try {
            throw new Error(message);
        } catch (e) {}
    }
    function getUndefinedStateErrorMessage(key, action) {
        var actionType = action && action.type;
        var actionDescription = actionType && 'action "' + String(actionType) + '"' || "an action";
        return "Given " + actionDescription + ', reducer "' + key + '" returned undefined. ' + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
    }
    function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
        var reducerKeys = Object.keys(reducers);
        var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
        if (reducerKeys.length === 0) {
            return "Store does not have a valid reducer. Make sure the argument passed " + "to combineReducers is an object whose values are reducers.";
        }
        if (!isPlainObject(inputState)) {
            return "The " + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
        }
        var unexpectedKeys = Object.keys(inputState).filter(function(key) {
            return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
        });
        unexpectedKeys.forEach(function(key) {
            unexpectedKeyCache[key] = true;
        });
        if (action && action.type === ActionTypes.REPLACE) return;
        if (unexpectedKeys.length > 0) {
            return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
        }
    }
    function assertReducerShape(reducers) {
        Object.keys(reducers).forEach(function(key) {
            var reducer = reducers[key];
            var initialState = reducer(undefined, {
                type: ActionTypes.INIT
            });
            if (typeof initialState === "undefined") {
                throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
            }
            var type = "@@redux/PROBE_UNKNOWN_ACTION_" + Math.random().toString(36).substring(7).split("").join(".");
            if (typeof reducer(undefined, {
                type
            }) === "undefined") {
                throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle " + ActionTypes.INIT + ' or other actions in "redux/*" ') + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
            }
        });
    }
    function combineReducers(reducers) {
        var reducerKeys = Object.keys(reducers);
        var finalReducers = {};
        for (var i = 0; i < reducerKeys.length; i++) {
            var key = reducerKeys[i];
            if (false) {}
            if (typeof reducers[key] === "function") {
                finalReducers[key] = reducers[key];
            }
        }
        var finalReducerKeys = Object.keys(finalReducers);
        var unexpectedKeyCache = void 0;
        if (false) {}
        var shapeAssertionError = void 0;
        try {
            assertReducerShape(finalReducers);
        } catch (e) {
            shapeAssertionError = e;
        }
        return function combination() {
            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var action = arguments[1];
            if (shapeAssertionError) {
                throw shapeAssertionError;
            }
            if (false) {
                var warningMessage;
            }
            var hasChanged = false;
            var nextState = {};
            for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                var _key = finalReducerKeys[_i];
                var reducer = finalReducers[_key];
                var previousStateForKey = state[_key];
                var nextStateForKey = reducer(previousStateForKey, action);
                if (typeof nextStateForKey === "undefined") {
                    var errorMessage = getUndefinedStateErrorMessage(_key, action);
                    throw new Error(errorMessage);
                }
                nextState[_key] = nextStateForKey;
                hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
            }
            return hasChanged ? nextState : state;
        };
    }
    function bindActionCreator(actionCreator, dispatch) {
        return function() {
            return dispatch(actionCreator.apply(this, arguments));
        };
    }
    function bindActionCreators(actionCreators, dispatch) {
        if (typeof actionCreators === "function") {
            return bindActionCreator(actionCreators, dispatch);
        }
        if ((typeof actionCreators === "undefined" ? "undefined" : _typeof(actionCreators)) !== "object" || actionCreators === null) {
            throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? "null" : typeof actionCreators === "undefined" ? "undefined" : _typeof(actionCreators)) + ". " + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
        }
        var keys = Object.keys(actionCreators);
        var boundActionCreators = {};
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var actionCreator = actionCreators[key];
            if (typeof actionCreator === "function") {
                boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
            }
        }
        return boundActionCreators;
    }
    function compose() {
        for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
            funcs[_key] = arguments[_key];
        }
        if (funcs.length === 0) {
            return function(arg) {
                return arg;
            };
        }
        if (funcs.length === 1) {
            return funcs[0];
        }
        return funcs.reduce(function(a, b) {
            return function() {
                return a(b.apply(undefined, arguments));
            };
        });
    }
    function applyMiddleware() {
        for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
            middlewares[_key] = arguments[_key];
        }
        return function(createStore) {
            return function() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }
                var store = createStore.apply(undefined, args);
                var _dispatch = function dispatch() {
                    throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
                };
                var middlewareAPI = {
                    getState: store.getState,
                    dispatch: function dispatch() {
                        return _dispatch.apply(undefined, arguments);
                    }
                };
                var chain = middlewares.map(function(middleware) {
                    return middleware(middlewareAPI);
                });
                _dispatch = compose.apply(undefined, chain)(store.dispatch);
                return _extends({}, store, {
                    dispatch: _dispatch
                });
            };
        };
    }
    function isCrushed() {}
    if (false) {}
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var errors = __webpack_require__(31);
    var Method = function(options) {
        this.name = options.name;
        this.call = options.call;
        this.params = options.params || 0;
        this.inputFormatter = options.inputFormatter;
        this.outputFormatter = options.outputFormatter;
        this.requestManager = null;
    };
    Method.prototype.setRequestManager = function(rm) {
        this.requestManager = rm;
    };
    Method.prototype.getCall = function(args) {
        return utils.isFunction(this.call) ? this.call(args) : this.call;
    };
    Method.prototype.extractCallback = function(args) {
        if (utils.isFunction(args[args.length - 1])) {
            return args.pop();
        }
    };
    Method.prototype.validateArgs = function(args) {
        if (args.length !== this.params) {
            throw errors.InvalidNumberOfRPCParams();
        }
    };
    Method.prototype.formatInput = function(args) {
        if (!this.inputFormatter) {
            return args;
        }
        return this.inputFormatter.map(function(formatter, index) {
            return formatter ? formatter(args[index]) : args[index];
        });
    };
    Method.prototype.formatOutput = function(result) {
        return this.outputFormatter && result ? this.outputFormatter(result) : result;
    };
    Method.prototype.toPayload = function(args) {
        var call = this.getCall(args);
        var callback = this.extractCallback(args);
        var params = this.formatInput(args);
        this.validateArgs(params);
        return {
            method: call,
            params,
            callback
        };
    };
    Method.prototype.attachToObject = function(obj) {
        var func = this.buildCall();
        func.call = this.call;
        var name = this.name.split(".");
        if (name.length > 1) {
            obj[name[0]] = obj[name[0]] || {};
            obj[name[0]][name[1]] = func;
        } else {
            obj[name[0]] = func;
        }
    };
    Method.prototype.buildCall = function() {
        var method = this;
        var send = function() {
            var payload = method.toPayload(Array.prototype.slice.call(arguments));
            if (payload.callback) {
                return method.requestManager.sendAsync(payload, function(err, result) {
                    payload.callback(err, method.formatOutput(result));
                });
            }
            return method.formatOutput(method.requestManager.send(payload));
        };
        send.request = this.request.bind(this);
        return send;
    };
    Method.prototype.request = function() {
        var payload = this.toPayload(Array.prototype.slice.call(arguments));
        payload.format = this.formatOutput.bind(this);
        return payload;
    };
    module.exports = Method;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var pna = __webpack_require__(62);
    var objectKeys = Object.keys || function(obj) {
        var keys = [];
        for (var key in obj) {
            keys.push(key);
        }
        return keys;
    };
    module.exports = Duplex;
    var util = __webpack_require__(42);
    util.inherits = __webpack_require__(3);
    var Readable = __webpack_require__(154);
    var Writable = __webpack_require__(80);
    util.inherits(Duplex, Readable);
    {
        var keys = objectKeys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
    }
    function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false) this.readable = false;
        if (options && options.writable === false) this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
        this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function onend() {
        if (this.allowHalfOpen || this._writableState.ended) return;
        pna.nextTick(onEndNT, this);
    }
    function onEndNT(self) {
        self.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
        get: function() {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(value) {
            if (this._readableState === undefined || this._writableState === undefined) {
                return;
            }
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
        }
    });
    Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
    };
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var Property = function(options) {
        this.name = options.name;
        this.getter = options.getter;
        this.setter = options.setter;
        this.outputFormatter = options.outputFormatter;
        this.inputFormatter = options.inputFormatter;
        this.requestManager = null;
    };
    Property.prototype.setRequestManager = function(rm) {
        this.requestManager = rm;
    };
    Property.prototype.formatInput = function(arg) {
        return this.inputFormatter ? this.inputFormatter(arg) : arg;
    };
    Property.prototype.formatOutput = function(result) {
        return this.outputFormatter && result !== null && result !== undefined ? this.outputFormatter(result) : result;
    };
    Property.prototype.extractCallback = function(args) {
        if (utils.isFunction(args[args.length - 1])) {
            return args.pop();
        }
    };
    Property.prototype.attachToObject = function(obj) {
        var proto = {
            get: this.buildGet(),
            enumerable: true
        };
        var names = this.name.split(".");
        var name = names[0];
        if (names.length > 1) {
            obj[names[0]] = obj[names[0]] || {};
            obj = obj[names[0]];
            name = names[1];
        }
        Object.defineProperty(obj, name, proto);
        obj[asyncGetterName(name)] = this.buildAsyncGet();
    };
    var asyncGetterName = function(name) {
        return "get" + name.charAt(0).toUpperCase() + name.slice(1);
    };
    Property.prototype.buildGet = function() {
        var property = this;
        return function get() {
            return property.formatOutput(property.requestManager.send({
                method: property.getter
            }));
        };
    };
    Property.prototype.buildAsyncGet = function() {
        var property = this;
        var get = function(callback) {
            property.requestManager.sendAsync({
                method: property.getter
            }, function(err, result) {
                callback(err, property.formatOutput(result));
            });
        };
        get.request = this.request.bind(this);
        return get;
    };
    Property.prototype.request = function() {
        var payload = {
            method: this.getter,
            params: [],
            callback: this.extractCallback(Array.prototype.slice.call(arguments))
        };
        payload.format = this.formatOutput.bind(this);
        return payload;
    };
    module.exports = Property;
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(68), __webpack_require__(67));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var MD5 = C_algo.MD5;
            var EvpKDF = C_algo.EvpKDF = Base.extend({
                cfg: Base.extend({
                    keySize: 128 / 32,
                    hasher: MD5,
                    iterations: 1
                }),
                init: function(cfg) {
                    this.cfg = this.cfg.extend(cfg);
                },
                compute: function(password, salt) {
                    var cfg = this.cfg;
                    var hasher = cfg.hasher.create();
                    var derivedKey = WordArray.create();
                    var derivedKeyWords = derivedKey.words;
                    var keySize = cfg.keySize;
                    var iterations = cfg.iterations;
                    while (derivedKeyWords.length < keySize) {
                        if (block) {
                            hasher.update(block);
                        }
                        var block = hasher.update(password).finalize(salt);
                        hasher.reset();
                        for (var i = 1; i < iterations; i++) {
                            block = hasher.finalize(block);
                            hasher.reset();
                        }
                        derivedKey.concat(block);
                    }
                    derivedKey.sigBytes = keySize * 4;
                    return derivedKey;
                }
            });
            C.EvpKDF = function(password, salt, cfg) {
                return EvpKDF.create(cfg).compute(password, salt);
            };
        })();
        return CryptoJS.EvpKDF;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function(Math) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
            var T = [];
            (function() {
                for (var i = 0; i < 64; i++) {
                    T[i] = Math.abs(Math.sin(i + 1)) * 4294967296 | 0;
                }
            })();
            var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function() {
                    this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878 ]);
                },
                _doProcessBlock: function(M, offset) {
                    for (var i = 0; i < 16; i++) {
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
                        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                    }
                    var H = this._hash.words;
                    var M_offset_0 = M[offset + 0];
                    var M_offset_1 = M[offset + 1];
                    var M_offset_2 = M[offset + 2];
                    var M_offset_3 = M[offset + 3];
                    var M_offset_4 = M[offset + 4];
                    var M_offset_5 = M[offset + 5];
                    var M_offset_6 = M[offset + 6];
                    var M_offset_7 = M[offset + 7];
                    var M_offset_8 = M[offset + 8];
                    var M_offset_9 = M[offset + 9];
                    var M_offset_10 = M[offset + 10];
                    var M_offset_11 = M[offset + 11];
                    var M_offset_12 = M[offset + 12];
                    var M_offset_13 = M[offset + 13];
                    var M_offset_14 = M[offset + 14];
                    var M_offset_15 = M[offset + 15];
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                    d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                    c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                    b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                    a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                    d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                    c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                    b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                    a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                    d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                    a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                    b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                    a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                    d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                    b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                    a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                    d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                    b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                    a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                    d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                    c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                    b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                    a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                    d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                    c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                    b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                    a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                    d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                    a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                    d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                    c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                    a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                    d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                    c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                    b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                    a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                    b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                    a = II(a, b, c, d, M_offset_0, 6, T[48]);
                    d = II(d, a, b, c, M_offset_7, 10, T[49]);
                    c = II(c, d, a, b, M_offset_14, 15, T[50]);
                    b = II(b, c, d, a, M_offset_5, 21, T[51]);
                    a = II(a, b, c, d, M_offset_12, 6, T[52]);
                    d = II(d, a, b, c, M_offset_3, 10, T[53]);
                    c = II(c, d, a, b, M_offset_10, 15, T[54]);
                    b = II(b, c, d, a, M_offset_1, 21, T[55]);
                    a = II(a, b, c, d, M_offset_8, 6, T[56]);
                    d = II(d, a, b, c, M_offset_15, 10, T[57]);
                    c = II(c, d, a, b, M_offset_6, 15, T[58]);
                    b = II(b, c, d, a, M_offset_13, 21, T[59]);
                    a = II(a, b, c, d, M_offset_4, 6, T[60]);
                    d = II(d, a, b, c, M_offset_11, 10, T[61]);
                    c = II(c, d, a, b, M_offset_2, 15, T[62]);
                    b = II(b, c, d, a, M_offset_9, 21, T[63]);
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                },
                _doFinalize: function() {
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                    var nBitsTotalH = Math.floor(nBitsTotal / 4294967296);
                    var nBitsTotalL = nBitsTotal;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                    data.sigBytes = (dataWords.length + 1) * 4;
                    this._process();
                    var hash = this._hash;
                    var H = hash.words;
                    for (var i = 0; i < 4; i++) {
                        var H_i = H[i];
                        H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                    }
                    return hash;
                },
                clone: function() {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
                    return clone;
                }
            });
            function FF(a, b, c, d, x, s, t) {
                var n = a + (b & c | ~b & d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }
            function GG(a, b, c, d, x, s, t) {
                var n = a + (b & d | c & ~d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }
            function HH(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }
            function II(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }
            C.MD5 = Hasher._createHelper(MD5);
            C.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
        return CryptoJS.MD5;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;
            var Base64 = C_enc.Base64 = {
                stringify: function(wordArray) {
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var map = this._map;
                    wordArray.clamp();
                    var base64Chars = [];
                    for (var i = 0; i < sigBytes; i += 3) {
                        var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                        var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                        var triplet = byte1 << 16 | byte2 << 8 | byte3;
                        for (var j = 0; j < 4 && i + j * .75 < sigBytes; j++) {
                            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                        }
                    }
                    var paddingChar = map.charAt(64);
                    if (paddingChar) {
                        while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                        }
                    }
                    return base64Chars.join("");
                },
                parse: function(base64Str) {
                    var base64StrLength = base64Str.length;
                    var map = this._map;
                    var reverseMap = this._reverseMap;
                    if (!reverseMap) {
                        reverseMap = this._reverseMap = [];
                        for (var j = 0; j < map.length; j++) {
                            reverseMap[map.charCodeAt(j)] = j;
                        }
                    }
                    var paddingChar = map.charAt(64);
                    if (paddingChar) {
                        var paddingIndex = base64Str.indexOf(paddingChar);
                        if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                        }
                    }
                    return parseLoop(base64Str, base64StrLength, reverseMap);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            };
            function parseLoop(base64Str, base64StrLength, reverseMap) {
                var words = [];
                var nBytes = 0;
                for (var i = 0; i < base64StrLength; i++) {
                    if (i % 4) {
                        var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                        var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                        words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
                        nBytes++;
                    }
                }
                return WordArray.create(words, nBytes);
            }
        })();
        return CryptoJS.enc.Base64;
    });
}, function(module, exports) {
    module.exports = {
        InvalidNumberOfSolidityArgs: function() {
            return new Error("Invalid number of arguments to Solidity function");
        },
        InvalidNumberOfRPCParams: function() {
            return new Error("Invalid number of input parameters to RPC method");
        },
        InvalidConnection: function(host) {
            return new Error("CONNECTION ERROR: Couldn't connect to node " + host + ".");
        },
        InvalidProvider: function() {
            return new Error("Provider not set or invalid");
        },
        InvalidResponse: function(result) {
            var message = !!result && !!result.error && !!result.error.message ? result.error.message : "Invalid JSON RPC response: " + JSON.stringify(result);
            return new Error(message);
        },
        ConnectionTimeout: function(ms) {
            return new Error("CONNECTION TIMEOUT: timeout of " + ms + " ms achived");
        }
    };
}, function(module, exports, __webpack_require__) {
    var asn1 = exports;
    asn1.bignum = __webpack_require__(350);
    asn1.define = __webpack_require__(349).define;
    asn1.base = __webpack_require__(58);
    asn1.constants = __webpack_require__(123);
    asn1.decoders = __webpack_require__(345);
    asn1.encoders = __webpack_require__(343);
}, function(module, exports, __webpack_require__) {
    var asn1 = exports;
    asn1.bignum = __webpack_require__(9);
    asn1.define = __webpack_require__(370).define;
    asn1.base = __webpack_require__(40);
    asn1.constants = __webpack_require__(131);
    asn1.decoders = __webpack_require__(365);
    asn1.encoders = __webpack_require__(363);
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    function Hash(blockSize, finalSize) {
        this._block = Buffer.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
            enc = enc || "utf8";
            data = Buffer.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length; ) {
            var assigned = accum % blockSize;
            var remainder = Math.min(length - offset, blockSize - assigned);
            for (var i = 0; i < remainder; i++) {
                block[assigned + i] = data[offset + i];
            }
            accum += remainder;
            offset += remainder;
            if (accum % blockSize === 0) {
                this._update(block);
            }
        }
        this._len += length;
        return this;
    };
    Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
            this._update(this._block);
            this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
            this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
            var lowBits = (bits & 4294967295) >>> 0;
            var highBits = (bits - lowBits) / 4294967296;
            this._block.writeUInt32BE(highBits, this._blockSize - 8);
            this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash = this._hash();
        return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(global, process) {
        function oldBrowser() {
            throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
        }
        var Buffer = __webpack_require__(7).Buffer;
        var crypto = global.crypto || global.msCrypto;
        if (crypto && crypto.getRandomValues) {
            module.exports = randomBytes;
        } else {
            module.exports = oldBrowser;
        }
        function randomBytes(size, cb) {
            if (size > 65536) throw new Error("requested too many random bytes");
            var rawBytes = new global.Uint8Array(size);
            if (size > 0) {
                crypto.getRandomValues(rawBytes);
            }
            var bytes = Buffer.from(rawBytes.buffer);
            if (typeof cb === "function") {
                return process.nextTick(function() {
                    cb(null, bytes);
                });
            }
            return bytes;
        }
    }).call(this, __webpack_require__(12), __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    var hash = exports;
    hash.utils = __webpack_require__(19);
    hash.common = __webpack_require__(45);
    hash.sha = __webpack_require__(425);
    hash.ripemd = __webpack_require__(421);
    hash.hmac = __webpack_require__(420);
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
}, function(module, exports, __webpack_require__) {
    var CryptoJS = __webpack_require__(258);
    var sha3 = __webpack_require__(104);
    module.exports = function(value, options) {
        if (options && options.encoding === "hex") {
            if (value.length > 2 && value.substr(0, 2) === "0x") {
                value = value.substr(2);
            }
            value = CryptoJS.enc.Hex.parse(value);
        }
        return sha3(value, {
            outputLength: 256
        }).toString();
    };
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function(global) {
        "use strict";
        var BigNumber, crypto, parseNumeric, isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, notBool = " not a boolean or binary digit", roundingMode = "rounding mode", tooManyDigits = "number type has more than 15 significant digits", ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13 ], SQRT_BASE = 1e7, MAX = 1e9;
        function another(configObj) {
            var div, id = 0, P = BigNumber.prototype, ONE = new BigNumber(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, ERRORS = true, isValidInt = intValidatorWithErrors, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 100, FORMAT = {
                decimalSeparator: ".",
                groupSeparator: ",",
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: " ",
                fractionGroupSize: 0
            };
            function BigNumber(n, b) {
                var c, e, i, num, len, str, x = this;
                if (!(x instanceof BigNumber)) {
                    if (ERRORS) raise(26, "constructor call without new", n);
                    return new BigNumber(n, b);
                }
                if (b == null || !isValidInt(b, 2, 64, id, "base")) {
                    if (n instanceof BigNumber) {
                        x.s = n.s;
                        x.e = n.e;
                        x.c = (n = n.c) ? n.slice() : n;
                        id = 0;
                        return;
                    }
                    if ((num = typeof n == "number") && n * 0 == 0) {
                        x.s = 1 / n < 0 ? (n = -n, -1) : 1;
                        if (n === ~~n) {
                            for (e = 0, i = n; i >= 10; i /= 10, e++) ;
                            x.e = e;
                            x.c = [ n ];
                            id = 0;
                            return;
                        }
                        str = n + "";
                    } else {
                        if (!isNumeric.test(str = n + "")) return parseNumeric(x, str, num);
                        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                    }
                } else {
                    b = b | 0;
                    str = n + "";
                    if (b == 10) {
                        x = new BigNumber(n instanceof BigNumber ? n : str);
                        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                    }
                    if ((num = typeof n == "number") && n * 0 != 0 || !new RegExp("^-?" + (c = "[" + ALPHABET.slice(0, b) + "]+") + "(?:\\." + c + ")?$", b < 37 ? "i" : "").test(str)) {
                        return parseNumeric(x, str, num, b);
                    }
                    if (num) {
                        x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;
                        if (ERRORS && str.replace(/^0\.0*|\./, "").length > 15) {
                            raise(id, tooManyDigits, n);
                        }
                        num = false;
                    } else {
                        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                    }
                    str = convertBase(str, 10, b, x.s);
                }
                if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
                if ((i = str.search(/e/i)) > 0) {
                    if (e < 0) e = i;
                    e += +str.slice(i + 1);
                    str = str.substring(0, i);
                } else if (e < 0) {
                    e = str.length;
                }
                for (i = 0; str.charCodeAt(i) === 48; i++) ;
                for (len = str.length; str.charCodeAt(--len) === 48; ) ;
                str = str.slice(i, len + 1);
                if (str) {
                    len = str.length;
                    if (num && ERRORS && len > 15) raise(id, tooManyDigits, x.s * n);
                    e = e - i - 1;
                    if (e > MAX_EXP) {
                        x.c = x.e = null;
                    } else if (e < MIN_EXP) {
                        x.c = [ x.e = 0 ];
                    } else {
                        x.e = e;
                        x.c = [];
                        i = (e + 1) % LOG_BASE;
                        if (e < 0) i += LOG_BASE;
                        if (i < len) {
                            if (i) x.c.push(+str.slice(0, i));
                            for (len -= LOG_BASE; i < len; ) {
                                x.c.push(+str.slice(i, i += LOG_BASE));
                            }
                            str = str.slice(i);
                            i = LOG_BASE - str.length;
                        } else {
                            i -= len;
                        }
                        for (;i--; str += "0") ;
                        x.c.push(+str);
                    }
                } else {
                    x.c = [ x.e = 0 ];
                }
                id = 0;
            }
            BigNumber.another = another;
            BigNumber.ROUND_UP = 0;
            BigNumber.ROUND_DOWN = 1;
            BigNumber.ROUND_CEIL = 2;
            BigNumber.ROUND_FLOOR = 3;
            BigNumber.ROUND_HALF_UP = 4;
            BigNumber.ROUND_HALF_DOWN = 5;
            BigNumber.ROUND_HALF_EVEN = 6;
            BigNumber.ROUND_HALF_CEIL = 7;
            BigNumber.ROUND_HALF_FLOOR = 8;
            BigNumber.EUCLID = 9;
            BigNumber.config = function() {
                var v, p, i = 0, r = {}, a = arguments, o = a[0], has = o && typeof o == "object" ? function() {
                    if (o.hasOwnProperty(p)) return (v = o[p]) != null;
                } : function() {
                    if (a.length > i) return (v = a[i++]) != null;
                };
                if (has(p = "DECIMAL_PLACES") && isValidInt(v, 0, MAX, 2, p)) {
                    DECIMAL_PLACES = v | 0;
                }
                r[p] = DECIMAL_PLACES;
                if (has(p = "ROUNDING_MODE") && isValidInt(v, 0, 8, 2, p)) {
                    ROUNDING_MODE = v | 0;
                }
                r[p] = ROUNDING_MODE;
                if (has(p = "EXPONENTIAL_AT")) {
                    if (isArray(v)) {
                        if (isValidInt(v[0], -MAX, 0, 2, p) && isValidInt(v[1], 0, MAX, 2, p)) {
                            TO_EXP_NEG = v[0] | 0;
                            TO_EXP_POS = v[1] | 0;
                        }
                    } else if (isValidInt(v, -MAX, MAX, 2, p)) {
                        TO_EXP_NEG = -(TO_EXP_POS = (v < 0 ? -v : v) | 0);
                    }
                }
                r[p] = [ TO_EXP_NEG, TO_EXP_POS ];
                if (has(p = "RANGE")) {
                    if (isArray(v)) {
                        if (isValidInt(v[0], -MAX, -1, 2, p) && isValidInt(v[1], 1, MAX, 2, p)) {
                            MIN_EXP = v[0] | 0;
                            MAX_EXP = v[1] | 0;
                        }
                    } else if (isValidInt(v, -MAX, MAX, 2, p)) {
                        if (v | 0) MIN_EXP = -(MAX_EXP = (v < 0 ? -v : v) | 0); else if (ERRORS) raise(2, p + " cannot be zero", v);
                    }
                }
                r[p] = [ MIN_EXP, MAX_EXP ];
                if (has(p = "ERRORS")) {
                    if (v === !!v || v === 1 || v === 0) {
                        id = 0;
                        isValidInt = (ERRORS = !!v) ? intValidatorWithErrors : intValidatorNoErrors;
                    } else if (ERRORS) {
                        raise(2, p + notBool, v);
                    }
                }
                r[p] = ERRORS;
                if (has(p = "CRYPTO")) {
                    if (v === !!v || v === 1 || v === 0) {
                        CRYPTO = !!(v && crypto && typeof crypto == "object");
                        if (v && !CRYPTO && ERRORS) raise(2, "crypto unavailable", crypto);
                    } else if (ERRORS) {
                        raise(2, p + notBool, v);
                    }
                }
                r[p] = CRYPTO;
                if (has(p = "MODULO_MODE") && isValidInt(v, 0, 9, 2, p)) {
                    MODULO_MODE = v | 0;
                }
                r[p] = MODULO_MODE;
                if (has(p = "POW_PRECISION") && isValidInt(v, 0, MAX, 2, p)) {
                    POW_PRECISION = v | 0;
                }
                r[p] = POW_PRECISION;
                if (has(p = "FORMAT")) {
                    if (typeof v == "object") {
                        FORMAT = v;
                    } else if (ERRORS) {
                        raise(2, p + " not an object", v);
                    }
                }
                r[p] = FORMAT;
                return r;
            };
            BigNumber.max = function() {
                return maxOrMin(arguments, P.lt);
            };
            BigNumber.min = function() {
                return maxOrMin(arguments, P.gt);
            };
            BigNumber.random = function() {
                var pow2_53 = 9007199254740992;
                var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
                    return mathfloor(Math.random() * pow2_53);
                } : function() {
                    return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
                };
                return function(dp) {
                    var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
                    dp = dp == null || !isValidInt(dp, 0, MAX, 14) ? DECIMAL_PLACES : dp | 0;
                    k = mathceil(dp / LOG_BASE);
                    if (CRYPTO) {
                        if (crypto && crypto.getRandomValues) {
                            a = crypto.getRandomValues(new Uint32Array(k *= 2));
                            for (;i < k; ) {
                                v = a[i] * 131072 + (a[i + 1] >>> 11);
                                if (v >= 9e15) {
                                    b = crypto.getRandomValues(new Uint32Array(2));
                                    a[i] = b[0];
                                    a[i + 1] = b[1];
                                } else {
                                    c.push(v % 1e14);
                                    i += 2;
                                }
                            }
                            i = k / 2;
                        } else if (crypto && crypto.randomBytes) {
                            a = crypto.randomBytes(k *= 7);
                            for (;i < k; ) {
                                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                                if (v >= 9e15) {
                                    crypto.randomBytes(7).copy(a, i);
                                } else {
                                    c.push(v % 1e14);
                                    i += 7;
                                }
                            }
                            i = k / 7;
                        } else if (ERRORS) {
                            raise(14, "crypto unavailable", crypto);
                        }
                    }
                    if (!i) {
                        for (;i < k; ) {
                            v = random53bitInt();
                            if (v < 9e15) c[i++] = v % 1e14;
                        }
                    }
                    k = c[--i];
                    dp %= LOG_BASE;
                    if (k && dp) {
                        v = POWS_TEN[LOG_BASE - dp];
                        c[i] = mathfloor(k / v) * v;
                    }
                    for (;c[i] === 0; c.pop(), i--) ;
                    if (i < 0) {
                        c = [ e = 0 ];
                    } else {
                        for (e = -1; c[0] === 0; c.shift(), e -= LOG_BASE) ;
                        for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
                        if (i < LOG_BASE) e -= LOG_BASE - i;
                    }
                    rand.e = e;
                    rand.c = c;
                    return rand;
                };
            }();
            function convertBase(str, baseOut, baseIn, sign) {
                var d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                if (baseIn < 37) str = str.toLowerCase();
                if (i >= 0) {
                    k = POW_PRECISION;
                    POW_PRECISION = 0;
                    str = str.replace(".", "");
                    y = new BigNumber(baseIn);
                    x = y.pow(str.length - i);
                    POW_PRECISION = k;
                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e), 10, baseOut);
                    y.e = y.c.length;
                }
                xc = toBaseOut(str, baseIn, baseOut);
                e = k = xc.length;
                for (;xc[--k] == 0; xc.pop()) ;
                if (!xc[0]) return "0";
                if (i < 0) {
                    --e;
                } else {
                    x.c = xc;
                    x.e = e;
                    x.s = sign;
                    x = div(x, y, dp, rm, baseOut);
                    xc = x.c;
                    r = x.r;
                    e = x.e;
                }
                d = e + dp + 1;
                i = xc[d];
                k = baseOut / 2;
                r = r || d < 0 || xc[d + 1] != null;
                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
                if (d < 1 || !xc[0]) {
                    str = r ? toFixedPoint("1", -dp) : "0";
                } else {
                    xc.length = d;
                    if (r) {
                        for (--baseOut; ++xc[--d] > baseOut; ) {
                            xc[d] = 0;
                            if (!d) {
                                ++e;
                                xc.unshift(1);
                            }
                        }
                    }
                    for (k = xc.length; !xc[--k]; ) ;
                    for (i = 0, str = ""; i <= k; str += ALPHABET.charAt(xc[i++])) ;
                    str = toFixedPoint(str, e);
                }
                return str;
            }
            div = function() {
                function multiply(x, k, base) {
                    var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                    for (x = x.slice(); i--; ) {
                        xlo = x[i] % SQRT_BASE;
                        xhi = x[i] / SQRT_BASE | 0;
                        m = khi * xlo + xhi * klo;
                        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                        x[i] = temp % base;
                    }
                    if (carry) x.unshift(carry);
                    return x;
                }
                function compare(a, b, aL, bL) {
                    var i, cmp;
                    if (aL != bL) {
                        cmp = aL > bL ? 1 : -1;
                    } else {
                        for (i = cmp = 0; i < aL; i++) {
                            if (a[i] != b[i]) {
                                cmp = a[i] > b[i] ? 1 : -1;
                                break;
                            }
                        }
                    }
                    return cmp;
                }
                function subtract(a, b, aL, base) {
                    var i = 0;
                    for (;aL--; ) {
                        a[aL] -= i;
                        i = a[aL] < b[aL] ? 1 : 0;
                        a[aL] = i * base + a[aL] - b[aL];
                    }
                    for (;!a[0] && a.length > 1; a.shift()) ;
                }
                return function(x, y, dp, rm, base) {
                    var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                    if (!xc || !xc[0] || !yc || !yc[0]) {
                        return new BigNumber(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
                    }
                    q = new BigNumber(s);
                    qc = q.c = [];
                    e = x.e - y.e;
                    s = dp + e + 1;
                    if (!base) {
                        base = BASE;
                        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                        s = s / LOG_BASE | 0;
                    }
                    for (i = 0; yc[i] == (xc[i] || 0); i++) ;
                    if (yc[i] > (xc[i] || 0)) e--;
                    if (s < 0) {
                        qc.push(1);
                        more = true;
                    } else {
                        xL = xc.length;
                        yL = yc.length;
                        i = 0;
                        s += 2;
                        n = mathfloor(base / (yc[0] + 1));
                        if (n > 1) {
                            yc = multiply(yc, n, base);
                            xc = multiply(xc, n, base);
                            yL = yc.length;
                            xL = xc.length;
                        }
                        xi = yL;
                        rem = xc.slice(0, yL);
                        remL = rem.length;
                        for (;remL < yL; rem[remL++] = 0) ;
                        yz = yc.slice();
                        yz.unshift(0);
                        yc0 = yc[0];
                        if (yc[1] >= base / 2) yc0++;
                        do {
                            n = 0;
                            cmp = compare(yc, rem, yL, remL);
                            if (cmp < 0) {
                                rem0 = rem[0];
                                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                                n = mathfloor(rem0 / yc0);
                                if (n > 1) {
                                    if (n >= base) n = base - 1;
                                    prod = multiply(yc, n, base);
                                    prodL = prod.length;
                                    remL = rem.length;
                                    while (compare(prod, rem, prodL, remL) == 1) {
                                        n--;
                                        subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                        prodL = prod.length;
                                        cmp = 1;
                                    }
                                } else {
                                    if (n == 0) {
                                        cmp = n = 1;
                                    }
                                    prod = yc.slice();
                                    prodL = prod.length;
                                }
                                if (prodL < remL) prod.unshift(0);
                                subtract(rem, prod, remL, base);
                                remL = rem.length;
                                if (cmp == -1) {
                                    while (compare(yc, rem, yL, remL) < 1) {
                                        n++;
                                        subtract(rem, yL < remL ? yz : yc, remL, base);
                                        remL = rem.length;
                                    }
                                }
                            } else if (cmp === 0) {
                                n++;
                                rem = [ 0 ];
                            }
                            qc[i++] = n;
                            if (rem[0]) {
                                rem[remL++] = xc[xi] || 0;
                            } else {
                                rem = [ xc[xi] ];
                                remL = 1;
                            }
                        } while ((xi++ < xL || rem[0] != null) && s--);
                        more = rem[0] != null;
                        if (!qc[0]) qc.shift();
                    }
                    if (base == BASE) {
                        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
                        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                    } else {
                        q.e = e;
                        q.r = +more;
                    }
                    return q;
                };
            }();
            function format(n, i, rm, caller) {
                var c0, e, ne, len, str;
                rm = rm != null && isValidInt(rm, 0, 8, caller, roundingMode) ? rm | 0 : ROUNDING_MODE;
                if (!n.c) return n.toString();
                c0 = n.c[0];
                ne = n.e;
                if (i == null) {
                    str = coeffToString(n.c);
                    str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG ? toExponential(str, ne) : toFixedPoint(str, ne);
                } else {
                    n = round(new BigNumber(n), i, rm);
                    e = n.e;
                    str = coeffToString(n.c);
                    len = str.length;
                    if (caller == 19 || caller == 24 && (i <= e || e <= TO_EXP_NEG)) {
                        for (;len < i; str += "0", len++) ;
                        str = toExponential(str, e);
                    } else {
                        i -= ne;
                        str = toFixedPoint(str, e);
                        if (e + 1 > len) {
                            if (--i > 0) for (str += "."; i--; str += "0") ;
                        } else {
                            i += e - len;
                            if (i > 0) {
                                if (e + 1 == len) str += ".";
                                for (;i--; str += "0") ;
                            }
                        }
                    }
                }
                return n.s < 0 && c0 ? "-" + str : str;
            }
            function maxOrMin(args, method) {
                var m, n, i = 0;
                if (isArray(args[0])) args = args[0];
                m = new BigNumber(args[0]);
                for (;++i < args.length; ) {
                    n = new BigNumber(args[i]);
                    if (!n.s) {
                        m = n;
                        break;
                    } else if (method.call(m, n)) {
                        m = n;
                    }
                }
                return m;
            }
            function intValidatorWithErrors(n, min, max, caller, name) {
                if (n < min || n > max || n != truncate(n)) {
                    raise(caller, (name || "decimal places") + (n < min || n > max ? " out of range" : " not an integer"), n);
                }
                return true;
            }
            function normalise(n, c, e) {
                var i = 1, j = c.length;
                for (;!c[--j]; c.pop()) ;
                for (j = c[0]; j >= 10; j /= 10, i++) ;
                if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
                    n.c = n.e = null;
                } else if (e < MIN_EXP) {
                    n.c = [ n.e = 0 ];
                } else {
                    n.e = e;
                    n.c = c;
                }
                return n;
            }
            parseNumeric = function() {
                var basePrefix = /^(-?)0([xbo])/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+|^\s+|\s+$/g;
                return function(x, str, num, b) {
                    var base, s = num ? str : str.replace(whitespaceOrPlus, "");
                    if (isInfinityOrNaN.test(s)) {
                        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                    } else {
                        if (!num) {
                            s = s.replace(basePrefix, function(m, p1, p2) {
                                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                                return !b || b == base ? p1 : m;
                            });
                            if (b) {
                                base = b;
                                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                            }
                            if (str != s) return new BigNumber(s, base);
                        }
                        if (ERRORS) raise(id, "not a" + (b ? " base " + b : "") + " number", str);
                        x.s = null;
                    }
                    x.c = x.e = null;
                    id = 0;
                };
            }();
            function raise(caller, msg, val) {
                var error = new Error([ "new BigNumber", "cmp", "config", "div", "divToInt", "eq", "gt", "gte", "lt", "lte", "minus", "mod", "plus", "precision", "random", "round", "shift", "times", "toDigits", "toExponential", "toFixed", "toFormat", "toFraction", "pow", "toPrecision", "toString", "BigNumber" ][caller] + "() " + msg + ": " + val);
                error.name = "BigNumber Error";
                id = 0;
                throw error;
            }
            function round(x, sd, rm, r) {
                var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
                if (xc) {
                    out: {
                        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
                        i = sd - d;
                        if (i < 0) {
                            i += LOG_BASE;
                            j = sd;
                            n = xc[ni = 0];
                            rd = n / pows10[d - j - 1] % 10 | 0;
                        } else {
                            ni = mathceil((i + 1) / LOG_BASE);
                            if (ni >= xc.length) {
                                if (r) {
                                    for (;xc.length <= ni; xc.push(0)) ;
                                    n = rd = 0;
                                    d = 1;
                                    i %= LOG_BASE;
                                    j = i - LOG_BASE + 1;
                                } else {
                                    break out;
                                }
                            } else {
                                n = k = xc[ni];
                                for (d = 1; k >= 10; k /= 10, d++) ;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + d;
                                rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                            }
                        }
                        r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                        if (sd < 1 || !xc[0]) {
                            xc.length = 0;
                            if (r) {
                                sd -= x.e + 1;
                                xc[0] = pows10[sd % LOG_BASE];
                                x.e = -sd || 0;
                            } else {
                                xc[0] = x.e = 0;
                            }
                            return x;
                        }
                        if (i == 0) {
                            xc.length = ni;
                            k = 1;
                            ni--;
                        } else {
                            xc.length = ni + 1;
                            k = pows10[LOG_BASE - i];
                            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                        }
                        if (r) {
                            for (;;) {
                                if (ni == 0) {
                                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                                    j = xc[0] += k;
                                    for (k = 1; j >= 10; j /= 10, k++) ;
                                    if (i != k) {
                                        x.e++;
                                        if (xc[0] == BASE) xc[0] = 1;
                                    }
                                    break;
                                } else {
                                    xc[ni] += k;
                                    if (xc[ni] != BASE) break;
                                    xc[ni--] = 0;
                                    k = 1;
                                }
                            }
                        }
                        for (i = xc.length; xc[--i] === 0; xc.pop()) ;
                    }
                    if (x.e > MAX_EXP) {
                        x.c = x.e = null;
                    } else if (x.e < MIN_EXP) {
                        x.c = [ x.e = 0 ];
                    }
                }
                return x;
            }
            P.absoluteValue = P.abs = function() {
                var x = new BigNumber(this);
                if (x.s < 0) x.s = 1;
                return x;
            };
            P.ceil = function() {
                return round(new BigNumber(this), this.e + 1, 2);
            };
            P.comparedTo = P.cmp = function(y, b) {
                id = 1;
                return compare(this, new BigNumber(y, b));
            };
            P.decimalPlaces = P.dp = function() {
                var n, v, c = this.c;
                if (!c) return null;
                n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
                if (v = c[v]) for (;v % 10 == 0; v /= 10, n--) ;
                if (n < 0) n = 0;
                return n;
            };
            P.dividedBy = P.div = function(y, b) {
                id = 3;
                return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
            };
            P.dividedToIntegerBy = P.divToInt = function(y, b) {
                id = 4;
                return div(this, new BigNumber(y, b), 0, 1);
            };
            P.equals = P.eq = function(y, b) {
                id = 5;
                return compare(this, new BigNumber(y, b)) === 0;
            };
            P.floor = function() {
                return round(new BigNumber(this), this.e + 1, 3);
            };
            P.greaterThan = P.gt = function(y, b) {
                id = 6;
                return compare(this, new BigNumber(y, b)) > 0;
            };
            P.greaterThanOrEqualTo = P.gte = function(y, b) {
                id = 7;
                return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
            };
            P.isFinite = function() {
                return !!this.c;
            };
            P.isInteger = P.isInt = function() {
                return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
            };
            P.isNaN = function() {
                return !this.s;
            };
            P.isNegative = P.isNeg = function() {
                return this.s < 0;
            };
            P.isZero = function() {
                return !!this.c && this.c[0] == 0;
            };
            P.lessThan = P.lt = function(y, b) {
                id = 8;
                return compare(this, new BigNumber(y, b)) < 0;
            };
            P.lessThanOrEqualTo = P.lte = function(y, b) {
                id = 9;
                return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
            };
            P.minus = P.sub = function(y, b) {
                var i, j, t, xLTy, x = this, a = x.s;
                id = 10;
                y = new BigNumber(y, b);
                b = y.s;
                if (!a || !b) return new BigNumber(NaN);
                if (a != b) {
                    y.s = -b;
                    return x.plus(y);
                }
                var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                if (!xe || !ye) {
                    if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
                    if (!xc[0] || !yc[0]) {
                        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
                    }
                }
                xe = bitFloor(xe);
                ye = bitFloor(ye);
                xc = xc.slice();
                if (a = xe - ye) {
                    if (xLTy = a < 0) {
                        a = -a;
                        t = xc;
                    } else {
                        ye = xe;
                        t = yc;
                    }
                    t.reverse();
                    for (b = a; b--; t.push(0)) ;
                    t.reverse();
                } else {
                    j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
                    for (a = b = 0; b < j; b++) {
                        if (xc[b] != yc[b]) {
                            xLTy = xc[b] < yc[b];
                            break;
                        }
                    }
                }
                if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
                b = (j = yc.length) - (i = xc.length);
                if (b > 0) for (;b--; xc[i++] = 0) ;
                b = BASE - 1;
                for (;j > a; ) {
                    if (xc[--j] < yc[j]) {
                        for (i = j; i && !xc[--i]; xc[i] = b) ;
                        --xc[i];
                        xc[j] += BASE;
                    }
                    xc[j] -= yc[j];
                }
                for (;xc[0] == 0; xc.shift(), --ye) ;
                if (!xc[0]) {
                    y.s = ROUNDING_MODE == 3 ? -1 : 1;
                    y.c = [ y.e = 0 ];
                    return y;
                }
                return normalise(y, xc, ye);
            };
            P.modulo = P.mod = function(y, b) {
                var q, s, x = this;
                id = 11;
                y = new BigNumber(y, b);
                if (!x.c || !y.s || y.c && !y.c[0]) {
                    return new BigNumber(NaN);
                } else if (!y.c || x.c && !x.c[0]) {
                    return new BigNumber(x);
                }
                if (MODULO_MODE == 9) {
                    s = y.s;
                    y.s = 1;
                    q = div(x, y, 0, 3);
                    y.s = s;
                    q.s *= s;
                } else {
                    q = div(x, y, 0, MODULO_MODE);
                }
                return x.minus(q.times(y));
            };
            P.negated = P.neg = function() {
                var x = new BigNumber(this);
                x.s = -x.s || null;
                return x;
            };
            P.plus = P.add = function(y, b) {
                var t, x = this, a = x.s;
                id = 12;
                y = new BigNumber(y, b);
                b = y.s;
                if (!a || !b) return new BigNumber(NaN);
                if (a != b) {
                    y.s = -b;
                    return x.minus(y);
                }
                var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                if (!xe || !ye) {
                    if (!xc || !yc) return new BigNumber(a / 0);
                    if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
                }
                xe = bitFloor(xe);
                ye = bitFloor(ye);
                xc = xc.slice();
                if (a = xe - ye) {
                    if (a > 0) {
                        ye = xe;
                        t = yc;
                    } else {
                        a = -a;
                        t = xc;
                    }
                    t.reverse();
                    for (;a--; t.push(0)) ;
                    t.reverse();
                }
                a = xc.length;
                b = yc.length;
                if (a - b < 0) t = yc, yc = xc, xc = t, b = a;
                for (a = 0; b; ) {
                    a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                    xc[b] %= BASE;
                }
                if (a) {
                    xc.unshift(a);
                    ++ye;
                }
                return normalise(y, xc, ye);
            };
            P.precision = P.sd = function(z) {
                var n, v, x = this, c = x.c;
                if (z != null && z !== !!z && z !== 1 && z !== 0) {
                    if (ERRORS) raise(13, "argument" + notBool, z);
                    if (z != !!z) z = null;
                }
                if (!c) return null;
                v = c.length - 1;
                n = v * LOG_BASE + 1;
                if (v = c[v]) {
                    for (;v % 10 == 0; v /= 10, n--) ;
                    for (v = c[0]; v >= 10; v /= 10, n++) ;
                }
                if (z && x.e + 1 > n) n = x.e + 1;
                return n;
            };
            P.round = function(dp, rm) {
                var n = new BigNumber(this);
                if (dp == null || isValidInt(dp, 0, MAX, 15)) {
                    round(n, ~~dp + this.e + 1, rm == null || !isValidInt(rm, 0, 8, 15, roundingMode) ? ROUNDING_MODE : rm | 0);
                }
                return n;
            };
            P.shift = function(k) {
                var n = this;
                return isValidInt(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, "argument") ? n.times("1e" + truncate(k)) : new BigNumber(n.c && n.c[0] && (k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER) ? n.s * (k < 0 ? 0 : 1 / 0) : n);
            };
            P.squareRoot = P.sqrt = function() {
                var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber("0.5");
                if (s !== 1 || !c || !c[0]) {
                    return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                }
                s = Math.sqrt(+x);
                if (s == 0 || s == 1 / 0) {
                    n = coeffToString(c);
                    if ((n.length + e) % 2 == 0) n += "0";
                    s = Math.sqrt(n);
                    e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
                    if (s == 1 / 0) {
                        n = "1e" + e;
                    } else {
                        n = s.toExponential();
                        n = n.slice(0, n.indexOf("e") + 1) + e;
                    }
                    r = new BigNumber(n);
                } else {
                    r = new BigNumber(s + "");
                }
                if (r.c[0]) {
                    e = r.e;
                    s = e + dp;
                    if (s < 3) s = 0;
                    for (;;) {
                        t = r;
                        r = half.times(t.plus(div(x, t, dp, 1)));
                        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                            if (r.e < e) --s;
                            n = n.slice(s - 3, s + 1);
                            if (n == "9999" || !rep && n == "4999") {
                                if (!rep) {
                                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                                    if (t.times(t).eq(x)) {
                                        r = t;
                                        break;
                                    }
                                }
                                dp += 4;
                                s += 4;
                                rep = 1;
                            } else {
                                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                                    m = !r.times(r).eq(x);
                                }
                                break;
                            }
                        }
                    }
                }
                return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
            };
            P.times = P.mul = function(y, b) {
                var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (id = 17, 
                y = new BigNumber(y, b)).c;
                if (!xc || !yc || !xc[0] || !yc[0]) {
                    if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                        y.c = y.e = y.s = null;
                    } else {
                        y.s *= x.s;
                        if (!xc || !yc) {
                            y.c = y.e = null;
                        } else {
                            y.c = [ 0 ];
                            y.e = 0;
                        }
                    }
                    return y;
                }
                e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                y.s *= x.s;
                xcL = xc.length;
                ycL = yc.length;
                if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
                for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
                base = BASE;
                sqrtBase = SQRT_BASE;
                for (i = ycL; --i >= 0; ) {
                    c = 0;
                    ylo = yc[i] % sqrtBase;
                    yhi = yc[i] / sqrtBase | 0;
                    for (k = xcL, j = i + k; j > i; ) {
                        xlo = xc[--k] % sqrtBase;
                        xhi = xc[k] / sqrtBase | 0;
                        m = yhi * xlo + xhi * ylo;
                        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                        zc[j--] = xlo % base;
                    }
                    zc[j] = c;
                }
                if (c) {
                    ++e;
                } else {
                    zc.shift();
                }
                return normalise(y, zc, e);
            };
            P.toDigits = function(sd, rm) {
                var n = new BigNumber(this);
                sd = sd == null || !isValidInt(sd, 1, MAX, 18, "precision") ? null : sd | 0;
                rm = rm == null || !isValidInt(rm, 0, 8, 18, roundingMode) ? ROUNDING_MODE : rm | 0;
                return sd ? round(n, sd, rm) : n;
            };
            P.toExponential = function(dp, rm) {
                return format(this, dp != null && isValidInt(dp, 0, MAX, 19) ? ~~dp + 1 : null, rm, 19);
            };
            P.toFixed = function(dp, rm) {
                return format(this, dp != null && isValidInt(dp, 0, MAX, 20) ? ~~dp + this.e + 1 : null, rm, 20);
            };
            P.toFormat = function(dp, rm) {
                var str = format(this, dp != null && isValidInt(dp, 0, MAX, 21) ? ~~dp + this.e + 1 : null, rm, 21);
                if (this.c) {
                    var i, arr = str.split("."), g1 = +FORMAT.groupSize, g2 = +FORMAT.secondaryGroupSize, groupSeparator = FORMAT.groupSeparator, intPart = arr[0], fractionPart = arr[1], isNeg = this.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                    if (g2) i = g1, g1 = g2, g2 = i, len -= i;
                    if (g1 > 0 && len > 0) {
                        i = len % g1 || g1;
                        intPart = intDigits.substr(0, i);
                        for (;i < len; i += g1) {
                            intPart += groupSeparator + intDigits.substr(i, g1);
                        }
                        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                        if (isNeg) intPart = "-" + intPart;
                    }
                    str = fractionPart ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + FORMAT.fractionGroupSeparator) : fractionPart) : intPart;
                }
                return str;
            };
            P.toFraction = function(md) {
                var arr, d0, d2, e, exp, n, n0, q, s, k = ERRORS, x = this, xc = x.c, d = new BigNumber(ONE), n1 = d0 = new BigNumber(ONE), d1 = n0 = new BigNumber(ONE);
                if (md != null) {
                    ERRORS = false;
                    n = new BigNumber(md);
                    ERRORS = k;
                    if (!(k = n.isInt()) || n.lt(ONE)) {
                        if (ERRORS) {
                            raise(22, "max denominator " + (k ? "out of range" : "not an integer"), md);
                        }
                        md = !k && n.c && round(n, n.e + 1, 1).gte(ONE) ? n : null;
                    }
                }
                if (!xc) return x.toString();
                s = coeffToString(xc);
                e = d.e = s.length - x.e - 1;
                d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                md = !md || n.cmp(d) > 0 ? e > 0 ? d : n1 : n;
                exp = MAX_EXP;
                MAX_EXP = 1 / 0;
                n = new BigNumber(s);
                n0.c[0] = 0;
                for (;;) {
                    q = div(n, d, 0, 1);
                    d2 = d0.plus(q.times(d1));
                    if (d2.cmp(md) == 1) break;
                    d0 = d1;
                    d1 = d2;
                    n1 = n0.plus(q.times(d2 = n1));
                    n0 = d2;
                    d = n.minus(q.times(d2 = d));
                    n = d2;
                }
                d2 = div(md.minus(d0), d1, 0, 1);
                n0 = n0.plus(d2.times(n1));
                d0 = d0.plus(d2.times(d1));
                n0.s = n1.s = x.s;
                e *= 2;
                arr = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().cmp(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [ n1.toString(), d1.toString() ] : [ n0.toString(), d0.toString() ];
                MAX_EXP = exp;
                return arr;
            };
            P.toNumber = function() {
                var x = this;
                return +x || (x.s ? x.s * 0 : NaN);
            };
            P.toPower = P.pow = function(n) {
                var k, y, i = mathfloor(n < 0 ? -n : +n), x = this;
                if (!isValidInt(n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, "exponent") && (!isFinite(n) || i > MAX_SAFE_INTEGER && (n /= 0) || parseFloat(n) != n && !(n = NaN))) {
                    return new BigNumber(Math.pow(+x, n));
                }
                k = POW_PRECISION ? mathceil(POW_PRECISION / LOG_BASE + 2) : 0;
                y = new BigNumber(ONE);
                for (;;) {
                    if (i % 2) {
                        y = y.times(x);
                        if (!y.c) break;
                        if (k && y.c.length > k) y.c.length = k;
                    }
                    i = mathfloor(i / 2);
                    if (!i) break;
                    x = x.times(x);
                    if (k && x.c && x.c.length > k) x.c.length = k;
                }
                if (n < 0) y = ONE.div(y);
                return k ? round(y, POW_PRECISION, ROUNDING_MODE) : y;
            };
            P.toPrecision = function(sd, rm) {
                return format(this, sd != null && isValidInt(sd, 1, MAX, 24, "precision") ? sd | 0 : null, rm, 24);
            };
            P.toString = function(b) {
                var str, n = this, s = n.s, e = n.e;
                if (e === null) {
                    if (s) {
                        str = "Infinity";
                        if (s < 0) str = "-" + str;
                    } else {
                        str = "NaN";
                    }
                } else {
                    str = coeffToString(n.c);
                    if (b == null || !isValidInt(b, 2, 64, 25, "base")) {
                        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e);
                    } else {
                        str = convertBase(toFixedPoint(str, e), b | 0, 10, s);
                    }
                    if (s < 0 && n.c[0]) str = "-" + str;
                }
                return str;
            };
            P.truncated = P.trunc = function() {
                return round(new BigNumber(this), this.e + 1, 1);
            };
            P.valueOf = P.toJSON = function() {
                return this.toString();
            };
            if (configObj != null) BigNumber.config(configObj);
            return BigNumber;
        }
        function bitFloor(n) {
            var i = n | 0;
            return n > 0 || n === i ? i : i - 1;
        }
        function coeffToString(a) {
            var s, z, i = 1, j = a.length, r = a[0] + "";
            for (;i < j; ) {
                s = a[i++] + "";
                z = LOG_BASE - s.length;
                for (;z--; s = "0" + s) ;
                r += s;
            }
            for (j = r.length; r.charCodeAt(--j) === 48; ) ;
            return r.slice(0, j + 1 || 1);
        }
        function compare(x, y) {
            var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
            if (!i || !j) return null;
            a = xc && !xc[0];
            b = yc && !yc[0];
            if (a || b) return a ? b ? 0 : -j : i;
            if (i != j) return i;
            a = i < 0;
            b = k == l;
            if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
            if (!b) return k > l ^ a ? 1 : -1;
            j = (k = xc.length) < (l = yc.length) ? k : l;
            for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
            return k == l ? 0 : k > l ^ a ? 1 : -1;
        }
        function intValidatorNoErrors(n, min, max) {
            return (n = truncate(n)) >= min && n <= max;
        }
        function isArray(obj) {
            return Object.prototype.toString.call(obj) == "[object Array]";
        }
        function toBaseOut(str, baseIn, baseOut) {
            var j, arr = [ 0 ], arrL, i = 0, len = str.length;
            for (;i < len; ) {
                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
                arr[j = 0] += ALPHABET.indexOf(str.charAt(i++));
                for (;j < arr.length; j++) {
                    if (arr[j] > baseOut - 1) {
                        if (arr[j + 1] == null) arr[j + 1] = 0;
                        arr[j + 1] += arr[j] / baseOut | 0;
                        arr[j] %= baseOut;
                    }
                }
            }
            return arr.reverse();
        }
        function toExponential(str, e) {
            return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
        }
        function toFixedPoint(str, e) {
            var len, z;
            if (e < 0) {
                for (z = "0."; ++e; z += "0") ;
                str = z + str;
            } else {
                len = str.length;
                if (++e > len) {
                    for (z = "0", e -= len; --e; z += "0") ;
                    str += z;
                } else if (e < len) {
                    str = str.slice(0, e) + "." + str.slice(e);
                }
            }
            return str;
        }
        function truncate(n) {
            n = parseFloat(n);
            return n < 0 ? mathceil(n) : mathfloor(n);
        }
        BigNumber = another();
        if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return BigNumber;
            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
    })(this);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = merge;
    function merge() {
        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaults = arguments[1];
        for (var key in defaults) {
            if (typeof obj[key] === "undefined") {
                obj[key] = defaults[key];
            }
        }
        return obj;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    var base = exports;
    base.Reporter = __webpack_require__(368).Reporter;
    base.DecoderBuffer = __webpack_require__(132).DecoderBuffer;
    base.EncoderBuffer = __webpack_require__(132).EncoderBuffer;
    base.Node = __webpack_require__(367);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        module.exports = function xor(a, b) {
            var length = Math.min(a.length, b.length);
            var buffer = new Buffer(length);
            for (var i = 0; i < length; ++i) {
                buffer[i] = a[i] ^ b[i];
            }
            return buffer;
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        function isArray(arg) {
            if (Array.isArray) {
                return Array.isArray(arg);
            }
            return objectToString(arg) === "[object Array]";
        }
        exports.isArray = isArray;
        function isBoolean(arg) {
            return typeof arg === "boolean";
        }
        exports.isBoolean = isBoolean;
        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;
        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
            return typeof arg === "number";
        }
        exports.isNumber = isNumber;
        function isString(arg) {
            return typeof arg === "string";
        }
        exports.isString = isString;
        function isSymbol(arg) {
            return typeof arg === "symbol";
        }
        exports.isSymbol = isSymbol;
        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;
        function isRegExp(re) {
            return objectToString(re) === "[object RegExp]";
        }
        exports.isRegExp = isRegExp;
        function isObject(arg) {
            return typeof arg === "object" && arg !== null;
        }
        exports.isObject = isObject;
        function isDate(d) {
            return objectToString(d) === "[object Date]";
        }
        exports.isDate = isDate;
        function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error;
        }
        exports.isError = isError;
        function isFunction(arg) {
            return typeof arg === "function";
        }
        exports.isFunction = isFunction;
        function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
        }
        exports.isPrimitive = isPrimitive;
        exports.isBuffer = Buffer.isBuffer;
        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    module.exports = Stream;
    var EE = __webpack_require__(82).EventEmitter;
    var inherits = __webpack_require__(3);
    inherits(Stream, EE);
    Stream.Readable = __webpack_require__(81);
    Stream.Writable = __webpack_require__(404);
    Stream.Duplex = __webpack_require__(403);
    Stream.Transform = __webpack_require__(402);
    Stream.PassThrough = __webpack_require__(401);
    Stream.Stream = Stream;
    function Stream() {
        EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
            if (dest.writable) {
                if (false === dest.write(chunk) && source.pause) {
                    source.pause();
                }
            }
        }
        source.on("data", ondata);
        function ondrain() {
            if (source.readable && source.resume) {
                source.resume();
            }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
            if (didOnEnd) return;
            didOnEnd = true;
            dest.end();
        }
        function onclose() {
            if (didOnEnd) return;
            didOnEnd = true;
            if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
                throw er;
            }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var inherits = __webpack_require__(3);
    var MD5 = __webpack_require__(83);
    var RIPEMD160 = __webpack_require__(78);
    var sha = __webpack_require__(77);
    var Base = __webpack_require__(23);
    function Hash(hash) {
        Base.call(this, "digest");
        this._hash = hash;
    }
    inherits(Hash, Base);
    Hash.prototype._update = function(data) {
        this._hash.update(data);
    };
    Hash.prototype._final = function() {
        return this._hash.digest();
    };
    module.exports = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5") return new MD5();
        if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
        return new Hash(sha(alg));
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var assert = __webpack_require__(15);
    function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending) this.pending = msg; else this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
            msg = this.pending;
            var r = msg.length % this._delta8;
            this.pending = msg.slice(msg.length - r, msg.length);
            if (this.pending.length === 0) this.pending = null;
            msg = utils.join32(msg, 0, msg.length - r, this.endian);
            for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
        }
        return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++) res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
            for (var t = 8; t < this.padLength; t++) res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = len >>> 24 & 255;
            res[i++] = len >>> 16 & 255;
            res[i++] = len >>> 8 & 255;
            res[i++] = len & 255;
        } else {
            res[i++] = len & 255;
            res[i++] = len >>> 8 & 255;
            res[i++] = len >>> 16 & 255;
            res[i++] = len >>> 24 & 255;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            for (t = 8; t < this.padLength; t++) res[i++] = 0;
        }
        return res;
    };
}, function(module, exports) {
    module.exports = function(module) {
        if (!module.webpackPolyfill) {
            module.deprecate = function() {};
            module.paths = [];
            if (!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
                enumerable: true,
                get: function() {
                    return module.l;
                }
            });
            Object.defineProperty(module, "id", {
                enumerable: true,
                get: function() {
                    return module.i;
                }
            });
            module.webpackPolyfill = 1;
        }
        return module;
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    var react = __webpack_require__(2);
    var prop_types = __webpack_require__(0);
    var prop_types_default = __webpack_require__.n(prop_types);
    var subscriptionShape = prop_types_default.a.shape({
        trySubscribe: prop_types_default.a.func.isRequired,
        tryUnsubscribe: prop_types_default.a.func.isRequired,
        notifyNestedSubs: prop_types_default.a.func.isRequired,
        isSubscribed: prop_types_default.a.func.isRequired
    });
    var storeShape = prop_types_default.a.shape({
        subscribe: prop_types_default.a.func.isRequired,
        dispatch: prop_types_default.a.func.isRequired,
        getState: prop_types_default.a.func.isRequired
    });
    function warning(message) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(message);
        }
        try {
            throw new Error(message);
        } catch (e) {}
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var didWarnAboutReceivingStore = false;
    function warnAboutReceivingStore() {
        if (didWarnAboutReceivingStore) {
            return;
        }
        didWarnAboutReceivingStore = true;
        warning("<Provider> does not support changing `store` on the fly. " + "It is most likely that you see this error because you updated to " + "Redux 2.x and React Redux 2.x which no longer hot reload reducers " + "automatically. See https://github.com/reactjs/react-redux/releases/" + "tag/v2.0.0 for the migration instructions.");
    }
    function createProvider() {
        var _Provider$childContex;
        var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "store";
        var subKey = arguments[1];
        var subscriptionKey = subKey || storeKey + "Subscription";
        var Provider = function(_Component) {
            _inherits(Provider, _Component);
            Provider.prototype.getChildContext = function getChildContext() {
                var _ref;
                return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, 
                _ref;
            };
            function Provider(props, context) {
                _classCallCheck(this, Provider);
                var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
                _this[storeKey] = props.store;
                return _this;
            }
            Provider.prototype.render = function render() {
                return react["Children"].only(this.props.children);
            };
            return Provider;
        }(react["Component"]);
        if (false) {}
        Provider.propTypes = {
            store: storeShape.isRequired,
            children: prop_types_default.a.element.isRequired
        };
        Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = storeShape.isRequired, 
        _Provider$childContex[subscriptionKey] = subscriptionShape, _Provider$childContex);
        return Provider;
    }
    var components_Provider = createProvider();
    var hoist_non_react_statics = __webpack_require__(65);
    var hoist_non_react_statics_default = __webpack_require__.n(hoist_non_react_statics);
    var browser = __webpack_require__(8);
    var browser_default = __webpack_require__.n(browser);
    function Subscription_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var CLEARED = null;
    var nullListeners = {
        notify: function notify() {}
    };
    function createListenerCollection() {
        var current = [];
        var next = [];
        return {
            clear: function clear() {
                next = CLEARED;
                current = CLEARED;
            },
            notify: function notify() {
                var listeners = current = next;
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i]();
                }
            },
            get: function get() {
                return next;
            },
            subscribe: function subscribe(listener) {
                var isSubscribed = true;
                if (next === current) next = current.slice();
                next.push(listener);
                return function unsubscribe() {
                    if (!isSubscribed || current === CLEARED) return;
                    isSubscribed = false;
                    if (next === current) next = current.slice();
                    next.splice(next.indexOf(listener), 1);
                };
            }
        };
    }
    var Subscription = function() {
        function Subscription(store, parentSub, onStateChange) {
            Subscription_classCallCheck(this, Subscription);
            this.store = store;
            this.parentSub = parentSub;
            this.onStateChange = onStateChange;
            this.unsubscribe = null;
            this.listeners = nullListeners;
        }
        Subscription.prototype.addNestedSub = function addNestedSub(listener) {
            this.trySubscribe();
            return this.listeners.subscribe(listener);
        };
        Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
            this.listeners.notify();
        };
        Subscription.prototype.isSubscribed = function isSubscribed() {
            return Boolean(this.unsubscribe);
        };
        Subscription.prototype.trySubscribe = function trySubscribe() {
            if (!this.unsubscribe) {
                this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);
                this.listeners = createListenerCollection();
            }
        };
        Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
            if (this.unsubscribe) {
                this.unsubscribe();
                this.unsubscribe = null;
                this.listeners.clear();
                this.listeners = nullListeners;
            }
        };
        return Subscription;
    }();
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function connectAdvanced_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function connectAdvanced_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function connectAdvanced_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function _objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    var hotReloadingVersion = 0;
    var dummyState = {};
    function noop() {}
    function makeSelectorStateful(sourceSelector, store) {
        var selector = {
            run: function runComponentSelector(props) {
                try {
                    var nextProps = sourceSelector(store.getState(), props);
                    if (nextProps !== selector.props || selector.error) {
                        selector.shouldComponentUpdate = true;
                        selector.props = nextProps;
                        selector.error = null;
                    }
                } catch (error) {
                    selector.shouldComponentUpdate = true;
                    selector.error = error;
                }
            }
        };
        return selector;
    }
    function connectAdvanced(selectorFactory) {
        var _contextTypes, _childContextTypes;
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$getDisplayName = _ref.getDisplayName, getDisplayName = _ref$getDisplayName === undefined ? function(name) {
            return "ConnectAdvanced(" + name + ")";
        } : _ref$getDisplayName, _ref$methodName = _ref.methodName, methodName = _ref$methodName === undefined ? "connectAdvanced" : _ref$methodName, _ref$renderCountProp = _ref.renderCountProp, renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp, _ref$shouldHandleStat = _ref.shouldHandleStateChanges, shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat, _ref$storeKey = _ref.storeKey, storeKey = _ref$storeKey === undefined ? "store" : _ref$storeKey, _ref$withRef = _ref.withRef, withRef = _ref$withRef === undefined ? false : _ref$withRef, connectOptions = _objectWithoutProperties(_ref, [ "getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef" ]);
        var subscriptionKey = storeKey + "Subscription";
        var version = hotReloadingVersion++;
        var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = storeShape, _contextTypes[subscriptionKey] = subscriptionShape, 
        _contextTypes);
        var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = subscriptionShape, 
        _childContextTypes);
        return function wrapWithConnect(WrappedComponent) {
            browser_default()(typeof WrappedComponent == "function", "You must pass a component to the function returned by " + (methodName + ". Instead received " + JSON.stringify(WrappedComponent)));
            var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
            var displayName = getDisplayName(wrappedComponentName);
            var selectorFactoryOptions = _extends({}, connectOptions, {
                getDisplayName,
                methodName,
                renderCountProp,
                shouldHandleStateChanges,
                storeKey,
                withRef,
                displayName,
                wrappedComponentName,
                WrappedComponent
            });
            var Connect = function(_Component) {
                connectAdvanced_inherits(Connect, _Component);
                function Connect(props, context) {
                    connectAdvanced_classCallCheck(this, Connect);
                    var _this = connectAdvanced_possibleConstructorReturn(this, _Component.call(this, props, context));
                    _this.version = version;
                    _this.state = {};
                    _this.renderCount = 0;
                    _this.store = props[storeKey] || context[storeKey];
                    _this.propsMode = Boolean(props[storeKey]);
                    _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);
                    browser_default()(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));
                    _this.initSelector();
                    _this.initSubscription();
                    return _this;
                }
                Connect.prototype.getChildContext = function getChildContext() {
                    var _ref2;
                    var subscription = this.propsMode ? null : this.subscription;
                    return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], 
                    _ref2;
                };
                Connect.prototype.componentDidMount = function componentDidMount() {
                    if (!shouldHandleStateChanges) return;
                    this.subscription.trySubscribe();
                    this.selector.run(this.props);
                    if (this.selector.shouldComponentUpdate) this.forceUpdate();
                };
                Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
                    this.selector.run(nextProps);
                };
                Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
                    return this.selector.shouldComponentUpdate;
                };
                Connect.prototype.componentWillUnmount = function componentWillUnmount() {
                    if (this.subscription) this.subscription.tryUnsubscribe();
                    this.subscription = null;
                    this.notifyNestedSubs = noop;
                    this.store = null;
                    this.selector.run = noop;
                    this.selector.shouldComponentUpdate = false;
                };
                Connect.prototype.getWrappedInstance = function getWrappedInstance() {
                    browser_default()(withRef, "To access the wrapped instance, you need to specify " + ("{ withRef: true } in the options argument of the " + methodName + "() call."));
                    return this.wrappedInstance;
                };
                Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
                    this.wrappedInstance = ref;
                };
                Connect.prototype.initSelector = function initSelector() {
                    var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
                    this.selector = makeSelectorStateful(sourceSelector, this.store);
                    this.selector.run(this.props);
                };
                Connect.prototype.initSubscription = function initSubscription() {
                    if (!shouldHandleStateChanges) return;
                    var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
                    this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this));
                    this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
                };
                Connect.prototype.onStateChange = function onStateChange() {
                    this.selector.run(this.props);
                    if (!this.selector.shouldComponentUpdate) {
                        this.notifyNestedSubs();
                    } else {
                        this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
                        this.setState(dummyState);
                    }
                };
                Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
                    this.componentDidUpdate = undefined;
                    this.notifyNestedSubs();
                };
                Connect.prototype.isSubscribed = function isSubscribed() {
                    return Boolean(this.subscription) && this.subscription.isSubscribed();
                };
                Connect.prototype.addExtraProps = function addExtraProps(props) {
                    if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
                    var withExtras = _extends({}, props);
                    if (withRef) withExtras.ref = this.setWrappedInstance;
                    if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
                    if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
                    return withExtras;
                };
                Connect.prototype.render = function render() {
                    var selector = this.selector;
                    selector.shouldComponentUpdate = false;
                    if (selector.error) {
                        throw selector.error;
                    } else {
                        return Object(react["createElement"])(WrappedComponent, this.addExtraProps(selector.props));
                    }
                };
                return Connect;
            }(react["Component"]);
            Connect.WrappedComponent = WrappedComponent;
            Connect.displayName = displayName;
            Connect.childContextTypes = childContextTypes;
            Connect.contextTypes = contextTypes;
            Connect.propTypes = contextTypes;
            if (false) {}
            return hoist_non_react_statics_default()(Connect, WrappedComponent);
        };
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    function is(x, y) {
        if (x === y) {
            return x !== 0 || y !== 0 || 1 / x === 1 / y;
        } else {
            return x !== x && y !== y;
        }
    }
    function shallowEqual(objA, objB) {
        if (is(objA, objB)) return true;
        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (var i = 0; i < keysA.length; i++) {
            if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
                return false;
            }
        }
        return true;
    }
    var redux = __webpack_require__(24);
    var _freeGlobal = __webpack_require__(481);
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = _freeGlobal["a"] || freeSelf || Function("return this")();
    var _root = root;
    var Symbol = _root.Symbol;
    var _Symbol = Symbol;
    var objectProto = Object.prototype;
    var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
    function getRawTag(value) {
        var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
            value[symToStringTag] = undefined;
            var unmasked = true;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        if (unmasked) {
            if (isOwn) {
                value[symToStringTag] = tag;
            } else {
                delete value[symToStringTag];
            }
        }
        return result;
    }
    var _getRawTag = getRawTag;
    var _objectToString_objectProto = Object.prototype;
    var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
    function objectToString(value) {
        return _objectToString_nativeObjectToString.call(value);
    }
    var _objectToString = objectToString;
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }
        return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
    }
    var _baseGetTag = baseGetTag;
    function overArg(func, transform) {
        return function(arg) {
            return func(transform(arg));
        };
    }
    var _overArg = overArg;
    var getPrototype = _overArg(Object.getPrototypeOf, Object);
    var _getPrototype = getPrototype;
    function isObjectLike(value) {
        return value != null && typeof value == "object";
    }
    var lodash_es_isObjectLike = isObjectLike;
    var objectTag = "[object Object]";
    var funcProto = Function.prototype, isPlainObject_objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
        if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {
            return false;
        }
        var proto = _getPrototype(value);
        if (proto === null) {
            return true;
        }
        var Ctor = isPlainObject_hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var lodash_es_isPlainObject = isPlainObject;
    function verifyPlainObject(value, displayName, methodName) {
        if (!lodash_es_isPlainObject(value)) {
            warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
        }
    }
    function wrapMapToPropsConstant(getConstant) {
        return function initConstantSelector(dispatch, options) {
            var constant = getConstant(dispatch, options);
            function constantSelector() {
                return constant;
            }
            constantSelector.dependsOnOwnProps = false;
            return constantSelector;
        };
    }
    function getDependsOnOwnProps(mapToProps) {
        return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
    }
    function wrapMapToPropsFunc(mapToProps, methodName) {
        return function initProxySelector(dispatch, _ref) {
            var displayName = _ref.displayName;
            var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
                return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
            };
            proxy.dependsOnOwnProps = true;
            proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
                proxy.mapToProps = mapToProps;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
                var props = proxy(stateOrDispatch, ownProps);
                if (typeof props === "function") {
                    proxy.mapToProps = props;
                    proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                    props = proxy(stateOrDispatch, ownProps);
                }
                if (false) {}
                return props;
            };
            return proxy;
        };
    }
    function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
        return typeof mapDispatchToProps === "function" ? wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : undefined;
    }
    function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
        return !mapDispatchToProps ? wrapMapToPropsConstant(function(dispatch) {
            return {
                dispatch
            };
        }) : undefined;
    }
    function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
        return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(function(dispatch) {
            return Object(redux["bindActionCreators"])(mapDispatchToProps, dispatch);
        }) : undefined;
    }
    var connect_mapDispatchToProps = [ whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject ];
    function whenMapStateToPropsIsFunction(mapStateToProps) {
        return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : undefined;
    }
    function whenMapStateToPropsIsMissing(mapStateToProps) {
        return !mapStateToProps ? wrapMapToPropsConstant(function() {
            return {};
        }) : undefined;
    }
    var connect_mapStateToProps = [ whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing ];
    var mergeProps_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function defaultMergeProps(stateProps, dispatchProps, ownProps) {
        return mergeProps_extends({}, ownProps, stateProps, dispatchProps);
    }
    function wrapMergePropsFunc(mergeProps) {
        return function initMergePropsProxy(dispatch, _ref) {
            var displayName = _ref.displayName, pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
            var hasRunOnce = false;
            var mergedProps = void 0;
            return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
                var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                if (hasRunOnce) {
                    if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
                } else {
                    hasRunOnce = true;
                    mergedProps = nextMergedProps;
                    if (false) {}
                }
                return mergedProps;
            };
        };
    }
    function whenMergePropsIsFunction(mergeProps) {
        return typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : undefined;
    }
    function whenMergePropsIsOmitted(mergeProps) {
        return !mergeProps ? function() {
            return defaultMergeProps;
        } : undefined;
    }
    var connect_mergeProps = [ whenMergePropsIsFunction, whenMergePropsIsOmitted ];
    function verify(selector, methodName, displayName) {
        if (!selector) {
            throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
        } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
            if (!selector.hasOwnProperty("dependsOnOwnProps")) {
                warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
            }
        }
    }
    function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
        verify(mapStateToProps, "mapStateToProps", displayName);
        verify(mapDispatchToProps, "mapDispatchToProps", displayName);
        verify(mergeProps, "mergeProps", displayName);
    }
    function selectorFactory_objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
        return function impureFinalPropsSelector(state, ownProps) {
            return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
        };
    }
    function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
        var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
        var hasRunAtLeastOnce = false;
        var state = void 0;
        var ownProps = void 0;
        var stateProps = void 0;
        var dispatchProps = void 0;
        var mergedProps = void 0;
        function handleFirstCall(firstState, firstOwnProps) {
            state = firstState;
            ownProps = firstOwnProps;
            stateProps = mapStateToProps(state, ownProps);
            dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            hasRunAtLeastOnce = true;
            return mergedProps;
        }
        function handleNewPropsAndNewState() {
            stateProps = mapStateToProps(state, ownProps);
            if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
        }
        function handleNewProps() {
            if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
            if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
        }
        function handleNewState() {
            var nextStateProps = mapStateToProps(state, ownProps);
            var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
            stateProps = nextStateProps;
            if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
        }
        function handleSubsequentCalls(nextState, nextOwnProps) {
            var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
            var stateChanged = !areStatesEqual(nextState, state);
            state = nextState;
            ownProps = nextOwnProps;
            if (propsChanged && stateChanged) return handleNewPropsAndNewState();
            if (propsChanged) return handleNewProps();
            if (stateChanged) return handleNewState();
            return mergedProps;
        }
        return function pureFinalPropsSelector(nextState, nextOwnProps) {
            return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
        };
    }
    function finalPropsSelectorFactory(dispatch, _ref2) {
        var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = selectorFactory_objectWithoutProperties(_ref2, [ "initMapStateToProps", "initMapDispatchToProps", "initMergeProps" ]);
        var mapStateToProps = initMapStateToProps(dispatch, options);
        var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
        var mergeProps = initMergeProps(dispatch, options);
        if (false) {}
        var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
        return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
    }
    var connect_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function connect_objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    function match(arg, factories, name) {
        for (var i = factories.length - 1; i >= 0; i--) {
            var result = factories[i](arg);
            if (result) return result;
        }
        return function(dispatch, options) {
            throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
        };
    }
    function strictEqual(a, b) {
        return a === b;
    }
    function createConnect() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === undefined ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? connect_mapStateToProps : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? connect_mapDispatchToProps : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === undefined ? connect_mergeProps : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === undefined ? finalPropsSelectorFactory : _ref$selectorFactory;
        return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
            var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, _ref2$pure = _ref2.pure, pure = _ref2$pure === undefined ? true : _ref2$pure, _ref2$areStatesEqual = _ref2.areStatesEqual, areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual, _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual, areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? shallowEqual : _ref2$areOwnPropsEqua, _ref2$areStatePropsEq = _ref2.areStatePropsEqual, areStatePropsEqual = _ref2$areStatePropsEq === undefined ? shallowEqual : _ref2$areStatePropsEq, _ref2$areMergedPropsE = _ref2.areMergedPropsEqual, areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? shallowEqual : _ref2$areMergedPropsE, extraOptions = connect_objectWithoutProperties(_ref2, [ "pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual" ]);
            var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
            var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, "mapDispatchToProps");
            var initMergeProps = match(mergeProps, mergePropsFactories, "mergeProps");
            return connectHOC(selectorFactory, connect_extends({
                methodName: "connect",
                getDisplayName: function getDisplayName(name) {
                    return "Connect(" + name + ")";
                },
                shouldHandleStateChanges: Boolean(mapStateToProps),
                initMapStateToProps,
                initMapDispatchToProps,
                initMergeProps,
                pure,
                areStatesEqual,
                areOwnPropsEqual,
                areStatePropsEqual,
                areMergedPropsEqual
            }, extraOptions));
        };
    }
    var connect_connect = createConnect();
    __webpack_require__.d(__webpack_exports__, "Provider", function() {
        return components_Provider;
    });
    __webpack_require__.d(__webpack_exports__, "createProvider", function() {
        return createProvider;
    });
    __webpack_require__.d(__webpack_exports__, "connectAdvanced", function() {
        return connectAdvanced;
    });
    __webpack_require__.d(__webpack_exports__, "connect", function() {
        return connect_connect;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
            var source = sources.shift();
            if (!source) {
                continue;
            }
            if (typeof source !== "object") {
                throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
                if (_has(source, p)) {
                    obj[p] = source[p];
                }
            }
        }
        return obj;
    };
    exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
            return buf;
        }
        if (buf.subarray) {
            return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
    };
    var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                return;
            }
            for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
            }
        },
        flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
                len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
                chunk = chunks[i];
                result.set(chunk, pos);
                pos += chunk.length;
            }
            return result;
        }
    };
    var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
            }
        },
        flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
        }
    };
    exports.setTyped = function(on) {
        if (on) {
            exports.Buf8 = Uint8Array;
            exports.Buf16 = Uint16Array;
            exports.Buf32 = Int32Array;
            exports.assign(exports, fnTyped);
        } else {
            exports.Buf8 = Array;
            exports.Buf16 = Array;
            exports.Buf32 = Array;
            exports.assign(exports, fnUntyped);
        }
    };
    exports.setTyped(TYPED_OK);
}, function(module, exports, __webpack_require__) {
    var Method = __webpack_require__(25);
    var eth = function() {
        var newFilterCall = function(args) {
            var type = args[0];
            switch (type) {
              case "latest":
                args.shift();
                this.params = 0;
                return "eth_newBlockFilter";

              case "pending":
                args.shift();
                this.params = 0;
                return "eth_newPendingTransactionFilter";

              default:
                return "eth_newFilter";
            }
        };
        var newFilter = new Method({
            name: "newFilter",
            call: newFilterCall,
            params: 1
        });
        var uninstallFilter = new Method({
            name: "uninstallFilter",
            call: "eth_uninstallFilter",
            params: 1
        });
        var getLogs = new Method({
            name: "getLogs",
            call: "eth_getFilterLogs",
            params: 1
        });
        var poll = new Method({
            name: "poll",
            call: "eth_getFilterChanges",
            params: 1
        });
        return [ newFilter, uninstallFilter, getLogs, poll ];
    };
    var shh = function() {
        var newFilter = new Method({
            name: "newFilter",
            call: "shh_newFilter",
            params: 1
        });
        var uninstallFilter = new Method({
            name: "uninstallFilter",
            call: "shh_uninstallFilter",
            params: 1
        });
        var getLogs = new Method({
            name: "getLogs",
            call: "shh_getMessages",
            params: 1
        });
        var poll = new Method({
            name: "poll",
            call: "shh_getFilterChanges",
            params: 1
        });
        return [ newFilter, uninstallFilter, getLogs, poll ];
    };
    module.exports = {
        eth,
        shh
    };
}, function(module, exports, __webpack_require__) {
    var formatters = __webpack_require__(22);
    var utils = __webpack_require__(11);
    var toTopic = function(value) {
        if (value === null || typeof value === "undefined") return null;
        value = String(value);
        if (value.indexOf("0x") === 0) return value; else return utils.fromUtf8(value);
    };
    var getOptions = function(options) {
        if (utils.isString(options)) {
            return options;
        }
        options = options || {};
        options.topics = options.topics || [];
        options.topics = options.topics.map(function(topic) {
            return utils.isArray(topic) ? topic.map(toTopic) : toTopic(topic);
        });
        return {
            topics: options.topics,
            from: options.from,
            to: options.to,
            address: options.address,
            fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
            toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
        };
    };
    var getLogsAtStart = function(self, callback) {
        if (!utils.isString(self.options)) {
            self.get(function(err, messages) {
                if (err) {
                    callback(err);
                }
                if (utils.isArray(messages)) {
                    messages.forEach(function(message) {
                        callback(null, message);
                    });
                }
            });
        }
    };
    var pollFilter = function(self) {
        var onMessage = function(error, messages) {
            if (error) {
                return self.callbacks.forEach(function(callback) {
                    callback(error);
                });
            }
            if (utils.isArray(messages)) {
                messages.forEach(function(message) {
                    message = self.formatter ? self.formatter(message) : message;
                    self.callbacks.forEach(function(callback) {
                        callback(null, message);
                    });
                });
            }
        };
        self.requestManager.startPolling({
            method: self.implementation.poll.call,
            params: [ self.filterId ]
        }, self.filterId, onMessage, self.stopWatching.bind(self));
    };
    var Filter = function(requestManager, options, methods, formatter, callback, filterCreationErrorCallback) {
        var self = this;
        var implementation = {};
        methods.forEach(function(method) {
            method.setRequestManager(requestManager);
            method.attachToObject(implementation);
        });
        this.requestManager = requestManager;
        this.options = getOptions(options);
        this.implementation = implementation;
        this.filterId = null;
        this.callbacks = [];
        this.getLogsCallbacks = [];
        this.pollFilters = [];
        this.formatter = formatter;
        this.implementation.newFilter(this.options, function(error, id) {
            if (error) {
                self.callbacks.forEach(function(cb) {
                    cb(error);
                });
                if (typeof filterCreationErrorCallback === "function") {
                    filterCreationErrorCallback(error);
                }
            } else {
                self.filterId = id;
                self.getLogsCallbacks.forEach(function(cb) {
                    self.get(cb);
                });
                self.getLogsCallbacks = [];
                self.callbacks.forEach(function(cb) {
                    getLogsAtStart(self, cb);
                });
                if (self.callbacks.length > 0) pollFilter(self);
                if (typeof callback === "function") {
                    return self.watch(callback);
                }
            }
        });
        return this;
    };
    Filter.prototype.watch = function(callback) {
        this.callbacks.push(callback);
        if (this.filterId) {
            getLogsAtStart(this, callback);
            pollFilter(this);
        }
        return this;
    };
    Filter.prototype.stopWatching = function(callback) {
        this.requestManager.stopPolling(this.filterId);
        this.callbacks = [];
        if (callback) {
            this.implementation.uninstallFilter(this.filterId, callback);
        } else {
            return this.implementation.uninstallFilter(this.filterId);
        }
    };
    Filter.prototype.get = function(callback) {
        var self = this;
        if (utils.isFunction(callback)) {
            if (this.filterId === null) {
                this.getLogsCallbacks.push(callback);
            } else {
                this.implementation.getLogs(this.filterId, function(err, res) {
                    if (err) {
                        callback(err);
                    } else {
                        callback(null, res.map(function(log) {
                            return self.formatter ? self.formatter(log) : log;
                        }));
                    }
                });
            }
        } else {
            if (this.filterId === null) {
                throw new Error("Filter ID Error: filter().get() can't be chained synchronous, please provide a callback for the get() method.");
            }
            var logs = this.implementation.getLogs(this.filterId);
            return logs.map(function(log) {
                return self.formatter ? self.formatter(log) : log;
            });
        }
        return this;
    };
    module.exports = Filter;
}, function(module, exports, __webpack_require__) {
    var BigNumber = __webpack_require__(38);
    var padLeft = function(string, bytes) {
        var result = string;
        while (result.length < bytes * 2) {
            result = "0" + result;
        }
        return result;
    };
    var iso13616Prepare = function(iban) {
        var A = "A".charCodeAt(0);
        var Z = "Z".charCodeAt(0);
        iban = iban.toUpperCase();
        iban = iban.substr(4) + iban.substr(0, 4);
        return iban.split("").map(function(n) {
            var code = n.charCodeAt(0);
            if (code >= A && code <= Z) {
                return code - A + 10;
            } else {
                return n;
            }
        }).join("");
    };
    var mod9710 = function(iban) {
        var remainder = iban, block;
        while (remainder.length > 2) {
            block = remainder.slice(0, 9);
            remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
        }
        return parseInt(remainder, 10) % 97;
    };
    var Iban = function(iban) {
        this._iban = iban;
    };
    Iban.fromAddress = function(address) {
        var asBn = new BigNumber(address, 16);
        var base36 = asBn.toString(36);
        var padded = padLeft(base36, 15);
        return Iban.fromBban(padded.toUpperCase());
    };
    Iban.fromBban = function(bban) {
        var countryCode = "XE";
        var remainder = mod9710(iso13616Prepare(countryCode + "00" + bban));
        var checkDigit = ("0" + (98 - remainder)).slice(-2);
        return new Iban(countryCode + checkDigit + bban);
    };
    Iban.createIndirect = function(options) {
        return Iban.fromBban("ETH" + options.institution + options.identifier);
    };
    Iban.isValid = function(iban) {
        var i = new Iban(iban);
        return i.isValid();
    };
    Iban.prototype.isValid = function() {
        return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) && mod9710(iso13616Prepare(this._iban)) === 1;
    };
    Iban.prototype.isDirect = function() {
        return this._iban.length === 34 || this._iban.length === 35;
    };
    Iban.prototype.isIndirect = function() {
        return this._iban.length === 20;
    };
    Iban.prototype.checksum = function() {
        return this._iban.substr(2, 2);
    };
    Iban.prototype.institution = function() {
        return this.isIndirect() ? this._iban.substr(7, 4) : "";
    };
    Iban.prototype.client = function() {
        return this.isIndirect() ? this._iban.substr(11) : "";
    };
    Iban.prototype.address = function() {
        if (this.isDirect()) {
            var base36 = this._iban.substr(4);
            var asBn = new BigNumber(base36, 36);
            return padLeft(asBn.toString(16), 20);
        }
        return "";
    };
    Iban.prototype.toString = function() {
        return this._iban;
    };
    module.exports = Iban;
}, function(module, exports, __webpack_require__) {
    var BigNumber = __webpack_require__(38);
    var ETH_UNITS = [ "wei", "kwei", "Mwei", "Gwei", "szabo", "finney", "femtoether", "picoether", "nanoether", "microether", "milliether", "nano", "micro", "milli", "ether", "grand", "Mether", "Gether", "Tether", "Pether", "Eether", "Zether", "Yether", "Nether", "Dether", "Vether", "Uether" ];
    module.exports = {
        ETH_PADDING: 32,
        ETH_SIGNATURE_LENGTH: 4,
        ETH_UNITS,
        ETH_BIGNUMBER_ROUNDING_MODE: {
            ROUNDING_MODE: BigNumber.ROUND_DOWN
        },
        ETH_POLLING_TIMEOUT: 1e3 / 2,
        defaultBlock: "latest",
        defaultAccount: undefined
    };
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function(undefined) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var X32WordArray = C_lib.WordArray;
            var C_x64 = C.x64 = {};
            var X64Word = C_x64.Word = Base.extend({
                init: function(high, low) {
                    this.high = high;
                    this.low = low;
                }
            });
            var X64WordArray = C_x64.WordArray = Base.extend({
                init: function(words, sigBytes) {
                    words = this.words = words || [];
                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 8;
                    }
                },
                toX32: function() {
                    var x64Words = this.words;
                    var x64WordsLength = x64Words.length;
                    var x32Words = [];
                    for (var i = 0; i < x64WordsLength; i++) {
                        var x64Word = x64Words[i];
                        x32Words.push(x64Word.high);
                        x32Words.push(x64Word.low);
                    }
                    return X32WordArray.create(x32Words, this.sigBytes);
                },
                clone: function() {
                    var clone = Base.clone.call(this);
                    var words = clone.words = this.words.slice(0);
                    var wordsLength = words.length;
                    for (var i = 0; i < wordsLength; i++) {
                        words[i] = words[i].clone();
                    }
                    return clone;
                }
            });
        })();
        return CryptoJS;
    });
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    module.exports = function base(ALPHABET) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        for (var z = 0; z < ALPHABET.length; z++) {
            var x = ALPHABET.charAt(z);
            if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + " is ambiguous");
            ALPHABET_MAP[x] = z;
        }
        function encode(source) {
            if (source.length === 0) return "";
            var digits = [ 0 ];
            for (var i = 0; i < source.length; ++i) {
                for (var j = 0, carry = source[i]; j < digits.length; ++j) {
                    carry += digits[j] << 8;
                    digits[j] = carry % BASE;
                    carry = carry / BASE | 0;
                }
                while (carry > 0) {
                    digits.push(carry % BASE);
                    carry = carry / BASE | 0;
                }
            }
            var string = "";
            for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += LEADER;
            for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];
            return string;
        }
        function decodeUnsafe(string) {
            if (typeof string !== "string") throw new TypeError("Expected String");
            if (string.length === 0) return Buffer.allocUnsafe(0);
            var bytes = [ 0 ];
            for (var i = 0; i < string.length; i++) {
                var value = ALPHABET_MAP[string[i]];
                if (value === undefined) return;
                for (var j = 0, carry = value; j < bytes.length; ++j) {
                    carry += bytes[j] * BASE;
                    bytes[j] = carry & 255;
                    carry >>= 8;
                }
                while (carry > 0) {
                    bytes.push(carry & 255);
                    carry >>= 8;
                }
            }
            for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
                bytes.push(0);
            }
            return Buffer.from(bytes.reverse());
        }
        function decode(string) {
            var buffer = decodeUnsafe(string);
            if (buffer) return buffer;
            throw new Error("Non-base" + BASE + " character");
        }
        return {
            encode,
            decodeUnsafe,
            decode
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.encode = encode;
    exports.decode = decode;
    exports.isMNID = isMNID;
    var _jsSha = __webpack_require__(275);
    var _buffer = __webpack_require__(4);
    var BASE58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var base58 = __webpack_require__(54)(BASE58);
    var hex = __webpack_require__(54)("0123456789abcdef");
    function checksum(payload) {
        return new _buffer.Buffer((0, _jsSha.sha3_256)(_buffer.Buffer.concat(payload)), "hex").slice(0, 4);
    }
    function encode(_ref) {
        var network = _ref.network, address = _ref.address;
        var payload = [ new _buffer.Buffer("01", "hex"), hex.decode(network.slice(2)), new _buffer.Buffer(address.slice(2), "hex") ];
        payload.push(checksum(payload));
        return base58.encode(_buffer.Buffer.concat(payload));
    }
    function decode(encoded) {
        var data = _buffer.Buffer.from(base58.decode(encoded));
        var netLength = data.length - 24;
        var version = data.slice(0, 1);
        var network = data.slice(1, netLength);
        var address = data.slice(netLength, 20 + netLength);
        var check = data.slice(netLength + 20);
        if (check.equals(checksum([ version, network, address ]))) {
            return {
                network: "0x" + hex.encode(network),
                address: "0x" + address.toString("hex")
            };
        } else {
            throw new Error("Invalid address checksum");
        }
    }
    function isMNID(encoded) {
        try {
            var data = _buffer.Buffer.from(base58.decode(encoded));
            return data.length > 24 && data[0] === 1;
        } catch (e) {
            return false;
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MissingParametersError = exports.MissingParametersError = function(_Error) {
        _inherits(MissingParametersError, _Error);
        function MissingParametersError(message) {
            _classCallCheck(this, MissingParametersError);
            var _this = _possibleConstructorReturn(this, (MissingParametersError.__proto__ || Object.getPrototypeOf(MissingParametersError)).call(this));
            _this.name = "MissingParametersError";
            _this.message = message || "";
            return _this;
        }
        return MissingParametersError;
    }(Error);
    var InvalidTokenError = exports.InvalidTokenError = function(_Error2) {
        _inherits(InvalidTokenError, _Error2);
        function InvalidTokenError(message) {
            _classCallCheck(this, InvalidTokenError);
            var _this2 = _possibleConstructorReturn(this, (InvalidTokenError.__proto__ || Object.getPrototypeOf(InvalidTokenError)).call(this));
            _this2.name = "InvalidTokenError";
            _this2.message = message || "";
            return _this2;
        }
        return InvalidTokenError;
    }(Error);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = exports;
    curve.base = __webpack_require__(338);
    curve.short = __webpack_require__(337);
    curve.mont = __webpack_require__(336);
    curve.edwards = __webpack_require__(335);
}, function(module, exports, __webpack_require__) {
    var base = exports;
    base.Reporter = __webpack_require__(348).Reporter;
    base.DecoderBuffer = __webpack_require__(124).DecoderBuffer;
    base.EncoderBuffer = __webpack_require__(124).EncoderBuffer;
    base.Node = __webpack_require__(347);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var asn1 = __webpack_require__(371);
        var aesid = __webpack_require__(360);
        var fixProc = __webpack_require__(359);
        var ciphers = __webpack_require__(75);
        var compat = __webpack_require__(144);
        module.exports = parseKeys;
        function parseKeys(buffer) {
            var password;
            if (typeof buffer === "object" && !Buffer.isBuffer(buffer)) {
                password = buffer.passphrase;
                buffer = buffer.key;
            }
            if (typeof buffer === "string") {
                buffer = new Buffer(buffer);
            }
            var stripped = fixProc(buffer, password);
            var type = stripped.tag;
            var data = stripped.data;
            var subtype, ndata;
            switch (type) {
              case "CERTIFICATE":
                ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;

              case "PUBLIC KEY":
                if (!ndata) {
                    ndata = asn1.PublicKey.decode(data, "der");
                }
                subtype = ndata.algorithm.algorithm.join(".");
                switch (subtype) {
                  case "1.2.840.113549.1.1.1":
                    return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");

                  case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };

                  case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };

                  default:
                    throw new Error("unknown key id " + subtype);
                }
                throw new Error("unknown key type " + type);

              case "ENCRYPTED PRIVATE KEY":
                data = asn1.EncryptedPrivateKey.decode(data, "der");
                data = decrypt(data, password);

              case "PRIVATE KEY":
                ndata = asn1.PrivateKey.decode(data, "der");
                subtype = ndata.algorithm.algorithm.join(".");
                switch (subtype) {
                  case "1.2.840.113549.1.1.1":
                    return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");

                  case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };

                  case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };

                  default:
                    throw new Error("unknown key id " + subtype);
                }
                throw new Error("unknown key type " + type);

              case "RSA PUBLIC KEY":
                return asn1.RSAPublicKey.decode(data, "der");

              case "RSA PRIVATE KEY":
                return asn1.RSAPrivateKey.decode(data, "der");

              case "DSA PRIVATE KEY":
                return {
                    type: "dsa",
                    params: asn1.DSAPrivateKey.decode(data, "der")
                };

              case "EC PRIVATE KEY":
                data = asn1.ECPrivateKey.decode(data, "der");
                return {
                    curve: data.parameters.value,
                    privateKey: data.privateKey
                };

              default:
                throw new Error("unknown key type " + type);
            }
        }
        parseKeys.signature = asn1.signature;
        function decrypt(data, password) {
            var salt = data.algorithm.decrypt.kde.kdeparams.salt;
            var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
            var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
            var iv = data.algorithm.decrypt.cipher.iv;
            var cipherText = data.subjectPrivateKey;
            var keylen = parseInt(algo.split("-")[1], 10) / 8;
            var key = compat.pbkdf2Sync(password, salt, iters, keylen);
            var cipher = ciphers.createDecipheriv(algo, key, iv);
            var out = [];
            out.push(cipher.update(cipherText));
            out.push(cipher.final());
            return Buffer.concat(out);
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    var MD5 = __webpack_require__(83);
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
        if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");
        if (salt) {
            if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
            if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
        }
        var keyLen = keyBits / 8;
        var key = Buffer.alloc(keyLen);
        var iv = Buffer.alloc(ivLen || 0);
        var tmp = Buffer.alloc(0);
        while (keyLen > 0 || ivLen > 0) {
            var hash = new MD5();
            hash.update(tmp);
            hash.update(password);
            if (salt) hash.update(salt);
            tmp = hash.digest();
            var used = 0;
            if (keyLen > 0) {
                var keyStart = key.length - keyLen;
                used = Math.min(keyLen, tmp.length);
                tmp.copy(key, keyStart, 0, used);
                keyLen -= used;
            }
            if (used < tmp.length && ivLen > 0) {
                var ivStart = iv.length - ivLen;
                var length = Math.min(ivLen, tmp.length - used);
                tmp.copy(iv, ivStart, used, used + length);
                ivLen -= length;
            }
        }
        tmp.fill(0);
        return {
            key,
            iv
        };
    }
    module.exports = EVP_BytesToKey;
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    function asUInt32Array(buf) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        var len = buf.length / 4 | 0;
        var out = new Array(len);
        for (var i = 0; i < len; i++) {
            out[i] = buf.readUInt32BE(i * 4);
        }
        return out;
    }
    function scrubVec(v) {
        for (var i = 0; i < v.length; v++) {
            v[i] = 0;
        }
    }
    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
        var SUB_MIX0 = SUB_MIX[0];
        var SUB_MIX1 = SUB_MIX[1];
        var SUB_MIX2 = SUB_MIX[2];
        var SUB_MIX3 = SUB_MIX[3];
        var s0 = M[0] ^ keySchedule[0];
        var s1 = M[1] ^ keySchedule[1];
        var s2 = M[2] ^ keySchedule[2];
        var s3 = M[3] ^ keySchedule[3];
        var t0, t1, t2, t3;
        var ksRow = 4;
        for (var round = 1; round < nRounds; round++) {
            t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
            t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
            t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
            t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
            s0 = t0;
            s1 = t1;
            s2 = t2;
            s3 = t3;
        }
        t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
        t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
        t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
        t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
        t0 = t0 >>> 0;
        t1 = t1 >>> 0;
        t2 = t2 >>> 0;
        t3 = t3 >>> 0;
        return [ t0, t1, t2, t3 ];
    }
    var RCON = [ 0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ];
    var G = function() {
        var d = new Array(256);
        for (var j = 0; j < 256; j++) {
            if (j < 128) {
                d[j] = j << 1;
            } else {
                d[j] = j << 1 ^ 283;
            }
        }
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX = [ [], [], [], [] ];
        var INV_SUB_MIX = [ [], [], [], [] ];
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; ++i) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX[0][x] = t << 24 | t >>> 8;
            SUB_MIX[1][x] = t << 16 | t >>> 16;
            SUB_MIX[2][x] = t << 8 | t >>> 24;
            SUB_MIX[3][x] = t;
            t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
            INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
            INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
            INV_SUB_MIX[3][sx] = t;
            if (x === 0) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
        return {
            SBOX,
            INV_SBOX,
            SUB_MIX,
            INV_SUB_MIX
        };
    }();
    function AES(key) {
        this._key = asUInt32Array(key);
        this._reset();
    }
    AES.blockSize = 4 * 4;
    AES.keySize = 256 / 8;
    AES.prototype.blockSize = AES.blockSize;
    AES.prototype.keySize = AES.keySize;
    AES.prototype._reset = function() {
        var keyWords = this._key;
        var keySize = keyWords.length;
        var nRounds = keySize + 6;
        var ksRows = (nRounds + 1) * 4;
        var keySchedule = [];
        for (var k = 0; k < keySize; k++) {
            keySchedule[k] = keyWords[k];
        }
        for (k = keySize; k < ksRows; k++) {
            var t = keySchedule[k - 1];
            if (k % keySize === 0) {
                t = t << 8 | t >>> 24;
                t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
                t ^= RCON[k / keySize | 0] << 24;
            } else if (keySize > 6 && k % keySize === 4) {
                t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
            }
            keySchedule[k] = keySchedule[k - keySize] ^ t;
        }
        var invKeySchedule = [];
        for (var ik = 0; ik < ksRows; ik++) {
            var ksR = ksRows - ik;
            var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
            if (ik < 4 || ksR <= 4) {
                invKeySchedule[ik] = tt;
            } else {
                invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
            }
        }
        this._nRounds = nRounds;
        this._keySchedule = keySchedule;
        this._invKeySchedule = invKeySchedule;
    };
    AES.prototype.encryptBlockRaw = function(M) {
        M = asUInt32Array(M);
        return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
    };
    AES.prototype.encryptBlock = function(M) {
        var out = this.encryptBlockRaw(M);
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[1], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[3], 12);
        return buf;
    };
    AES.prototype.decryptBlock = function(M) {
        M = asUInt32Array(M);
        var m1 = M[1];
        M[1] = M[3];
        M[3] = m1;
        var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[3], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[1], 12);
        return buf;
    };
    AES.prototype.scrub = function() {
        scrubVec(this._keySchedule);
        scrubVec(this._invKeySchedule);
        scrubVec(this._key);
    };
    module.exports.AES = AES;
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(process) {
        if (!process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
            module.exports = {
                nextTick
            };
        } else {
            module.exports = process;
        }
        function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
                throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn);

              case 2:
                return process.nextTick(function afterTickOne() {
                    fn.call(null, arg1);
                });

              case 3:
                return process.nextTick(function afterTickTwo() {
                    fn.call(null, arg1, arg2);
                });

              case 4:
                return process.nextTick(function afterTickThree() {
                    fn.call(null, arg1, arg2, arg3);
                });

              default:
                args = new Array(len - 1);
                i = 0;
                while (i < args.length) {
                    args[i++] = arguments[i];
                }
                return process.nextTick(function afterTick() {
                    fn.apply(null, args);
                });
            }
        }
    }).call(this, __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = exports;
    curve.base = __webpack_require__(430);
    curve.short = __webpack_require__(429);
    curve.mont = __webpack_require__(428);
    curve.edwards = __webpack_require__(427);
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(437).default;
    module.exports.default = module.exports;
}, function(module, exports, __webpack_require__) {
    (function(global, factory) {
        true ? module.exports = factory() : undefined;
    })(this, function() {
        "use strict";
        var REACT_STATICS = {
            childContextTypes: true,
            contextTypes: true,
            defaultProps: true,
            displayName: true,
            getDefaultProps: true,
            getDerivedStateFromProps: true,
            mixins: true,
            propTypes: true,
            type: true
        };
        var KNOWN_STATICS = {
            name: true,
            length: true,
            prototype: true,
            caller: true,
            callee: true,
            arguments: true,
            arity: true
        };
        var defineProperty = Object.defineProperty;
        var getOwnPropertyNames = Object.getOwnPropertyNames;
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var getPrototypeOf = Object.getPrototypeOf;
        var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
        return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
            if (typeof sourceComponent !== "string") {
                if (objectPrototype) {
                    var inheritedComponent = getPrototypeOf(sourceComponent);
                    if (inheritedComponent && inheritedComponent !== objectPrototype) {
                        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                    }
                }
                var keys = getOwnPropertyNames(sourceComponent);
                if (getOwnPropertySymbols) {
                    keys = keys.concat(getOwnPropertySymbols(sourceComponent));
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                        try {
                            defineProperty(targetComponent, key, descriptor);
                        } catch (e) {}
                    }
                }
                return targetComponent;
            }
            return targetComponent;
        };
    });
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityTypeAddress = __webpack_require__(232);
    var SolidityTypeBool = __webpack_require__(231);
    var SolidityTypeInt = __webpack_require__(230);
    var SolidityTypeUInt = __webpack_require__(229);
    var SolidityTypeDynamicBytes = __webpack_require__(228);
    var SolidityTypeString = __webpack_require__(227);
    var SolidityTypeReal = __webpack_require__(226);
    var SolidityTypeUReal = __webpack_require__(225);
    var SolidityTypeBytes = __webpack_require__(224);
    var isDynamic = function(solidityType, type) {
        return solidityType.isDynamicType(type) || solidityType.isDynamicArray(type);
    };
    var SolidityCoder = function(types) {
        this._types = types;
    };
    SolidityCoder.prototype._requireType = function(type) {
        var solidityType = this._types.filter(function(t) {
            return t.isType(type);
        })[0];
        if (!solidityType) {
            throw Error("invalid solidity type!: " + type);
        }
        return solidityType;
    };
    SolidityCoder.prototype.encodeParam = function(type, param) {
        return this.encodeParams([ type ], [ param ]);
    };
    SolidityCoder.prototype.encodeParams = function(types, params) {
        var solidityTypes = this.getSolidityTypes(types);
        var encodeds = solidityTypes.map(function(solidityType, index) {
            return solidityType.encode(params[index], types[index]);
        });
        var dynamicOffset = solidityTypes.reduce(function(acc, solidityType, index) {
            var staticPartLength = solidityType.staticPartLength(types[index]);
            var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;
            return acc + (isDynamic(solidityTypes[index], types[index]) ? 32 : roundedStaticPartLength);
        }, 0);
        var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);
        return result;
    };
    SolidityCoder.prototype.encodeMultiWithOffset = function(types, solidityTypes, encodeds, dynamicOffset) {
        var result = "";
        var self = this;
        types.forEach(function(type, i) {
            if (isDynamic(solidityTypes[i], types[i])) {
                result += f.formatInputInt(dynamicOffset).encode();
                var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
                dynamicOffset += e.length / 2;
            } else {
                result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            }
        });
        types.forEach(function(type, i) {
            if (isDynamic(solidityTypes[i], types[i])) {
                var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
                dynamicOffset += e.length / 2;
                result += e;
            }
        });
        return result;
    };
    SolidityCoder.prototype.encodeWithOffset = function(type, solidityType, encoded, offset) {
        var self = this;
        if (solidityType.isDynamicArray(type)) {
            return function() {
                var nestedName = solidityType.nestedName(type);
                var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
                var result = encoded[0];
                (function() {
                    var previousLength = 2;
                    if (solidityType.isDynamicArray(nestedName)) {
                        for (var i = 1; i < encoded.length; i++) {
                            previousLength += +encoded[i - 1][0] || 0;
                            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                        }
                    }
                })();
                (function() {
                    for (var i = 0; i < encoded.length - 1; i++) {
                        var additionalOffset = result / 2;
                        result += self.encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset + additionalOffset);
                    }
                })();
                return result;
            }();
        } else if (solidityType.isStaticArray(type)) {
            return function() {
                var nestedName = solidityType.nestedName(type);
                var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
                var result = "";
                if (solidityType.isDynamicArray(nestedName)) {
                    (function() {
                        var previousLength = 0;
                        for (var i = 0; i < encoded.length; i++) {
                            previousLength += +(encoded[i - 1] || [])[0] || 0;
                            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                        }
                    })();
                }
                (function() {
                    for (var i = 0; i < encoded.length; i++) {
                        var additionalOffset = result / 2;
                        result += self.encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);
                    }
                })();
                return result;
            }();
        }
        return encoded;
    };
    SolidityCoder.prototype.decodeParam = function(type, bytes) {
        return this.decodeParams([ type ], bytes)[0];
    };
    SolidityCoder.prototype.decodeParams = function(types, bytes) {
        var solidityTypes = this.getSolidityTypes(types);
        var offsets = this.getOffsets(types, solidityTypes);
        return solidityTypes.map(function(solidityType, index) {
            return solidityType.decode(bytes, offsets[index], types[index], index);
        });
    };
    SolidityCoder.prototype.getOffsets = function(types, solidityTypes) {
        var lengths = solidityTypes.map(function(solidityType, index) {
            return solidityType.staticPartLength(types[index]);
        });
        for (var i = 1; i < lengths.length; i++) {
            lengths[i] += lengths[i - 1];
        }
        return lengths.map(function(length, index) {
            var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
            return length - staticPartLength;
        });
    };
    SolidityCoder.prototype.getSolidityTypes = function(types) {
        var self = this;
        return types.map(function(type) {
            return self._requireType(type);
        });
    };
    var coder = new SolidityCoder([ new SolidityTypeAddress(), new SolidityTypeBool(), new SolidityTypeInt(), new SolidityTypeUInt(), new SolidityTypeDynamicBytes(), new SolidityTypeBytes(), new SolidityTypeString(), new SolidityTypeReal(), new SolidityTypeUReal() ]);
    module.exports = coder;
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var C_algo = C.algo;
            var HMAC = C_algo.HMAC = Base.extend({
                init: function(hasher, key) {
                    hasher = this._hasher = new hasher.init();
                    if (typeof key == "string") {
                        key = Utf8.parse(key);
                    }
                    var hasherBlockSize = hasher.blockSize;
                    var hasherBlockSizeBytes = hasherBlockSize * 4;
                    if (key.sigBytes > hasherBlockSizeBytes) {
                        key = hasher.finalize(key);
                    }
                    key.clamp();
                    var oKey = this._oKey = key.clone();
                    var iKey = this._iKey = key.clone();
                    var oKeyWords = oKey.words;
                    var iKeyWords = iKey.words;
                    for (var i = 0; i < hasherBlockSize; i++) {
                        oKeyWords[i] ^= 1549556828;
                        iKeyWords[i] ^= 909522486;
                    }
                    oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                    this.reset();
                },
                reset: function() {
                    var hasher = this._hasher;
                    hasher.reset();
                    hasher.update(this._iKey);
                },
                update: function(messageUpdate) {
                    this._hasher.update(messageUpdate);
                    return this;
                },
                finalize: function(messageUpdate) {
                    var hasher = this._hasher;
                    var innerHash = hasher.finalize(messageUpdate);
                    hasher.reset();
                    var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                    return hmac;
                }
            });
        })();
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
            var W = [];
            var SHA1 = C_algo.SHA1 = Hasher.extend({
                _doReset: function() {
                    this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);
                },
                _doProcessBlock: function(M, offset) {
                    var H = this._hash.words;
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];
                    for (var i = 0; i < 80; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            W[i] = n << 1 | n >>> 31;
                        }
                        var t = (a << 5 | a >>> 27) + e + W[i];
                        if (i < 20) {
                            t += (b & c | ~b & d) + 1518500249;
                        } else if (i < 40) {
                            t += (b ^ c ^ d) + 1859775393;
                        } else if (i < 60) {
                            t += (b & c | b & d | c & d) - 1894007588;
                        } else {
                            t += (b ^ c ^ d) - 899497514;
                        }
                        e = d;
                        d = c;
                        c = b << 30 | b >>> 2;
                        b = a;
                        a = t;
                    }
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                    H[4] = H[4] + e | 0;
                },
                _doFinalize: function() {
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;
                    this._process();
                    return this._hash;
                },
                clone: function() {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
                    return clone;
                }
            });
            C.SHA1 = Hasher._createHelper(SHA1);
            C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
        return CryptoJS.SHA1;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.decodeToken = decodeToken;
    var _base64url = __webpack_require__(64);
    var _base64url2 = _interopRequireDefault(_base64url);
    var _errors = __webpack_require__(56);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function decodeToken(token) {
        if (typeof token === "string") {
            var tokenParts = token.split(".");
            var header = JSON.parse(_base64url2.default.decode(tokenParts[0]));
            var payload = JSON.parse(_base64url2.default.decode(tokenParts[1]));
            var signature = tokenParts[2];
            return {
                header,
                payload,
                signature
            };
        } else if ((typeof token === "undefined" ? "undefined" : _typeof(token)) === "object") {
            var _payload = token.payload;
            if (token.payload[0] !== "{") {
                _payload = _base64url2.default.decode(_payload);
            }
            var allHeaders = [];
            token.header.map(function(headerValue) {
                var header = JSON.parse(_base64url2.default.decode(headerValue));
                allHeaders.push(header);
            });
            return {
                header: allHeaders,
                payload: JSON.parse(_payload),
                signature: token.signature
            };
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isFDQN;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _merge = __webpack_require__(39);
    var _merge2 = _interopRequireDefault(_merge);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var default_fqdn_options = {
        require_tld: true,
        allow_underscores: false,
        allow_trailing_dot: false
    };
    function isFDQN(str, options) {
        (0, _assertString2.default)(str);
        options = (0, _merge2.default)(options, default_fqdn_options);
        if (options.allow_trailing_dot && str[str.length - 1] === ".") {
            str = str.substring(0, str.length - 1);
        }
        var parts = str.split(".");
        if (options.require_tld) {
            var tld = parts.pop();
            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
                return false;
            }
            if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
                return false;
            }
        }
        for (var part, i = 0; i < parts.length; i++) {
            part = parts[i];
            if (options.allow_underscores) {
                part = part.replace(/_/g, "");
            }
            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
                return false;
            }
            if (/[\uff01-\uff5e]/.test(part)) {
                return false;
            }
            if (part[0] === "-" || part[part.length - 1] === "-") {
                return false;
            }
        }
        return true;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = toString;
    function toString(input) {
        if ((typeof input === "undefined" ? "undefined" : _typeof(input)) === "object" && input !== null) {
            if (typeof input.toString === "function") {
                input = input.toString();
            } else {
                input = "[object Object]";
            }
        } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
            input = "";
        }
        return String(input);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = toDate;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function toDate(date) {
        (0, _assertString2.default)(date);
        date = Date.parse(date);
        return !isNaN(date) ? new Date(date) : null;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var bn = __webpack_require__(9);
        var randomBytes = __webpack_require__(35);
        module.exports = crt;
        function blind(priv) {
            var r = getr(priv);
            var blinder = r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed();
            return {
                blinder,
                unblinder: r.invm(priv.modulus)
            };
        }
        function crt(msg, priv) {
            var blinds = blind(priv);
            var len = priv.modulus.byteLength();
            var mod = bn.mont(priv.modulus);
            var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
            var c1 = blinded.toRed(bn.mont(priv.prime1));
            var c2 = blinded.toRed(bn.mont(priv.prime2));
            var qinv = priv.coefficient;
            var p = priv.prime1;
            var q = priv.prime2;
            var m1 = c1.redPow(priv.exponent1);
            var m2 = c2.redPow(priv.exponent2);
            m1 = m1.fromRed();
            m2 = m2.fromRed();
            var h = m1.isub(m2).imul(qinv).umod(p);
            h.imul(q);
            m2.iadd(h);
            return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
        }
        crt.getr = getr;
        function getr(priv) {
            var len = priv.modulus.byteLength();
            var r = new bn(randomBytes(len));
            while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
                r = new bn(randomBytes(len));
            }
            return r;
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    var modeModules = {
        ECB: __webpack_require__(385),
        CBC: __webpack_require__(384),
        CFB: __webpack_require__(383),
        CFB8: __webpack_require__(382),
        CFB1: __webpack_require__(381),
        OFB: __webpack_require__(380),
        CTR: __webpack_require__(140),
        GCM: __webpack_require__(140)
    };
    var modes = __webpack_require__(138);
    for (var key in modes) {
        modes[key].module = modeModules[modes[key].mode];
    }
    module.exports = modes;
}, function(module, exports, __webpack_require__) {
    var ciphers = __webpack_require__(386);
    var deciphers = __webpack_require__(378);
    var modes = __webpack_require__(138);
    function getCiphers() {
        return Object.keys(modes);
    }
    exports.createCipher = exports.Cipher = ciphers.createCipher;
    exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
    exports.createDecipher = exports.Decipher = deciphers.createDecipher;
    exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
    exports.listCiphers = exports.getCiphers = getCiphers;
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.utils = __webpack_require__(391);
    exports.Cipher = __webpack_require__(390);
    exports.DES = __webpack_require__(389);
    exports.CBC = __webpack_require__(388);
    exports.EDE = __webpack_require__(387);
}, function(module, exports, __webpack_require__) {
    var exports = module.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = exports[algorithm];
        if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
    };
    exports.sha = __webpack_require__(400);
    exports.sha1 = __webpack_require__(399);
    exports.sha224 = __webpack_require__(398);
    exports.sha256 = __webpack_require__(149);
    exports.sha384 = __webpack_require__(397);
    exports.sha512 = __webpack_require__(148);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Buffer = __webpack_require__(4).Buffer;
    var inherits = __webpack_require__(3);
    var HashBase = __webpack_require__(155);
    var ARRAY16 = new Array(16);
    var zl = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ];
    var zr = [ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ];
    var sl = [ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ];
    var sr = [ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ];
    var hl = [ 0, 1518500249, 1859775393, 2400959708, 2840853838 ];
    var hr = [ 1352829926, 1548603684, 1836072691, 2053994217, 0 ];
    function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
    }
    inherits(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
            var tl;
            var tr;
            if (i < 16) {
                tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
                tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
            } else if (i < 32) {
                tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
                tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
            } else if (i < 48) {
                tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
                tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
            } else if (i < 64) {
                tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
                tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
            } else {
                tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
                tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
            }
            al = el;
            el = dl;
            dl = rotl(cl, 10);
            cl = bl;
            bl = tl;
            ar = er;
            er = dr;
            dr = rotl(cr, 10);
            cr = br;
            br = tr;
        }
        var t = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t;
    };
    RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
            this._block.fill(0, this._blockOffset, 64);
            this._update();
            this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        buffer.writeInt32LE(this._e, 16);
        return buffer;
    };
    function rotl(x, n) {
        return x << n | x >>> 32 - n;
    }
    function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    module.exports = RIPEMD160;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Buffer = __webpack_require__(7).Buffer;
    var isEncoding = Buffer.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;

          default:
            return false;
        }
    };
    function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";

              case "latin1":
              case "binary":
                return "latin1";

              case "base64":
              case "ascii":
              case "hex":
                return enc;

              default:
                if (retried) return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
        }
    }
    function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;

          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;

          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;

          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0) return "";
        var r;
        var i;
        if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === undefined) return "";
            i = this.lastNeed;
            this.lastNeed = 0;
        } else {
            i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
        if (byte <= 127) return 0; else if (byte >> 5 === 6) return 2; else if (byte >> 4 === 14) return 3; else if (byte >> 3 === 30) return 4;
        return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1;
            return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2;
            return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
            if (nb > 0) {
                if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
            }
            return nb;
        }
        return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
        if ((buf[0] & 192) !== 128) {
            self.lastNeed = 0;
            return "�";
        }
        if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
                self.lastNeed = 1;
                return "�";
            }
            if (self.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 192) !== 128) {
                    self.lastNeed = 2;
                    return "�";
                }
            }
        }
    }
    function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== undefined) return r;
        if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + "�";
        return r;
    }
    function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
                var c = r.charCodeAt(r.length - 1);
                if (c >= 55296 && c <= 56319) {
                    this.lastNeed = 2;
                    this.lastTotal = 4;
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                    return r.slice(0, -1);
                }
            }
            return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
    }
    function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
        } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
    }
    function simpleWrite(buf) {
        return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(process, setImmediate, global) {
        var pna = __webpack_require__(62);
        module.exports = Writable;
        function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
        }
        function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
                onCorkedFinish(_this, state);
            };
        }
        var asyncWrite = !process.browser && [ "v0.10", "v0.9." ].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
        var Duplex;
        Writable.WritableState = WritableState;
        var util = __webpack_require__(42);
        util.inherits = __webpack_require__(3);
        var internalUtil = {
            deprecate: __webpack_require__(406)
        };
        var Stream = __webpack_require__(153);
        var Buffer = __webpack_require__(7).Buffer;
        var OurUint8Array = global.Uint8Array || function() {};
        function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var destroyImpl = __webpack_require__(152);
        util.inherits(Writable, Stream);
        function nop() {}
        function WritableState(options, stream) {
            Duplex = Duplex || __webpack_require__(26);
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
            var hwm = options.highWaterMark;
            var writableHwm = options.writableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
                onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
        }
        WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
                out.push(current);
                current = current.next;
            }
            return out;
        };
        (function() {
            try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                    get: internalUtil.deprecate(function() {
                        return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
                });
            } catch (_) {}
        })();
        var realHasInstance;
        if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function(object) {
                    if (realHasInstance.call(this, object)) return true;
                    if (this !== Writable) return false;
                    return object && object._writableState instanceof WritableState;
                }
            });
        } else {
            realHasInstance = function(object) {
                return object instanceof this;
            };
        }
        function Writable(options) {
            Duplex = Duplex || __webpack_require__(26);
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                return new Writable(options);
            }
            this._writableState = new WritableState(options, this);
            this.writable = true;
            if (options) {
                if (typeof options.write === "function") this._write = options.write;
                if (typeof options.writev === "function") this._writev = options.writev;
                if (typeof options.destroy === "function") this._destroy = options.destroy;
                if (typeof options.final === "function") this._final = options.final;
            }
            Stream.call(this);
        }
        Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function writeAfterEnd(stream, cb) {
            var er = new Error("write after end");
            stream.emit("error", er);
            pna.nextTick(cb, er);
        }
        function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            if (chunk === null) {
                er = new TypeError("May not write null values to stream");
            } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
                er = new TypeError("Invalid non-string/buffer chunk");
            }
            if (er) {
                stream.emit("error", er);
                pna.nextTick(cb, er);
                valid = false;
            }
            return valid;
        }
        Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
            }
            if (isBuf) encoding = "buffer"; else if (!encoding) encoding = state.defaultEncoding;
            if (typeof cb !== "function") cb = nop;
            if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
        };
        Writable.prototype.cork = function() {
            var state = this._writableState;
            state.corked++;
        };
        Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
            }
        };
        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string") encoding = encoding.toLowerCase();
            if (!([ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
        };
        function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
        }
        Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            enumerable: false,
            get: function() {
                return this._writableState.highWaterMark;
            }
        });
        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                    isBuf = true;
                    encoding = "buffer";
                    chunk = newChunk;
                }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret) state.needDrain = true;
            if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                    chunk,
                    encoding,
                    isBuf,
                    callback: cb,
                    next: null
                };
                if (last) {
                    last.next = state.lastBufferedRequest;
                } else {
                    state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
            } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
        }
        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
        }
        function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
                pna.nextTick(cb, er);
                pna.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
            } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
                finishMaybe(stream, state);
            }
        }
        function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
        }
        function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er) onwriteError(stream, state, sync, er, cb); else {
                var finished = needFinish(state);
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                    clearBuffer(stream, state);
                }
                if (sync) {
                    asyncWrite(afterWrite, stream, state, finished, cb);
                } else {
                    afterWrite(stream, state, finished, cb);
                }
            }
        }
        function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
        }
        function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
            }
        }
        function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                    buffer[count] = entry;
                    if (!entry.isBuf) allBuffers = false;
                    entry = entry.next;
                    count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                    state.corkedRequestsFree = holder.next;
                    holder.next = null;
                } else {
                    state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
            } else {
                while (entry) {
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                    entry = entry.next;
                    state.bufferedRequestCount--;
                    if (state.writing) {
                        break;
                    }
                }
                if (entry === null) state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
        }
        Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"));
        };
        Writable.prototype._writev = null;
        Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
            } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
            }
            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
            if (state.corked) {
                state.corked = 1;
                this.uncork();
            }
            if (!state.ending && !state.finished) endWritable(this, state, cb);
        };
        function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }
        function callFinal(stream, state) {
            stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                    stream.emit("error", err);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
            });
        }
        function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function") {
                    state.pendingcb++;
                    state.finalCalled = true;
                    pna.nextTick(callFinal, stream, state);
                } else {
                    state.prefinished = true;
                    stream.emit("prefinish");
                }
            }
        }
        function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                    state.finished = true;
                    stream.emit("finish");
                }
            }
            return need;
        }
        function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
                if (state.finished) pna.nextTick(cb); else stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
        }
        function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
            }
            if (state.corkedRequestsFree) {
                state.corkedRequestsFree.next = corkReq;
            } else {
                state.corkedRequestsFree = corkReq;
            }
        }
        Object.defineProperty(Writable.prototype, "destroyed", {
            get: function() {
                if (this._writableState === undefined) {
                    return false;
                }
                return this._writableState.destroyed;
            },
            set: function(value) {
                if (!this._writableState) {
                    return;
                }
                this._writableState.destroyed = value;
            }
        });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;
        Writable.prototype._destroy = function(err, cb) {
            this.end();
            cb(err);
        };
    }).call(this, __webpack_require__(13), __webpack_require__(151).setImmediate, __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(154);
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(80);
    exports.Duplex = __webpack_require__(26);
    exports.Transform = __webpack_require__(150);
    exports.PassThrough = __webpack_require__(405);
}, function(module, exports) {
    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
        this._maxListeners = n;
        return this;
    };
    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;
        if (!this._events) this._events = {};
        if (type === "error") {
            if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er;
                } else {
                    var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
                    err.context = er;
                    throw err;
                }
            }
        }
        handler = this._events[type];
        if (isUndefined(handler)) return false;
        if (isFunction(handler)) {
            switch (arguments.length) {
              case 1:
                handler.call(this);
                break;

              case 2:
                handler.call(this, arguments[1]);
                break;

              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;

              default:
                args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            args = Array.prototype.slice.call(arguments, 1);
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++) listeners[i].apply(this, args);
        }
        return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
        var m;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events) this._events = {};
        if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type]) this._events[type] = listener; else if (isObject(this._events[type])) this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
        if (isObject(this._events[type]) && !this._events[type].warned) {
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }
            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                if (typeof console.trace === "function") {
                    console.trace();
                }
            }
        }
        return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        var fired = false;
        function g() {
            this.removeListener(type, g);
            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }
        g.listener = listener;
        this.on(type, g);
        return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[type]) return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || isFunction(list.listener) && list.listener === listener) {
            delete this._events[type];
            if (this._events.removeListener) this.emit("removeListener", type, listener);
        } else if (isObject(list)) {
            for (i = length; i-- > 0; ) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                    position = i;
                    break;
                }
            }
            if (position < 0) return this;
            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }
            if (this._events.removeListener) this.emit("removeListener", type, listener);
        }
        return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;
        if (!this._events) return this;
        if (!this._events.removeListener) {
            if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type];
            return this;
        }
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === "removeListener") continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = {};
            return this;
        }
        listeners = this._events[type];
        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else if (listeners) {
            while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];
        return this;
    };
    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [ this._events[type] ]; else ret = this._events[type].slice();
        return ret;
    };
    EventEmitter.prototype.listenerCount = function(type) {
        if (this._events) {
            var evlistener = this._events[type];
            if (isFunction(evlistener)) return 1; else if (evlistener) return evlistener.length;
        }
        return 0;
    };
    EventEmitter.listenerCount = function(emitter, type) {
        return emitter.listenerCount(type);
    };
    function isFunction(arg) {
        return typeof arg === "function";
    }
    function isNumber(arg) {
        return typeof arg === "number";
    }
    function isObject(arg) {
        return typeof arg === "object" && arg !== null;
    }
    function isUndefined(arg) {
        return arg === void 0;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var inherits = __webpack_require__(3);
        var HashBase = __webpack_require__(155);
        var ARRAY16 = new Array(16);
        function MD5() {
            HashBase.call(this, 64);
            this._a = 1732584193;
            this._b = 4023233417;
            this._c = 2562383102;
            this._d = 271733878;
        }
        inherits(MD5, HashBase);
        MD5.prototype._update = function() {
            var M = ARRAY16;
            for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
            var a = this._a;
            var b = this._b;
            var c = this._c;
            var d = this._d;
            a = fnF(a, b, c, d, M[0], 3614090360, 7);
            d = fnF(d, a, b, c, M[1], 3905402710, 12);
            c = fnF(c, d, a, b, M[2], 606105819, 17);
            b = fnF(b, c, d, a, M[3], 3250441966, 22);
            a = fnF(a, b, c, d, M[4], 4118548399, 7);
            d = fnF(d, a, b, c, M[5], 1200080426, 12);
            c = fnF(c, d, a, b, M[6], 2821735955, 17);
            b = fnF(b, c, d, a, M[7], 4249261313, 22);
            a = fnF(a, b, c, d, M[8], 1770035416, 7);
            d = fnF(d, a, b, c, M[9], 2336552879, 12);
            c = fnF(c, d, a, b, M[10], 4294925233, 17);
            b = fnF(b, c, d, a, M[11], 2304563134, 22);
            a = fnF(a, b, c, d, M[12], 1804603682, 7);
            d = fnF(d, a, b, c, M[13], 4254626195, 12);
            c = fnF(c, d, a, b, M[14], 2792965006, 17);
            b = fnF(b, c, d, a, M[15], 1236535329, 22);
            a = fnG(a, b, c, d, M[1], 4129170786, 5);
            d = fnG(d, a, b, c, M[6], 3225465664, 9);
            c = fnG(c, d, a, b, M[11], 643717713, 14);
            b = fnG(b, c, d, a, M[0], 3921069994, 20);
            a = fnG(a, b, c, d, M[5], 3593408605, 5);
            d = fnG(d, a, b, c, M[10], 38016083, 9);
            c = fnG(c, d, a, b, M[15], 3634488961, 14);
            b = fnG(b, c, d, a, M[4], 3889429448, 20);
            a = fnG(a, b, c, d, M[9], 568446438, 5);
            d = fnG(d, a, b, c, M[14], 3275163606, 9);
            c = fnG(c, d, a, b, M[3], 4107603335, 14);
            b = fnG(b, c, d, a, M[8], 1163531501, 20);
            a = fnG(a, b, c, d, M[13], 2850285829, 5);
            d = fnG(d, a, b, c, M[2], 4243563512, 9);
            c = fnG(c, d, a, b, M[7], 1735328473, 14);
            b = fnG(b, c, d, a, M[12], 2368359562, 20);
            a = fnH(a, b, c, d, M[5], 4294588738, 4);
            d = fnH(d, a, b, c, M[8], 2272392833, 11);
            c = fnH(c, d, a, b, M[11], 1839030562, 16);
            b = fnH(b, c, d, a, M[14], 4259657740, 23);
            a = fnH(a, b, c, d, M[1], 2763975236, 4);
            d = fnH(d, a, b, c, M[4], 1272893353, 11);
            c = fnH(c, d, a, b, M[7], 4139469664, 16);
            b = fnH(b, c, d, a, M[10], 3200236656, 23);
            a = fnH(a, b, c, d, M[13], 681279174, 4);
            d = fnH(d, a, b, c, M[0], 3936430074, 11);
            c = fnH(c, d, a, b, M[3], 3572445317, 16);
            b = fnH(b, c, d, a, M[6], 76029189, 23);
            a = fnH(a, b, c, d, M[9], 3654602809, 4);
            d = fnH(d, a, b, c, M[12], 3873151461, 11);
            c = fnH(c, d, a, b, M[15], 530742520, 16);
            b = fnH(b, c, d, a, M[2], 3299628645, 23);
            a = fnI(a, b, c, d, M[0], 4096336452, 6);
            d = fnI(d, a, b, c, M[7], 1126891415, 10);
            c = fnI(c, d, a, b, M[14], 2878612391, 15);
            b = fnI(b, c, d, a, M[5], 4237533241, 21);
            a = fnI(a, b, c, d, M[12], 1700485571, 6);
            d = fnI(d, a, b, c, M[3], 2399980690, 10);
            c = fnI(c, d, a, b, M[10], 4293915773, 15);
            b = fnI(b, c, d, a, M[1], 2240044497, 21);
            a = fnI(a, b, c, d, M[8], 1873313359, 6);
            d = fnI(d, a, b, c, M[15], 4264355552, 10);
            c = fnI(c, d, a, b, M[6], 2734768916, 15);
            b = fnI(b, c, d, a, M[13], 1309151649, 21);
            a = fnI(a, b, c, d, M[4], 4149444226, 6);
            d = fnI(d, a, b, c, M[11], 3174756917, 10);
            c = fnI(c, d, a, b, M[2], 718787259, 15);
            b = fnI(b, c, d, a, M[9], 3951481745, 21);
            this._a = this._a + a | 0;
            this._b = this._b + b | 0;
            this._c = this._c + c | 0;
            this._d = this._d + d | 0;
        };
        MD5.prototype._digest = function() {
            this._block[this._blockOffset++] = 128;
            if (this._blockOffset > 56) {
                this._block.fill(0, this._blockOffset, 64);
                this._update();
                this._blockOffset = 0;
            }
            this._block.fill(0, this._blockOffset, 56);
            this._block.writeUInt32LE(this._length[0], 56);
            this._block.writeUInt32LE(this._length[1], 60);
            this._update();
            var buffer = new Buffer(16);
            buffer.writeInt32LE(this._a, 0);
            buffer.writeInt32LE(this._b, 4);
            buffer.writeInt32LE(this._c, 8);
            buffer.writeInt32LE(this._d, 12);
            return buffer;
        };
        function rotl(x, n) {
            return x << n | x >>> 32 - n;
        }
        function fnF(a, b, c, d, m, k, s) {
            return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
        }
        function fnG(a, b, c, d, m, k, s) {
            return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
        }
        function fnH(a, b, c, d, m, k, s) {
            return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
        }
        function fnI(a, b, c, d, m, k, s) {
            return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
        }
        module.exports = MD5;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    var r;
    module.exports = function rand(len) {
        if (!r) r = new Rand(null);
        return r.generate(len);
    };
    function Rand(rand) {
        this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
        return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes) return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();
        return res;
    };
    if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
            Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                self.crypto.getRandomValues(arr);
                return arr;
            };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
            Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                self.msCrypto.getRandomValues(arr);
                return arr;
            };
        } else if (typeof window === "object") {
            Rand.prototype._rand = function() {
                throw new Error("Not implemented yet");
            };
        }
    } else {
        try {
            var crypto = __webpack_require__(431);
            if (typeof crypto.randomBytes !== "function") throw new Error("Not supported");
            Rand.prototype._rand = function _rand(n) {
                return crypto.randomBytes(n);
            };
        } catch (e) {}
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.cryptoClients = exports.SECP256K1Client = undefined;
    var _secp256k = __webpack_require__(435);
    var cryptoClients = {
        ES256K: _secp256k.SECP256K1Client
    };
    exports.SECP256K1Client = _secp256k.SECP256K1Client;
    exports.cryptoClients = cryptoClients;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _signer = __webpack_require__(438);
    Object.defineProperty(exports, "TokenSigner", {
        enumerable: true,
        get: function get() {
            return _signer.TokenSigner;
        }
    });
    Object.defineProperty(exports, "createUnsecuredToken", {
        enumerable: true,
        get: function get() {
            return _signer.createUnsecuredToken;
        }
    });
    var _verifier = __webpack_require__(276);
    Object.defineProperty(exports, "TokenVerifier", {
        enumerable: true,
        get: function get() {
            return _verifier.TokenVerifier;
        }
    });
    var _decode = __webpack_require__(69);
    Object.defineProperty(exports, "decodeToken", {
        enumerable: true,
        get: function get() {
            return _decode.decodeToken;
        }
    });
    var _errors = __webpack_require__(56);
    Object.defineProperty(exports, "MissingParametersError", {
        enumerable: true,
        get: function get() {
            return _errors.MissingParametersError;
        }
    });
    Object.defineProperty(exports, "InvalidTokenError", {
        enumerable: true,
        get: function get() {
            return _errors.InvalidTokenError;
        }
    });
    var _cryptoClients = __webpack_require__(85);
    Object.defineProperty(exports, "SECP256K1Client", {
        enumerable: true,
        get: function get() {
            return _cryptoClients.SECP256K1Client;
        }
    });
    Object.defineProperty(exports, "cryptoClients", {
        enumerable: true,
        get: function get() {
            return _cryptoClients.cryptoClients;
        }
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var connectUport = exports.connectUport = function connectUport(data) {
        return {
            type: "CONNECT_UPORT",
            data
        };
    };
    var getUserAccount = exports.getUserAccount = function getUserAccount(text) {
        return {
            type: "USER_ACCOUNT",
            text
        };
    };
    var getContract = exports.getContract = function getContract(data) {
        return {
            type: "CONTRACT",
            data
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var _warning = __webpack_require__(5);
    var _warning2 = _interopRequireDefault(_warning);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var createTransitionManager = function createTransitionManager() {
        var prompt = null;
        var setPrompt = function setPrompt(nextPrompt) {
            (0, _warning2.default)(prompt == null, "A history supports only one prompt at a time");
            prompt = nextPrompt;
            return function() {
                if (prompt === nextPrompt) prompt = null;
            };
        };
        var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
            if (prompt != null) {
                var result = typeof prompt === "function" ? prompt(location, action) : prompt;
                if (typeof result === "string") {
                    if (typeof getUserConfirmation === "function") {
                        getUserConfirmation(result, callback);
                    } else {
                        (0, _warning2.default)(false, "A history needs a getUserConfirmation function in order to use a prompt message");
                        callback(true);
                    }
                } else {
                    callback(result !== false);
                }
            } else {
                callback(true);
            }
        };
        var listeners = [];
        var appendListener = function appendListener(fn) {
            var isActive = true;
            var listener = function listener() {
                if (isActive) fn.apply(undefined, arguments);
            };
            listeners.push(listener);
            return function() {
                isActive = false;
                listeners = listeners.filter(function(item) {
                    return item !== listener;
                });
            };
        };
        var notifyListeners = function notifyListeners() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            listeners.forEach(function(listener) {
                return listener.apply(undefined, args);
            });
        };
        return {
            setPrompt,
            confirmTransitionTo,
            appendListener,
            notifyListeners
        };
    };
    exports.default = createTransitionManager;
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.locationsAreEqual = exports.createLocation = undefined;
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _resolvePathname = __webpack_require__(93);
    var _resolvePathname2 = _interopRequireDefault(_resolvePathname);
    var _valueEqual = __webpack_require__(92);
    var _valueEqual2 = _interopRequireDefault(_valueEqual);
    var _PathUtils = __webpack_require__(20);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
        var location = void 0;
        if (typeof path === "string") {
            location = (0, _PathUtils.parsePath)(path);
            location.state = state;
        } else {
            location = _extends({}, path);
            if (location.pathname === undefined) location.pathname = "";
            if (location.search) {
                if (location.search.charAt(0) !== "?") location.search = "?" + location.search;
            } else {
                location.search = "";
            }
            if (location.hash) {
                if (location.hash.charAt(0) !== "#") location.hash = "#" + location.hash;
            } else {
                location.hash = "";
            }
            if (state !== undefined && location.state === undefined) location.state = state;
        }
        try {
            location.pathname = decodeURI(location.pathname);
        } catch (e) {
            if (e instanceof URIError) {
                throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + "This is likely caused by an invalid percent-encoding.");
            } else {
                throw e;
            }
        }
        if (key) location.key = key;
        if (currentLocation) {
            if (!location.pathname) {
                location.pathname = currentLocation.pathname;
            } else if (location.pathname.charAt(0) !== "/") {
                location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
            }
        } else {
            if (!location.pathname) {
                location.pathname = "/";
            }
        }
        return location;
    };
    var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
        return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, 
        _valueEqual2.default)(a.state, b.state);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    function makeEmptyFunction(arg) {
        return function() {
            return arg;
        };
    }
    var emptyFunction = function emptyFunction() {};
    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function() {
        return this;
    };
    emptyFunction.thatReturnsArgument = function(arg) {
        return arg;
    };
    module.exports = emptyFunction;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var validateFormat = function validateFormat(format) {};
    if (false) {}
    function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);
        if (!condition) {
            var error;
            if (format === undefined) {
                error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
            } else {
                var args = [ a, b, c, d, e, f ];
                var argIndex = 0;
                error = new Error(format.replace(/%s/g, function() {
                    return args[argIndex++];
                }));
                error.name = "Invariant Violation";
            }
            error.framesToPop = 1;
            throw error;
        }
    }
    module.exports = invariant;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    function valueEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return false;
        if (Array.isArray(a)) {
            return Array.isArray(b) && a.length === b.length && a.every(function(item, index) {
                return valueEqual(item, b[index]);
            });
        }
        var aType = typeof a === "undefined" ? "undefined" : _typeof(a);
        var bType = typeof b === "undefined" ? "undefined" : _typeof(b);
        if (aType !== bType) return false;
        if (aType === "object") {
            var aValue = a.valueOf();
            var bValue = b.valueOf();
            if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
            var aKeys = Object.keys(a);
            var bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length) return false;
            return aKeys.every(function(key) {
                return valueEqual(a[key], b[key]);
            });
        }
        return false;
    }
    __webpack_exports__["default"] = valueEqual;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    function isAbsolute(pathname) {
        return pathname.charAt(0) === "/";
    }
    function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
            list[i] = list[k];
        }
        list.pop();
    }
    function resolvePathname(to) {
        var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var toParts = to && to.split("/") || [];
        var fromParts = from && from.split("/") || [];
        var isToAbs = to && isAbsolute(to);
        var isFromAbs = from && isAbsolute(from);
        var mustEndAbs = isToAbs || isFromAbs;
        if (to && isAbsolute(to)) {
            fromParts = toParts;
        } else if (toParts.length) {
            fromParts.pop();
            fromParts = fromParts.concat(toParts);
        }
        if (!fromParts.length) return "/";
        var hasTrailingSlash = void 0;
        if (fromParts.length) {
            var last = fromParts[fromParts.length - 1];
            hasTrailingSlash = last === "." || last === ".." || last === "";
        } else {
            hasTrailingSlash = false;
        }
        var up = 0;
        for (var i = fromParts.length; i >= 0; i--) {
            var part = fromParts[i];
            if (part === ".") {
                spliceOne(fromParts, i);
            } else if (part === "..") {
                spliceOne(fromParts, i);
                up++;
            } else if (up) {
                spliceOne(fromParts, i);
                up--;
            }
        }
        if (!mustEndAbs) for (;up--; up) {
            fromParts.unshift("..");
        }
        if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift("");
        var result = fromParts.join("/");
        if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
        return result;
    }
    __webpack_exports__["default"] = resolvePathname;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(global, module) {
        var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(174);
        var root;
        if (typeof self !== "undefined") {
            root = self;
        } else if (typeof window !== "undefined") {
            root = window;
        } else if (typeof global !== "undefined") {
            root = global;
        } else if (true) {
            root = module;
        } else {}
        var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["a"])(root);
        __webpack_exports__["a"] = result;
    }).call(this, __webpack_require__(12), __webpack_require__(468)(module));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    var KEY_PREFIX = "persist:";
    var FLUSH = "persist/FLUSH";
    var REHYDRATE = "persist/REHYDRATE";
    var PAUSE = "persist/PAUSE";
    var PERSIST = "persist/PERSIST";
    var PURGE = "persist/PURGE";
    var REGISTER = "persist/REGISTER";
    var DEFAULT_VERSION = -1;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
        var debug = _ref.debug;
        var newState = _extends({}, reducedState);
        if (inboundState && (typeof inboundState === "undefined" ? "undefined" : _typeof(inboundState)) === "object") {
            Object.keys(inboundState).forEach(function(key) {
                if (key === "_persist") return;
                if (originalState[key] !== reducedState[key]) {
                    if (false) {}
                    return;
                }
                newState[key] = inboundState[key];
            });
        }
        if (false) {}
        return newState;
    }
    function createPersistoid(config) {
        var blacklist = config.blacklist || null;
        var whitelist = config.whitelist || null;
        var transforms = config.transforms || [];
        var throttle = config.throttle || 0;
        var storageKey = "" + (config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX) + config.key;
        var storage = config.storage;
        var serialize = config.serialize === false ? function(x) {
            return x;
        } : defaultSerialize;
        var lastState = {};
        var stagedState = {};
        var keysToProcess = [];
        var timeIterator = null;
        var writePromise = null;
        var update = function update(state) {
            Object.keys(state).forEach(function(key) {
                var subState = state[key];
                if (!passWhitelistBlacklist(key)) return;
                if (lastState[key] === state[key]) return;
                if (keysToProcess.indexOf(key) !== -1) return;
                keysToProcess.push(key);
            });
            if (timeIterator === null) {
                timeIterator = setInterval(processNextKey, throttle);
            }
            lastState = state;
        };
        function processNextKey() {
            if (keysToProcess.length === 0) {
                if (timeIterator) clearInterval(timeIterator);
                timeIterator = null;
                return;
            }
            var key = keysToProcess.shift();
            var endState = transforms.reduce(function(subState, transformer) {
                return transformer.in(subState, key, lastState);
            }, lastState[key]);
            if (typeof endState !== "undefined") stagedWrite(key, endState);
        }
        function stagedWrite(key, endState) {
            try {
                stagedState[key] = serialize(endState);
            } catch (err) {
                console.error("redux-persist/createPersistoid: error serializing state", err);
            }
            if (keysToProcess.length === 0) {
                Object.keys(stagedState).forEach(function(key) {
                    if (lastState[key] === undefined) {
                        delete stagedState[key];
                    }
                });
                writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
            }
        }
        function passWhitelistBlacklist(key) {
            if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist") return false;
            if (blacklist && blacklist.indexOf(key) !== -1) return false;
            return true;
        }
        function onWriteFail(err) {
            if (err && "production" !== "production") {
                console.error("Error storing data", err);
            }
        }
        var flush = function flush() {
            while (keysToProcess.length !== 0) {
                processNextKey();
            }
            return writePromise || Promise.resolve();
        };
        return {
            update,
            flush
        };
    }
    function defaultSerialize(data) {
        return JSON.stringify(data);
    }
    function getStoredState_getStoredState(config) {
        var transforms = config.transforms || [];
        var storageKey = "" + (config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX) + config.key;
        var storage = config.storage;
        var debug = config.debug;
        var deserialize = config.serialize === false ? function(x) {
            return x;
        } : defaultDeserialize;
        return storage.getItem(storageKey).then(function(serialized) {
            if (!serialized) return undefined; else {
                try {
                    var state = {};
                    var rawState = deserialize(serialized);
                    Object.keys(rawState).forEach(function(key) {
                        state[key] = transforms.reduceRight(function(subState, transformer) {
                            return transformer.out(subState, key, rawState);
                        }, deserialize(rawState[key]));
                    });
                    return state;
                } catch (err) {
                    if (false) {}
                    throw err;
                }
            }
        });
    }
    function defaultDeserialize(serial) {
        return JSON.parse(serial);
    }
    function purgeStoredState(config) {
        var storage = config.storage;
        var storageKey = "" + (config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX) + config.key;
        return storage.removeItem(storageKey, warnIfRemoveError);
    }
    function warnIfRemoveError(err) {
        if (err && "production" !== "production") {
            console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
        }
    }
    var persistReducer_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function _objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    var DEFAULT_TIMEOUT = 5e3;
    function persistReducer(config, baseReducer) {
        if (false) {}
        var version = config.version !== undefined ? config.version : DEFAULT_VERSION;
        var debug = config.debug || false;
        var stateReconciler = config.stateReconciler === undefined ? autoMergeLevel1 : config.stateReconciler;
        var getStoredState = config.getStoredState || getStoredState_getStoredState;
        var timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;
        var _persistoid = null;
        var _purge = false;
        var _paused = true;
        var conditionalUpdate = function conditionalUpdate(state) {
            state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
            return state;
        };
        return function(state, action) {
            var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, [ "_persist" ]);
            var restState = rest;
            if (action.type === PERSIST) {
                var _sealed = false;
                var _rehydrate = function _rehydrate(payload, err) {
                    if (false) {}
                    if (!_sealed) {
                        action.rehydrate(config.key, payload, err);
                        _sealed = true;
                    }
                };
                timeout && setTimeout(function() {
                    !_sealed && _rehydrate(undefined, new Error('redux-persist: persist timed out for persist key "' + config.key + '"'));
                }, timeout);
                _paused = false;
                if (!_persistoid) _persistoid = createPersistoid(config);
                if (_persist) return state;
                if (typeof action.rehydrate !== "function" || typeof action.register !== "function") throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
                action.register(config.key);
                getStoredState(config).then(function(restoredState) {
                    var migrate = config.migrate || function(s, v) {
                        return Promise.resolve(s);
                    };
                    migrate(restoredState, version).then(function(migratedState) {
                        _rehydrate(migratedState);
                    }, function(migrateErr) {
                        if (false) {}
                        _rehydrate(undefined, migrateErr);
                    });
                }, function(err) {
                    _rehydrate(undefined, err);
                });
                return persistReducer_extends({}, baseReducer(restState, action), {
                    _persist: {
                        version,
                        rehydrated: false
                    }
                });
            } else if (action.type === PURGE) {
                _purge = true;
                action.result(purgeStoredState(config));
                return persistReducer_extends({}, baseReducer(restState, action), {
                    _persist
                });
            } else if (action.type === FLUSH) {
                action.result(_persistoid && _persistoid.flush());
                return persistReducer_extends({}, baseReducer(restState, action), {
                    _persist
                });
            } else if (action.type === PAUSE) {
                _paused = true;
            } else if (action.type === REHYDRATE) {
                if (_purge) return persistReducer_extends({}, restState, {
                    _persist: persistReducer_extends({}, _persist, {
                        rehydrated: true
                    })
                });
                if (action.key === config.key) {
                    var reducedState = baseReducer(restState, action);
                    var inboundState = action.payload;
                    var reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
                    var _newState = persistReducer_extends({}, reconciledRest, {
                        _persist: persistReducer_extends({}, _persist, {
                            rehydrated: true
                        })
                    });
                    return conditionalUpdate(_newState);
                }
            }
            if (!_persist) return baseReducer(state, action);
            var newState = baseReducer(restState, action);
            if (newState === restState) return state; else {
                newState._persist = _persist;
                return conditionalUpdate(newState);
            }
        };
    }
    var redux = __webpack_require__(24);
    var autoMergeLevel2_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var autoMergeLevel2_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {
        var debug = _ref.debug;
        var newState = autoMergeLevel2_extends({}, reducedState);
        if (inboundState && (typeof inboundState === "undefined" ? "undefined" : autoMergeLevel2_typeof(inboundState)) === "object") {
            Object.keys(inboundState).forEach(function(key) {
                if (key === "_persist") return;
                if (originalState[key] !== reducedState[key]) {
                    if (false) {}
                    return;
                }
                if (isPlainEnoughObject(reducedState[key])) {
                    newState[key] = autoMergeLevel2_extends({}, newState[key], inboundState[key]);
                    return;
                }
                newState[key] = inboundState[key];
            });
        }
        if (false) {}
        return newState;
    }
    function isPlainEnoughObject(o) {
        return o !== null && !Array.isArray(o) && (typeof o === "undefined" ? "undefined" : autoMergeLevel2_typeof(o)) === "object";
    }
    function persistCombineReducers(config, reducers) {
        config.stateReconciler = config.stateReconciler === undefined ? autoMergeLevel2 : config.stateReconciler;
        return persistReducer(config, Object(redux["combineReducers"])(reducers));
    }
    var persistStore_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        } else {
            return Array.from(arr);
        }
    }
    var initialState = {
        registry: [],
        bootstrapped: false
    };
    var persistStore_persistorReducer = function persistorReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
        var action = arguments[1];
        switch (action.type) {
          case REGISTER:
            return persistStore_extends({}, state, {
                registry: [].concat(_toConsumableArray(state.registry), [ action.key ])
            });

          case REHYDRATE:
            var firstIndex = state.registry.indexOf(action.key);
            var registry = [].concat(_toConsumableArray(state.registry));
            registry.splice(firstIndex, 1);
            return persistStore_extends({}, state, {
                registry,
                bootstrapped: registry.length === 0
            });

          default:
            return state;
        }
    };
    function persistStore(store, options, cb) {
        if (false) {
            var bannedKeys, optionsToTest;
        }
        var boostrappedCb = cb || false;
        var _pStore = Object(redux["createStore"])(persistStore_persistorReducer, initialState, options ? options.enhancer : undefined);
        var register = function register(key) {
            _pStore.dispatch({
                type: REGISTER,
                key
            });
        };
        var rehydrate = function rehydrate(key, payload, err) {
            var rehydrateAction = {
                type: REHYDRATE,
                payload,
                err,
                key
            };
            store.dispatch(rehydrateAction);
            _pStore.dispatch(rehydrateAction);
            if (boostrappedCb && persistor.getState().bootstrapped) {
                boostrappedCb();
                boostrappedCb = false;
            }
        };
        var persistor = persistStore_extends({}, _pStore, {
            purge: function purge() {
                var results = [];
                store.dispatch({
                    type: PURGE,
                    result: function result(purgeResult) {
                        results.push(purgeResult);
                    }
                });
                return Promise.all(results);
            },
            flush: function flush() {
                var results = [];
                store.dispatch({
                    type: FLUSH,
                    result: function result(flushResult) {
                        results.push(flushResult);
                    }
                });
                return Promise.all(results);
            },
            pause: function pause() {
                store.dispatch({
                    type: PAUSE
                });
            },
            persist: function persist() {
                store.dispatch({
                    type: PERSIST,
                    register,
                    rehydrate
                });
            }
        });
        persistor.persist();
        return persistor;
    }
    function createMigrate(migrations, config) {
        var _ref = config || {}, debug = _ref.debug;
        return function(state, currentVersion) {
            if (!state) {
                if (false) {}
                return Promise.resolve(undefined);
            }
            var inboundVersion = state._persist && state._persist.version !== undefined ? state._persist.version : DEFAULT_VERSION;
            if (inboundVersion === currentVersion) {
                if (false) {}
                return Promise.resolve(state);
            }
            if (inboundVersion > currentVersion) {
                if (false) {}
                return Promise.resolve(state);
            }
            var migrationKeys = Object.keys(migrations).map(function(ver) {
                return parseInt(ver);
            }).filter(function(key) {
                return currentVersion >= key && key > inboundVersion;
            }).sort(function(a, b) {
                return a - b;
            });
            if (false) {}
            try {
                var migratedState = migrationKeys.reduce(function(state, versionKey) {
                    if (false) {}
                    return migrations[versionKey](state);
                }, state);
                return Promise.resolve(migratedState);
            } catch (err) {
                return Promise.reject(err);
            }
        };
    }
    function createTransform(inbound, outbound) {
        var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var whitelist = config.whitelist || null;
        var blacklist = config.blacklist || null;
        function whitelistBlacklistCheck(key) {
            if (whitelist && whitelist.indexOf(key) === -1) return true;
            if (blacklist && blacklist.indexOf(key) !== -1) return true;
            return false;
        }
        return {
            in: function _in(state, key, fullState) {
                return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;
            },
            out: function out(state, key, fullState) {
                return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;
            }
        };
    }
    __webpack_require__.d(__webpack_exports__, "persistReducer", function() {
        return persistReducer;
    });
    __webpack_require__.d(__webpack_exports__, "persistCombineReducers", function() {
        return persistCombineReducers;
    });
    __webpack_require__.d(__webpack_exports__, "persistStore", function() {
        return persistStore;
    });
    __webpack_require__.d(__webpack_exports__, "createMigrate", function() {
        return createMigrate;
    });
    __webpack_require__.d(__webpack_exports__, "createTransform", function() {
        return createTransform;
    });
    __webpack_require__.d(__webpack_exports__, "getStoredState", function() {
        return getStoredState_getStoredState;
    });
    __webpack_require__.d(__webpack_exports__, "createPersistoid", function() {
        return createPersistoid;
    });
    __webpack_require__.d(__webpack_exports__, "purgeStoredState", function() {
        return purgeStoredState;
    });
    __webpack_require__.d(__webpack_exports__, "KEY_PREFIX", function() {
        return KEY_PREFIX;
    });
    __webpack_require__.d(__webpack_exports__, "FLUSH", function() {
        return FLUSH;
    });
    __webpack_require__.d(__webpack_exports__, "REHYDRATE", function() {
        return REHYDRATE;
    });
    __webpack_require__.d(__webpack_exports__, "PAUSE", function() {
        return PAUSE;
    });
    __webpack_require__.d(__webpack_exports__, "PERSIST", function() {
        return PERSIST;
    });
    __webpack_require__.d(__webpack_exports__, "PURGE", function() {
        return PURGE;
    });
    __webpack_require__.d(__webpack_exports__, "REGISTER", function() {
        return REGISTER;
    });
    __webpack_require__.d(__webpack_exports__, "DEFAULT_VERSION", function() {
        return DEFAULT_VERSION;
    });
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    var browser = __webpack_require__(5);
    var browser_default = __webpack_require__.n(browser);
    var react = __webpack_require__(2);
    var react_default = __webpack_require__.n(react);
    var prop_types = __webpack_require__(0);
    var prop_types_default = __webpack_require__.n(prop_types);
    var history_createBrowserHistory = __webpack_require__(178);
    var createBrowserHistory_default = __webpack_require__.n(history_createBrowserHistory);
    var invariant_browser = __webpack_require__(8);
    var invariant_browser_default = __webpack_require__.n(invariant_browser);
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Router_Router = function(_React$Component) {
        _inherits(Router, _React$Component);
        function Router() {
            var _temp, _this, _ret;
            _classCallCheck(this, Router);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.state = {
                match: _this.computeMatch(_this.props.history.location.pathname)
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }
        Router.prototype.getChildContext = function getChildContext() {
            return {
                router: _extends({}, this.context.router, {
                    history: this.props.history,
                    route: {
                        location: this.props.history.location,
                        match: this.state.match
                    }
                })
            };
        };
        Router.prototype.computeMatch = function computeMatch(pathname) {
            return {
                path: "/",
                url: "/",
                params: {},
                isExact: pathname === "/"
            };
        };
        Router.prototype.componentWillMount = function componentWillMount() {
            var _this2 = this;
            var _props = this.props, children = _props.children, history = _props.history;
            invariant_browser_default()(children == null || react_default.a.Children.count(children) === 1, "A <Router> may have only one child element");
            this.unlisten = history.listen(function() {
                _this2.setState({
                    match: _this2.computeMatch(history.location.pathname)
                });
            });
        };
        Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            browser_default()(this.props.history === nextProps.history, "You cannot change <Router history>");
        };
        Router.prototype.componentWillUnmount = function componentWillUnmount() {
            this.unlisten();
        };
        Router.prototype.render = function render() {
            var children = this.props.children;
            return children ? react_default.a.Children.only(children) : null;
        };
        return Router;
    }(react_default.a.Component);
    Router_Router.propTypes = {
        history: prop_types_default.a.object.isRequired,
        children: prop_types_default.a.node
    };
    Router_Router.contextTypes = {
        router: prop_types_default.a.object
    };
    Router_Router.childContextTypes = {
        router: prop_types_default.a.object.isRequired
    };
    var es_Router = Router_Router;
    var react_router_dom_es_Router = es_Router;
    function BrowserRouter_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function BrowserRouter_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function BrowserRouter_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var BrowserRouter_BrowserRouter = function(_React$Component) {
        BrowserRouter_inherits(BrowserRouter, _React$Component);
        function BrowserRouter() {
            var _temp, _this, _ret;
            BrowserRouter_classCallCheck(this, BrowserRouter);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = BrowserRouter_possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.history = createBrowserHistory_default()(_this.props), _temp), BrowserRouter_possibleConstructorReturn(_this, _ret);
        }
        BrowserRouter.prototype.componentWillMount = function componentWillMount() {
            browser_default()(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.");
        };
        BrowserRouter.prototype.render = function render() {
            return react_default.a.createElement(react_router_dom_es_Router, {
                history: this.history,
                children: this.props.children
            });
        };
        return BrowserRouter;
    }(react_default.a.Component);
    BrowserRouter_BrowserRouter.propTypes = {
        basename: prop_types_default.a.string,
        forceRefresh: prop_types_default.a.bool,
        getUserConfirmation: prop_types_default.a.func,
        keyLength: prop_types_default.a.number,
        children: prop_types_default.a.node
    };
    var es_BrowserRouter = BrowserRouter_BrowserRouter;
    var history_createHashHistory = __webpack_require__(177);
    var createHashHistory_default = __webpack_require__.n(history_createHashHistory);
    function HashRouter_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function HashRouter_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function HashRouter_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var HashRouter_HashRouter = function(_React$Component) {
        HashRouter_inherits(HashRouter, _React$Component);
        function HashRouter() {
            var _temp, _this, _ret;
            HashRouter_classCallCheck(this, HashRouter);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = HashRouter_possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.history = createHashHistory_default()(_this.props), _temp), HashRouter_possibleConstructorReturn(_this, _ret);
        }
        HashRouter.prototype.componentWillMount = function componentWillMount() {
            browser_default()(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.");
        };
        HashRouter.prototype.render = function render() {
            return react_default.a.createElement(react_router_dom_es_Router, {
                history: this.history,
                children: this.props.children
            });
        };
        return HashRouter;
    }(react_default.a.Component);
    HashRouter_HashRouter.propTypes = {
        basename: prop_types_default.a.string,
        getUserConfirmation: prop_types_default.a.func,
        hashType: prop_types_default.a.oneOf([ "hashbang", "noslash", "slash" ]),
        children: prop_types_default.a.node
    };
    var es_HashRouter = HashRouter_HashRouter;
    var Link_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function _objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    function Link_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function Link_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function Link_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var isModifiedEvent = function isModifiedEvent(event) {
        return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    };
    var Link_Link = function(_React$Component) {
        Link_inherits(Link, _React$Component);
        function Link() {
            var _temp, _this, _ret;
            Link_classCallCheck(this, Link);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = Link_possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.handleClick = function(event) {
                if (_this.props.onClick) _this.props.onClick(event);
                if (!event.defaultPrevented && event.button === 0 && !_this.props.target && !isModifiedEvent(event)) {
                    event.preventDefault();
                    var history = _this.context.router.history;
                    var _this$props = _this.props, replace = _this$props.replace, to = _this$props.to;
                    if (replace) {
                        history.replace(to);
                    } else {
                        history.push(to);
                    }
                }
            }, _temp), Link_possibleConstructorReturn(_this, _ret);
        }
        Link.prototype.render = function render() {
            var _props = this.props, replace = _props.replace, to = _props.to, innerRef = _props.innerRef, props = _objectWithoutProperties(_props, [ "replace", "to", "innerRef" ]);
            invariant_browser_default()(this.context.router, "You should not use <Link> outside a <Router>");
            var href = this.context.router.history.createHref(typeof to === "string" ? {
                pathname: to
            } : to);
            return react_default.a.createElement("a", Link_extends({}, props, {
                onClick: this.handleClick,
                href,
                ref: innerRef
            }));
        };
        return Link;
    }(react_default.a.Component);
    Link_Link.propTypes = {
        onClick: prop_types_default.a.func,
        target: prop_types_default.a.string,
        replace: prop_types_default.a.bool,
        to: prop_types_default.a.oneOfType([ prop_types_default.a.string, prop_types_default.a.object ]).isRequired,
        innerRef: prop_types_default.a.oneOfType([ prop_types_default.a.string, prop_types_default.a.func ])
    };
    Link_Link.defaultProps = {
        replace: false
    };
    Link_Link.contextTypes = {
        router: prop_types_default.a.shape({
            history: prop_types_default.a.shape({
                push: prop_types_default.a.func.isRequired,
                replace: prop_types_default.a.func.isRequired,
                createHref: prop_types_default.a.func.isRequired
            }).isRequired
        }).isRequired
    };
    var es_Link = Link_Link;
    var history_createMemoryHistory = __webpack_require__(176);
    var createMemoryHistory_default = __webpack_require__.n(history_createMemoryHistory);
    function MemoryRouter_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function MemoryRouter_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function MemoryRouter_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MemoryRouter_MemoryRouter = function(_React$Component) {
        MemoryRouter_inherits(MemoryRouter, _React$Component);
        function MemoryRouter() {
            var _temp, _this, _ret;
            MemoryRouter_classCallCheck(this, MemoryRouter);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = MemoryRouter_possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.history = createMemoryHistory_default()(_this.props), _temp), MemoryRouter_possibleConstructorReturn(_this, _ret);
        }
        MemoryRouter.prototype.componentWillMount = function componentWillMount() {
            browser_default()(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.");
        };
        MemoryRouter.prototype.render = function render() {
            return react_default.a.createElement(es_Router, {
                history: this.history,
                children: this.props.children
            });
        };
        return MemoryRouter;
    }(react_default.a.Component);
    MemoryRouter_MemoryRouter.propTypes = {
        initialEntries: prop_types_default.a.array,
        initialIndex: prop_types_default.a.number,
        getUserConfirmation: prop_types_default.a.func,
        keyLength: prop_types_default.a.number,
        children: prop_types_default.a.node
    };
    var es_MemoryRouter = MemoryRouter_MemoryRouter;
    var react_router_dom_es_MemoryRouter = es_MemoryRouter;
    var path_to_regexp = __webpack_require__(175);
    var path_to_regexp_default = __webpack_require__.n(path_to_regexp);
    var patternCache = {};
    var cacheLimit = 1e4;
    var cacheCount = 0;
    var matchPath_compilePath = function compilePath(pattern, options) {
        var cacheKey = "" + options.end + options.strict + options.sensitive;
        var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
        if (cache[pattern]) return cache[pattern];
        var keys = [];
        var re = path_to_regexp_default()(pattern, keys, options);
        var compiledPattern = {
            re,
            keys
        };
        if (cacheCount < cacheLimit) {
            cache[pattern] = compiledPattern;
            cacheCount++;
        }
        return compiledPattern;
    };
    var matchPath = function matchPath(pathname) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (typeof options === "string") options = {
            path: options
        };
        var _options = options, _options$path = _options.path, path = _options$path === undefined ? "/" : _options$path, _options$exact = _options.exact, exact = _options$exact === undefined ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === undefined ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === undefined ? false : _options$sensitive;
        var _compilePath = matchPath_compilePath(path, {
            end: exact,
            strict,
            sensitive
        }), re = _compilePath.re, keys = _compilePath.keys;
        var match = re.exec(pathname);
        if (!match) return null;
        var url = match[0], values = match.slice(1);
        var isExact = pathname === url;
        if (exact && !isExact) return null;
        return {
            path,
            url: path === "/" && url === "" ? "/" : url,
            isExact,
            params: keys.reduce(function(memo, key, index) {
                memo[key.name] = values[index];
                return memo;
            }, {})
        };
    };
    var es_matchPath = matchPath;
    var Route_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function Route_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function Route_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function Route_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Route_isEmptyChildren = function isEmptyChildren(children) {
        return react_default.a.Children.count(children) === 0;
    };
    var Route_Route = function(_React$Component) {
        Route_inherits(Route, _React$Component);
        function Route() {
            var _temp, _this, _ret;
            Route_classCallCheck(this, Route);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = Route_possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.state = {
                match: _this.computeMatch(_this.props, _this.context.router)
            }, _temp), Route_possibleConstructorReturn(_this, _ret);
        }
        Route.prototype.getChildContext = function getChildContext() {
            return {
                router: Route_extends({}, this.context.router, {
                    route: {
                        location: this.props.location || this.context.router.route.location,
                        match: this.state.match
                    }
                })
            };
        };
        Route.prototype.computeMatch = function computeMatch(_ref, router) {
            var computedMatch = _ref.computedMatch, location = _ref.location, path = _ref.path, strict = _ref.strict, exact = _ref.exact, sensitive = _ref.sensitive;
            if (computedMatch) return computedMatch;
            invariant_browser_default()(router, "You should not use <Route> or withRouter() outside a <Router>");
            var route = router.route;
            var pathname = (location || route.location).pathname;
            return path ? es_matchPath(pathname, {
                path,
                strict,
                exact,
                sensitive
            }) : route.match;
        };
        Route.prototype.componentWillMount = function componentWillMount() {
            browser_default()(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored");
            browser_default()(!(this.props.component && this.props.children && !Route_isEmptyChildren(this.props.children)), "You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored");
            browser_default()(!(this.props.render && this.props.children && !Route_isEmptyChildren(this.props.children)), "You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored");
        };
        Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
            browser_default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');
            browser_default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
            this.setState({
                match: this.computeMatch(nextProps, nextContext.router)
            });
        };
        Route.prototype.render = function render() {
            var match = this.state.match;
            var _props = this.props, children = _props.children, component = _props.component, render = _props.render;
            var _context$router = this.context.router, history = _context$router.history, route = _context$router.route, staticContext = _context$router.staticContext;
            var location = this.props.location || route.location;
            var props = {
                match,
                location,
                history,
                staticContext
            };
            return component ? match ? react_default.a.createElement(component, props) : null : render ? match ? render(props) : null : children ? typeof children === "function" ? children(props) : !Route_isEmptyChildren(children) ? react_default.a.Children.only(children) : null : null;
        };
        return Route;
    }(react_default.a.Component);
    Route_Route.propTypes = {
        computedMatch: prop_types_default.a.object,
        path: prop_types_default.a.string,
        exact: prop_types_default.a.bool,
        strict: prop_types_default.a.bool,
        sensitive: prop_types_default.a.bool,
        component: prop_types_default.a.func,
        render: prop_types_default.a.func,
        children: prop_types_default.a.oneOfType([ prop_types_default.a.func, prop_types_default.a.node ]),
        location: prop_types_default.a.object
    };
    Route_Route.contextTypes = {
        router: prop_types_default.a.shape({
            history: prop_types_default.a.object.isRequired,
            route: prop_types_default.a.object.isRequired,
            staticContext: prop_types_default.a.object
        })
    };
    Route_Route.childContextTypes = {
        router: prop_types_default.a.object.isRequired
    };
    var es_Route = Route_Route;
    var react_router_dom_es_Route = es_Route;
    var NavLink_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    function NavLink_objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    var NavLink_NavLink = function NavLink(_ref) {
        var to = _ref.to, exact = _ref.exact, strict = _ref.strict, location = _ref.location, activeClassName = _ref.activeClassName, className = _ref.className, activeStyle = _ref.activeStyle, style = _ref.style, getIsActive = _ref.isActive, ariaCurrent = _ref.ariaCurrent, rest = NavLink_objectWithoutProperties(_ref, [ "to", "exact", "strict", "location", "activeClassName", "className", "activeStyle", "style", "isActive", "ariaCurrent" ]);
        return react_default.a.createElement(react_router_dom_es_Route, {
            path: (typeof to === "undefined" ? "undefined" : _typeof(to)) === "object" ? to.pathname : to,
            exact,
            strict,
            location,
            children: function children(_ref2) {
                var location = _ref2.location, match = _ref2.match;
                var isActive = !!(getIsActive ? getIsActive(match, location) : match);
                return react_default.a.createElement(es_Link, NavLink_extends({
                    to,
                    className: isActive ? [ className, activeClassName ].filter(function(i) {
                        return i;
                    }).join(" ") : className,
                    style: isActive ? NavLink_extends({}, style, activeStyle) : style,
                    "aria-current": isActive && ariaCurrent
                }, rest));
            }
        });
    };
    NavLink_NavLink.propTypes = {
        to: es_Link.propTypes.to,
        exact: prop_types_default.a.bool,
        strict: prop_types_default.a.bool,
        location: prop_types_default.a.object,
        activeClassName: prop_types_default.a.string,
        className: prop_types_default.a.string,
        activeStyle: prop_types_default.a.object,
        style: prop_types_default.a.object,
        isActive: prop_types_default.a.func,
        ariaCurrent: prop_types_default.a.oneOf([ "page", "step", "location", "true" ])
    };
    NavLink_NavLink.defaultProps = {
        activeClassName: "active",
        ariaCurrent: "true"
    };
    var es_NavLink = NavLink_NavLink;
    function Prompt_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function Prompt_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function Prompt_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Prompt_Prompt = function(_React$Component) {
        Prompt_inherits(Prompt, _React$Component);
        function Prompt() {
            Prompt_classCallCheck(this, Prompt);
            return Prompt_possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }
        Prompt.prototype.enable = function enable(message) {
            if (this.unblock) this.unblock();
            this.unblock = this.context.router.history.block(message);
        };
        Prompt.prototype.disable = function disable() {
            if (this.unblock) {
                this.unblock();
                this.unblock = null;
            }
        };
        Prompt.prototype.componentWillMount = function componentWillMount() {
            invariant_browser_default()(this.context.router, "You should not use <Prompt> outside a <Router>");
            if (this.props.when) this.enable(this.props.message);
        };
        Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if (nextProps.when) {
                if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
            } else {
                this.disable();
            }
        };
        Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
            this.disable();
        };
        Prompt.prototype.render = function render() {
            return null;
        };
        return Prompt;
    }(react_default.a.Component);
    Prompt_Prompt.propTypes = {
        when: prop_types_default.a.bool,
        message: prop_types_default.a.oneOfType([ prop_types_default.a.func, prop_types_default.a.string ]).isRequired
    };
    Prompt_Prompt.defaultProps = {
        when: true
    };
    Prompt_Prompt.contextTypes = {
        router: prop_types_default.a.shape({
            history: prop_types_default.a.shape({
                block: prop_types_default.a.func.isRequired
            }).isRequired
        }).isRequired
    };
    var es_Prompt = Prompt_Prompt;
    var react_router_dom_es_Prompt = es_Prompt;
    var resolve_pathname = __webpack_require__(93);
    var value_equal = __webpack_require__(92);
    var addLeadingSlash = function addLeadingSlash(path) {
        return path.charAt(0) === "/" ? path : "/" + path;
    };
    var stripLeadingSlash = function stripLeadingSlash(path) {
        return path.charAt(0) === "/" ? path.substr(1) : path;
    };
    var hasBasename = function hasBasename(path, prefix) {
        return new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path);
    };
    var PathUtils_stripBasename = function stripBasename(path, prefix) {
        return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
    };
    var stripTrailingSlash = function stripTrailingSlash(path) {
        return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
    };
    var parsePath = function parsePath(path) {
        var pathname = path || "/";
        var search = "";
        var hash = "";
        var hashIndex = pathname.indexOf("#");
        if (hashIndex !== -1) {
            hash = pathname.substr(hashIndex);
            pathname = pathname.substr(0, hashIndex);
        }
        var searchIndex = pathname.indexOf("?");
        if (searchIndex !== -1) {
            search = pathname.substr(searchIndex);
            pathname = pathname.substr(0, searchIndex);
        }
        return {
            pathname,
            search: search === "?" ? "" : search,
            hash: hash === "#" ? "" : hash
        };
    };
    var createPath = function createPath(location) {
        var pathname = location.pathname, search = location.search, hash = location.hash;
        var path = pathname || "/";
        if (search && search !== "?") path += search.charAt(0) === "?" ? search : "?" + search;
        if (hash && hash !== "#") path += hash.charAt(0) === "#" ? hash : "#" + hash;
        return path;
    };
    var LocationUtils_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var LocationUtils_createLocation = function createLocation(path, state, key, currentLocation) {
        var location = void 0;
        if (typeof path === "string") {
            location = parsePath(path);
            location.state = state;
        } else {
            location = LocationUtils_extends({}, path);
            if (location.pathname === undefined) location.pathname = "";
            if (location.search) {
                if (location.search.charAt(0) !== "?") location.search = "?" + location.search;
            } else {
                location.search = "";
            }
            if (location.hash) {
                if (location.hash.charAt(0) !== "#") location.hash = "#" + location.hash;
            } else {
                location.hash = "";
            }
            if (state !== undefined && location.state === undefined) location.state = state;
        }
        try {
            location.pathname = decodeURI(location.pathname);
        } catch (e) {
            if (e instanceof URIError) {
                throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + "This is likely caused by an invalid percent-encoding.");
            } else {
                throw e;
            }
        }
        if (key) location.key = key;
        if (currentLocation) {
            if (!location.pathname) {
                location.pathname = currentLocation.pathname;
            } else if (location.pathname.charAt(0) !== "/") {
                location.pathname = Object(resolve_pathname["default"])(location.pathname, currentLocation.pathname);
            }
        } else {
            if (!location.pathname) {
                location.pathname = "/";
            }
        }
        return location;
    };
    var LocationUtils_locationsAreEqual = function locationsAreEqual(a, b) {
        return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal["default"])(a.state, b.state);
    };
    var createTransitionManager_createTransitionManager = function createTransitionManager() {
        var prompt = null;
        var setPrompt = function setPrompt(nextPrompt) {
            browser_default()(prompt == null, "A history supports only one prompt at a time");
            prompt = nextPrompt;
            return function() {
                if (prompt === nextPrompt) prompt = null;
            };
        };
        var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
            if (prompt != null) {
                var result = typeof prompt === "function" ? prompt(location, action) : prompt;
                if (typeof result === "string") {
                    if (typeof getUserConfirmation === "function") {
                        getUserConfirmation(result, callback);
                    } else {
                        browser_default()(false, "A history needs a getUserConfirmation function in order to use a prompt message");
                        callback(true);
                    }
                } else {
                    callback(result !== false);
                }
            } else {
                callback(true);
            }
        };
        var listeners = [];
        var appendListener = function appendListener(fn) {
            var isActive = true;
            var listener = function listener() {
                if (isActive) fn.apply(undefined, arguments);
            };
            listeners.push(listener);
            return function() {
                isActive = false;
                listeners = listeners.filter(function(item) {
                    return item !== listener;
                });
            };
        };
        var notifyListeners = function notifyListeners() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            listeners.forEach(function(listener) {
                return listener.apply(undefined, args);
            });
        };
        return {
            setPrompt,
            confirmTransitionTo,
            appendListener,
            notifyListeners
        };
    };
    var es_createTransitionManager = createTransitionManager_createTransitionManager;
    var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    var addEventListener = function addEventListener(node, event, listener) {
        return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent("on" + event, listener);
    };
    var removeEventListener = function removeEventListener(node, event, listener) {
        return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent("on" + event, listener);
    };
    var getConfirmation = function getConfirmation(message, callback) {
        return callback(window.confirm(message));
    };
    var supportsHistory = function supportsHistory() {
        var ua = window.navigator.userAgent;
        if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1) return false;
        return window.history && "pushState" in window.history;
    };
    var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
        return window.navigator.userAgent.indexOf("Trident") === -1;
    };
    var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
        return window.navigator.userAgent.indexOf("Firefox") === -1;
    };
    var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
        return event.state === undefined && navigator.userAgent.indexOf("CriOS") === -1;
    };
    var createBrowserHistory_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var createBrowserHistory_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var PopStateEvent = "popstate";
    var HashChangeEvent = "hashchange";
    var getHistoryState = function getHistoryState() {
        try {
            return window.history.state || {};
        } catch (e) {
            return {};
        }
    };
    var createBrowserHistory_createBrowserHistory = function createBrowserHistory() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        invariant_browser_default()(canUseDOM, "Browser history needs a DOM");
        var globalHistory = window.history;
        var canUseHistory = supportsHistory();
        var needsHashChangeListener = !supportsPopStateOnHashChange();
        var _props$forceRefresh = props.forceRefresh, forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm, _props$keyLength = props.keyLength, keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;
        var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
        var getDOMLocation = function getDOMLocation(historyState) {
            var _ref = historyState || {}, key = _ref.key, state = _ref.state;
            var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
            var path = pathname + search + hash;
            browser_default()(!basename || hasBasename(path, basename), "You are attempting to use a basename on a page whose URL path does not begin " + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
            if (basename) path = PathUtils_stripBasename(path, basename);
            return LocationUtils_createLocation(path, state, key);
        };
        var createKey = function createKey() {
            return Math.random().toString(36).substr(2, keyLength);
        };
        var transitionManager = es_createTransitionManager();
        var setState = function setState(nextState) {
            createBrowserHistory_extends(history, nextState);
            history.length = globalHistory.length;
            transitionManager.notifyListeners(history.location, history.action);
        };
        var handlePopState = function handlePopState(event) {
            if (isExtraneousPopstateEvent(event)) return;
            handlePop(getDOMLocation(event.state));
        };
        var handleHashChange = function handleHashChange() {
            handlePop(getDOMLocation(getHistoryState()));
        };
        var forceNextPop = false;
        var handlePop = function handlePop(location) {
            if (forceNextPop) {
                forceNextPop = false;
                setState();
            } else {
                var action = "POP";
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        setState({
                            action,
                            location
                        });
                    } else {
                        revertPop(location);
                    }
                });
            }
        };
        var revertPop = function revertPop(fromLocation) {
            var toLocation = history.location;
            var toIndex = allKeys.indexOf(toLocation.key);
            if (toIndex === -1) toIndex = 0;
            var fromIndex = allKeys.indexOf(fromLocation.key);
            if (fromIndex === -1) fromIndex = 0;
            var delta = toIndex - fromIndex;
            if (delta) {
                forceNextPop = true;
                go(delta);
            }
        };
        var initialLocation = getDOMLocation(getHistoryState());
        var allKeys = [ initialLocation.key ];
        var createHref = function createHref(location) {
            return basename + createPath(location);
        };
        var push = function push(path, state) {
            browser_default()(!((typeof path === "undefined" ? "undefined" : createBrowserHistory_typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to push when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "PUSH";
            var location = LocationUtils_createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var href = createHref(location);
                var key = location.key, state = location.state;
                if (canUseHistory) {
                    globalHistory.pushState({
                        key,
                        state
                    }, null, href);
                    if (forceRefresh) {
                        window.location.href = href;
                    } else {
                        var prevIndex = allKeys.indexOf(history.location.key);
                        var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                        nextKeys.push(location.key);
                        allKeys = nextKeys;
                        setState({
                            action,
                            location
                        });
                    }
                } else {
                    browser_default()(state === undefined, "Browser history cannot push state in browsers that do not support HTML5 history");
                    window.location.href = href;
                }
            });
        };
        var replace = function replace(path, state) {
            browser_default()(!((typeof path === "undefined" ? "undefined" : createBrowserHistory_typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to replace when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "REPLACE";
            var location = LocationUtils_createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var href = createHref(location);
                var key = location.key, state = location.state;
                if (canUseHistory) {
                    globalHistory.replaceState({
                        key,
                        state
                    }, null, href);
                    if (forceRefresh) {
                        window.location.replace(href);
                    } else {
                        var prevIndex = allKeys.indexOf(history.location.key);
                        if (prevIndex !== -1) allKeys[prevIndex] = location.key;
                        setState({
                            action,
                            location
                        });
                    }
                } else {
                    browser_default()(state === undefined, "Browser history cannot replace state in browsers that do not support HTML5 history");
                    window.location.replace(href);
                }
            });
        };
        var go = function go(n) {
            globalHistory.go(n);
        };
        var goBack = function goBack() {
            return go(-1);
        };
        var goForward = function goForward() {
            return go(1);
        };
        var listenerCount = 0;
        var checkDOMListeners = function checkDOMListeners(delta) {
            listenerCount += delta;
            if (listenerCount === 1) {
                addEventListener(window, PopStateEvent, handlePopState);
                if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);
            } else if (listenerCount === 0) {
                removeEventListener(window, PopStateEvent, handlePopState);
                if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);
            }
        };
        var isBlocked = false;
        var block = function block() {
            var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var unblock = transitionManager.setPrompt(prompt);
            if (!isBlocked) {
                checkDOMListeners(1);
                isBlocked = true;
            }
            return function() {
                if (isBlocked) {
                    isBlocked = false;
                    checkDOMListeners(-1);
                }
                return unblock();
            };
        };
        var listen = function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            checkDOMListeners(1);
            return function() {
                checkDOMListeners(-1);
                unlisten();
            };
        };
        var history = {
            length: globalHistory.length,
            action: "POP",
            location: initialLocation,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            block,
            listen
        };
        return history;
    };
    var es_createBrowserHistory = createBrowserHistory_createBrowserHistory;
    var createHashHistory_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var createHashHistory_HashChangeEvent = "hashchange";
    var HashPathCoders = {
        hashbang: {
            encodePath: function encodePath(path) {
                return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
            },
            decodePath: function decodePath(path) {
                return path.charAt(0) === "!" ? path.substr(1) : path;
            }
        },
        noslash: {
            encodePath: stripLeadingSlash,
            decodePath: addLeadingSlash
        },
        slash: {
            encodePath: addLeadingSlash,
            decodePath: addLeadingSlash
        }
    };
    var getHashPath = function getHashPath() {
        var href = window.location.href;
        var hashIndex = href.indexOf("#");
        return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
    };
    var pushHashPath = function pushHashPath(path) {
        return window.location.hash = path;
    };
    var replaceHashPath = function replaceHashPath(path) {
        var hashIndex = window.location.href.indexOf("#");
        window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + "#" + path);
    };
    var createHashHistory_createHashHistory = function createHashHistory() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        invariant_browser_default()(canUseDOM, "Hash history needs a DOM");
        var globalHistory = window.history;
        var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
        var _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm, _props$hashType = props.hashType, hashType = _props$hashType === undefined ? "slash" : _props$hashType;
        var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
        var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath;
        var getDOMLocation = function getDOMLocation() {
            var path = decodePath(getHashPath());
            browser_default()(!basename || hasBasename(path, basename), "You are attempting to use a basename on a page whose URL path does not begin " + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
            if (basename) path = PathUtils_stripBasename(path, basename);
            return LocationUtils_createLocation(path);
        };
        var transitionManager = es_createTransitionManager();
        var setState = function setState(nextState) {
            createHashHistory_extends(history, nextState);
            history.length = globalHistory.length;
            transitionManager.notifyListeners(history.location, history.action);
        };
        var forceNextPop = false;
        var ignorePath = null;
        var handleHashChange = function handleHashChange() {
            var path = getHashPath();
            var encodedPath = encodePath(path);
            if (path !== encodedPath) {
                replaceHashPath(encodedPath);
            } else {
                var location = getDOMLocation();
                var prevLocation = history.location;
                if (!forceNextPop && LocationUtils_locationsAreEqual(prevLocation, location)) return;
                if (ignorePath === createPath(location)) return;
                ignorePath = null;
                handlePop(location);
            }
        };
        var handlePop = function handlePop(location) {
            if (forceNextPop) {
                forceNextPop = false;
                setState();
            } else {
                var action = "POP";
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        setState({
                            action,
                            location
                        });
                    } else {
                        revertPop(location);
                    }
                });
            }
        };
        var revertPop = function revertPop(fromLocation) {
            var toLocation = history.location;
            var toIndex = allPaths.lastIndexOf(createPath(toLocation));
            if (toIndex === -1) toIndex = 0;
            var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
            if (fromIndex === -1) fromIndex = 0;
            var delta = toIndex - fromIndex;
            if (delta) {
                forceNextPop = true;
                go(delta);
            }
        };
        var path = getHashPath();
        var encodedPath = encodePath(path);
        if (path !== encodedPath) replaceHashPath(encodedPath);
        var initialLocation = getDOMLocation();
        var allPaths = [ createPath(initialLocation) ];
        var createHref = function createHref(location) {
            return "#" + encodePath(basename + createPath(location));
        };
        var push = function push(path, state) {
            browser_default()(state === undefined, "Hash history cannot push state; it is ignored");
            var action = "PUSH";
            var location = LocationUtils_createLocation(path, undefined, undefined, history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var path = createPath(location);
                var encodedPath = encodePath(basename + path);
                var hashChanged = getHashPath() !== encodedPath;
                if (hashChanged) {
                    ignorePath = path;
                    pushHashPath(encodedPath);
                    var prevIndex = allPaths.lastIndexOf(createPath(history.location));
                    var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                    nextPaths.push(path);
                    allPaths = nextPaths;
                    setState({
                        action,
                        location
                    });
                } else {
                    browser_default()(false, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack");
                    setState();
                }
            });
        };
        var replace = function replace(path, state) {
            browser_default()(state === undefined, "Hash history cannot replace state; it is ignored");
            var action = "REPLACE";
            var location = LocationUtils_createLocation(path, undefined, undefined, history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var path = createPath(location);
                var encodedPath = encodePath(basename + path);
                var hashChanged = getHashPath() !== encodedPath;
                if (hashChanged) {
                    ignorePath = path;
                    replaceHashPath(encodedPath);
                }
                var prevIndex = allPaths.indexOf(createPath(history.location));
                if (prevIndex !== -1) allPaths[prevIndex] = path;
                setState({
                    action,
                    location
                });
            });
        };
        var go = function go(n) {
            browser_default()(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser");
            globalHistory.go(n);
        };
        var goBack = function goBack() {
            return go(-1);
        };
        var goForward = function goForward() {
            return go(1);
        };
        var listenerCount = 0;
        var checkDOMListeners = function checkDOMListeners(delta) {
            listenerCount += delta;
            if (listenerCount === 1) {
                addEventListener(window, createHashHistory_HashChangeEvent, handleHashChange);
            } else if (listenerCount === 0) {
                removeEventListener(window, createHashHistory_HashChangeEvent, handleHashChange);
            }
        };
        var isBlocked = false;
        var block = function block() {
            var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var unblock = transitionManager.setPrompt(prompt);
            if (!isBlocked) {
                checkDOMListeners(1);
                isBlocked = true;
            }
            return function() {
                if (isBlocked) {
                    isBlocked = false;
                    checkDOMListeners(-1);
                }
                return unblock();
            };
        };
        var listen = function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            checkDOMListeners(1);
            return function() {
                checkDOMListeners(-1);
                unlisten();
            };
        };
        var history = {
            length: globalHistory.length,
            action: "POP",
            location: initialLocation,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            block,
            listen
        };
        return history;
    };
    var es_createHashHistory = createHashHistory_createHashHistory;
    var createMemoryHistory_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var createMemoryHistory_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var clamp = function clamp(n, lowerBound, upperBound) {
        return Math.min(Math.max(n, lowerBound), upperBound);
    };
    var createMemoryHistory_createMemoryHistory = function createMemoryHistory() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var getUserConfirmation = props.getUserConfirmation, _props$initialEntries = props.initialEntries, initialEntries = _props$initialEntries === undefined ? [ "/" ] : _props$initialEntries, _props$initialIndex = props.initialIndex, initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex, _props$keyLength = props.keyLength, keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;
        var transitionManager = es_createTransitionManager();
        var setState = function setState(nextState) {
            createMemoryHistory_extends(history, nextState);
            history.length = history.entries.length;
            transitionManager.notifyListeners(history.location, history.action);
        };
        var createKey = function createKey() {
            return Math.random().toString(36).substr(2, keyLength);
        };
        var index = clamp(initialIndex, 0, initialEntries.length - 1);
        var entries = initialEntries.map(function(entry) {
            return typeof entry === "string" ? LocationUtils_createLocation(entry, undefined, createKey()) : LocationUtils_createLocation(entry, undefined, entry.key || createKey());
        });
        var createHref = createPath;
        var push = function push(path, state) {
            browser_default()(!((typeof path === "undefined" ? "undefined" : createMemoryHistory_typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to push when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "PUSH";
            var location = LocationUtils_createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var prevIndex = history.index;
                var nextIndex = prevIndex + 1;
                var nextEntries = history.entries.slice(0);
                if (nextEntries.length > nextIndex) {
                    nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
                } else {
                    nextEntries.push(location);
                }
                setState({
                    action,
                    location,
                    index: nextIndex,
                    entries: nextEntries
                });
            });
        };
        var replace = function replace(path, state) {
            browser_default()(!((typeof path === "undefined" ? "undefined" : createMemoryHistory_typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to replace when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "REPLACE";
            var location = LocationUtils_createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                history.entries[history.index] = location;
                setState({
                    action,
                    location
                });
            });
        };
        var go = function go(n) {
            var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
            var action = "POP";
            var location = history.entries[nextIndex];
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (ok) {
                    setState({
                        action,
                        location,
                        index: nextIndex
                    });
                } else {
                    setState();
                }
            });
        };
        var goBack = function goBack() {
            return go(-1);
        };
        var goForward = function goForward() {
            return go(1);
        };
        var canGo = function canGo(n) {
            var nextIndex = history.index + n;
            return nextIndex >= 0 && nextIndex < history.entries.length;
        };
        var block = function block() {
            var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            return transitionManager.setPrompt(prompt);
        };
        var listen = function listen(listener) {
            return transitionManager.appendListener(listener);
        };
        var history = {
            length: entries.length,
            action: "POP",
            location: entries[index],
            index,
            entries,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            canGo,
            block,
            listen
        };
        return history;
    };
    var es_createMemoryHistory = createMemoryHistory_createMemoryHistory;
    function Redirect_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function Redirect_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function Redirect_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Redirect_Redirect = function(_React$Component) {
        Redirect_inherits(Redirect, _React$Component);
        function Redirect() {
            Redirect_classCallCheck(this, Redirect);
            return Redirect_possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }
        Redirect.prototype.isStatic = function isStatic() {
            return this.context.router && this.context.router.staticContext;
        };
        Redirect.prototype.componentWillMount = function componentWillMount() {
            invariant_browser_default()(this.context.router, "You should not use <Redirect> outside a <Router>");
            if (this.isStatic()) this.perform();
        };
        Redirect.prototype.componentDidMount = function componentDidMount() {
            if (!this.isStatic()) this.perform();
        };
        Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
            var prevTo = LocationUtils_createLocation(prevProps.to);
            var nextTo = LocationUtils_createLocation(this.props.to);
            if (LocationUtils_locationsAreEqual(prevTo, nextTo)) {
                browser_default()(false, "You tried to redirect to the same route you're currently on: " + ('"' + nextTo.pathname + nextTo.search + '"'));
                return;
            }
            this.perform();
        };
        Redirect.prototype.perform = function perform() {
            var history = this.context.router.history;
            var _props = this.props, push = _props.push, to = _props.to;
            if (push) {
                history.push(to);
            } else {
                history.replace(to);
            }
        };
        Redirect.prototype.render = function render() {
            return null;
        };
        return Redirect;
    }(react_default.a.Component);
    Redirect_Redirect.propTypes = {
        push: prop_types_default.a.bool,
        from: prop_types_default.a.string,
        to: prop_types_default.a.oneOfType([ prop_types_default.a.string, prop_types_default.a.object ]).isRequired
    };
    Redirect_Redirect.defaultProps = {
        push: false
    };
    Redirect_Redirect.contextTypes = {
        router: prop_types_default.a.shape({
            history: prop_types_default.a.shape({
                push: prop_types_default.a.func.isRequired,
                replace: prop_types_default.a.func.isRequired
            }).isRequired,
            staticContext: prop_types_default.a.object
        }).isRequired
    };
    var es_Redirect = Redirect_Redirect;
    var react_router_dom_es_Redirect = es_Redirect;
    var PathUtils = __webpack_require__(20);
    var StaticRouter_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function StaticRouter_objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    function StaticRouter_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function StaticRouter_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function StaticRouter_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var normalizeLocation = function normalizeLocation(object) {
        var _object$pathname = object.pathname, pathname = _object$pathname === undefined ? "/" : _object$pathname, _object$search = object.search, search = _object$search === undefined ? "" : _object$search, _object$hash = object.hash, hash = _object$hash === undefined ? "" : _object$hash;
        return {
            pathname,
            search: search === "?" ? "" : search,
            hash: hash === "#" ? "" : hash
        };
    };
    var StaticRouter_addBasename = function addBasename(basename, location) {
        if (!basename) return location;
        return StaticRouter_extends({}, location, {
            pathname: Object(PathUtils["addLeadingSlash"])(basename) + location.pathname
        });
    };
    var StaticRouter_stripBasename = function stripBasename(basename, location) {
        if (!basename) return location;
        var base = Object(PathUtils["addLeadingSlash"])(basename);
        if (location.pathname.indexOf(base) !== 0) return location;
        return StaticRouter_extends({}, location, {
            pathname: location.pathname.substr(base.length)
        });
    };
    var StaticRouter_createLocation = function createLocation(location) {
        return typeof location === "string" ? Object(PathUtils["parsePath"])(location) : normalizeLocation(location);
    };
    var StaticRouter_createURL = function createURL(location) {
        return typeof location === "string" ? location : Object(PathUtils["createPath"])(location);
    };
    var StaticRouter_staticHandler = function staticHandler(methodName) {
        return function() {
            invariant_browser_default()(false, "You cannot %s with <StaticRouter>", methodName);
        };
    };
    var noop = function noop() {};
    var StaticRouter_StaticRouter = function(_React$Component) {
        StaticRouter_inherits(StaticRouter, _React$Component);
        function StaticRouter() {
            var _temp, _this, _ret;
            StaticRouter_classCallCheck(this, StaticRouter);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = StaticRouter_possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
            _this), _this.createHref = function(path) {
                return Object(PathUtils["addLeadingSlash"])(_this.props.basename + StaticRouter_createURL(path));
            }, _this.handlePush = function(location) {
                var _this$props = _this.props, basename = _this$props.basename, context = _this$props.context;
                context.action = "PUSH";
                context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
                context.url = StaticRouter_createURL(context.location);
            }, _this.handleReplace = function(location) {
                var _this$props2 = _this.props, basename = _this$props2.basename, context = _this$props2.context;
                context.action = "REPLACE";
                context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
                context.url = StaticRouter_createURL(context.location);
            }, _this.handleListen = function() {
                return noop;
            }, _this.handleBlock = function() {
                return noop;
            }, _temp), StaticRouter_possibleConstructorReturn(_this, _ret);
        }
        StaticRouter.prototype.getChildContext = function getChildContext() {
            return {
                router: {
                    staticContext: this.props.context
                }
            };
        };
        StaticRouter.prototype.componentWillMount = function componentWillMount() {
            browser_default()(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.");
        };
        StaticRouter.prototype.render = function render() {
            var _props = this.props, basename = _props.basename, context = _props.context, location = _props.location, props = StaticRouter_objectWithoutProperties(_props, [ "basename", "context", "location" ]);
            var history = {
                createHref: this.createHref,
                action: "POP",
                location: StaticRouter_stripBasename(basename, StaticRouter_createLocation(location)),
                push: this.handlePush,
                replace: this.handleReplace,
                go: StaticRouter_staticHandler("go"),
                goBack: StaticRouter_staticHandler("goBack"),
                goForward: StaticRouter_staticHandler("goForward"),
                listen: this.handleListen,
                block: this.handleBlock
            };
            return react_default.a.createElement(es_Router, StaticRouter_extends({}, props, {
                history
            }));
        };
        return StaticRouter;
    }(react_default.a.Component);
    StaticRouter_StaticRouter.propTypes = {
        basename: prop_types_default.a.string,
        context: prop_types_default.a.object.isRequired,
        location: prop_types_default.a.oneOfType([ prop_types_default.a.string, prop_types_default.a.object ])
    };
    StaticRouter_StaticRouter.defaultProps = {
        basename: "",
        location: "/"
    };
    StaticRouter_StaticRouter.childContextTypes = {
        router: prop_types_default.a.object.isRequired
    };
    var es_StaticRouter = StaticRouter_StaticRouter;
    var react_router_dom_es_StaticRouter = es_StaticRouter;
    function Switch_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function Switch_possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function Switch_inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Switch_Switch = function(_React$Component) {
        Switch_inherits(Switch, _React$Component);
        function Switch() {
            Switch_classCallCheck(this, Switch);
            return Switch_possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }
        Switch.prototype.componentWillMount = function componentWillMount() {
            invariant_browser_default()(this.context.router, "You should not use <Switch> outside a <Router>");
        };
        Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            browser_default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');
            browser_default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
        };
        Switch.prototype.render = function render() {
            var route = this.context.router.route;
            var children = this.props.children;
            var location = this.props.location || route.location;
            var match = void 0, child = void 0;
            react_default.a.Children.forEach(children, function(element) {
                if (!react_default.a.isValidElement(element)) return;
                var _element$props = element.props, pathProp = _element$props.path, exact = _element$props.exact, strict = _element$props.strict, sensitive = _element$props.sensitive, from = _element$props.from;
                var path = pathProp || from;
                if (match == null) {
                    child = element;
                    match = path ? es_matchPath(location.pathname, {
                        path,
                        exact,
                        strict,
                        sensitive
                    }) : route.match;
                }
            });
            return match ? react_default.a.cloneElement(child, {
                location,
                computedMatch: match
            }) : null;
        };
        return Switch;
    }(react_default.a.Component);
    Switch_Switch.contextTypes = {
        router: prop_types_default.a.shape({
            route: prop_types_default.a.object.isRequired
        }).isRequired
    };
    Switch_Switch.propTypes = {
        children: prop_types_default.a.node,
        location: prop_types_default.a.object
    };
    var es_Switch = Switch_Switch;
    var react_router_dom_es_Switch = es_Switch;
    var react_router_dom_es_matchPath = es_matchPath;
    var hoist_non_react_statics = __webpack_require__(65);
    var hoist_non_react_statics_default = __webpack_require__.n(hoist_non_react_statics);
    var withRouter_extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function withRouter_objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
        }
        return target;
    }
    var withRouter_withRouter = function withRouter(Component) {
        var C = function C(props) {
            var wrappedComponentRef = props.wrappedComponentRef, remainingProps = withRouter_objectWithoutProperties(props, [ "wrappedComponentRef" ]);
            return react_default.a.createElement(es_Route, {
                render: function render(routeComponentProps) {
                    return react_default.a.createElement(Component, withRouter_extends({}, remainingProps, routeComponentProps, {
                        ref: wrappedComponentRef
                    }));
                }
            });
        };
        C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
        C.WrappedComponent = Component;
        C.propTypes = {
            wrappedComponentRef: prop_types_default.a.func
        };
        return hoist_non_react_statics_default()(C, Component);
    };
    var es_withRouter = withRouter_withRouter;
    var react_router_dom_es_withRouter = es_withRouter;
    __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() {
        return es_BrowserRouter;
    });
    __webpack_require__.d(__webpack_exports__, "HashRouter", function() {
        return es_HashRouter;
    });
    __webpack_require__.d(__webpack_exports__, "Link", function() {
        return es_Link;
    });
    __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() {
        return react_router_dom_es_MemoryRouter;
    });
    __webpack_require__.d(__webpack_exports__, "NavLink", function() {
        return es_NavLink;
    });
    __webpack_require__.d(__webpack_exports__, "Prompt", function() {
        return react_router_dom_es_Prompt;
    });
    __webpack_require__.d(__webpack_exports__, "Redirect", function() {
        return react_router_dom_es_Redirect;
    });
    __webpack_require__.d(__webpack_exports__, "Route", function() {
        return react_router_dom_es_Route;
    });
    __webpack_require__.d(__webpack_exports__, "Router", function() {
        return react_router_dom_es_Router;
    });
    __webpack_require__.d(__webpack_exports__, "StaticRouter", function() {
        return react_router_dom_es_StaticRouter;
    });
    __webpack_require__.d(__webpack_exports__, "Switch", function() {
        return react_router_dom_es_Switch;
    });
    __webpack_require__.d(__webpack_exports__, "matchPath", function() {
        return react_router_dom_es_matchPath;
    });
    __webpack_require__.d(__webpack_exports__, "withRouter", function() {
        return react_router_dom_es_withRouter;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
        }
        return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
        var t = crcTable, end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
    }
    module.exports = crc32;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === "%%") return "%";
                if (i >= len) return x;
                switch (x) {
                  case "%s":
                    return String(args[i++]);

                  case "%d":
                    return Number(args[i++]);

                  case "%j":
                    try {
                        return JSON.stringify(args[i++]);
                    } catch (_) {
                        return "[Circular]";
                    }

                  default:
                    return x;
                }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += " " + x;
                } else {
                    str += " " + inspect(x);
                }
            }
            return str;
        };
        exports.deprecate = function(fn, msg) {
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }
            if (process.noDeprecation === true) {
                return fn;
            }
            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }
            return deprecated;
        };
        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error("%s %d: %s", set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };
        function inspect(obj, opts) {
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                ctx.showHidden = opts;
            } else if (opts) {
                exports._extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;
        inspect.colors = {
            bold: [ 1, 22 ],
            italic: [ 3, 23 ],
            underline: [ 4, 24 ],
            inverse: [ 7, 27 ],
            white: [ 37, 39 ],
            grey: [ 90, 39 ],
            black: [ 30, 39 ],
            blue: [ 34, 39 ],
            cyan: [ 36, 39 ],
            green: [ 32, 39 ],
            magenta: [ 35, 39 ],
            red: [ 31, 39 ],
            yellow: [ 33, 39 ]
        };
        inspect.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        };
        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
                return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
            } else {
                return str;
            }
        }
        function stylizeNoColor(str, styleType) {
            return str;
        }
        function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
                hash[val] = true;
            });
            return hash;
        }
        function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
            }
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }
            var base = "", array = false, braces = [ "{", "}" ];
            if (isArray(value)) {
                array = true;
                braces = [ "[", "]" ];
            }
            if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
            }
            if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
                base = " " + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                    return ctx.stylize("[Object]", "special");
                }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
        }
        function formatPrimitive(ctx, value) {
            if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
            }
            if (isNumber(value)) return ctx.stylize("" + value, "number");
            if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
            if (isNull(value)) return ctx.stylize("null", "null");
        }
        function formatError(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                } else {
                    output.push("");
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
            });
            return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
            };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                    str = ctx.stylize("[Getter]", "special");
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize("[Setter]", "special");
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                        if (array) {
                            str = str.split("\n").map(function(line) {
                                return "  " + line;
                            }).join("\n").substr(2);
                        } else {
                            str = "\n" + str.split("\n").map(function(line) {
                                return "   " + line;
                            }).join("\n");
                        }
                    }
                } else {
                    str = ctx.stylize("[Circular]", "special");
                }
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, "name");
                } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                }
            }
            return name + ": " + str;
        }
        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            }
            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
        }
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;
        function isBoolean(arg) {
            return typeof arg === "boolean";
        }
        exports.isBoolean = isBoolean;
        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;
        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
            return typeof arg === "number";
        }
        exports.isNumber = isNumber;
        function isString(arg) {
            return typeof arg === "string";
        }
        exports.isString = isString;
        function isSymbol(arg) {
            return typeof arg === "symbol";
        }
        exports.isSymbol = isSymbol;
        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;
        function isRegExp(re) {
            return isObject(re) && objectToString(re) === "[object RegExp]";
        }
        exports.isRegExp = isRegExp;
        function isObject(arg) {
            return typeof arg === "object" && arg !== null;
        }
        exports.isObject = isObject;
        function isDate(d) {
            return isObject(d) && objectToString(d) === "[object Date]";
        }
        exports.isDate = isDate;
        function isError(e) {
            return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
        }
        exports.isError = isError;
        function isFunction(arg) {
            return typeof arg === "function";
        }
        exports.isFunction = isFunction;
        function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
        }
        exports.isPrimitive = isPrimitive;
        exports.isBuffer = __webpack_require__(197);
        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }
        function pad(n) {
            return n < 10 ? "0" + n.toString(10) : n.toString(10);
        }
        var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
        function timestamp() {
            var d = new Date();
            var time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":");
            return [ d.getDate(), months[d.getMonth()], time ].join(" ");
        }
        exports.log = function() {
            console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
        };
        exports.inherits = __webpack_require__(196);
        exports._extend = function(origin, add) {
            if (!add || !isObject(add)) return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
    }).call(this, __webpack_require__(12), __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(global) {
        function compare(a, b) {
            if (a === b) {
                return 0;
            }
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                }
            }
            if (x < y) {
                return -1;
            }
            if (y < x) {
                return 1;
            }
            return 0;
        }
        function isBuffer(b) {
            if (global.Buffer && typeof global.Buffer.isBuffer === "function") {
                return global.Buffer.isBuffer(b);
            }
            return !!(b != null && b._isBuffer);
        }
        var util = __webpack_require__(99);
        var hasOwn = Object.prototype.hasOwnProperty;
        var pSlice = Array.prototype.slice;
        var functionsHaveNames = function() {
            return function foo() {}.name === "foo";
        }();
        function pToString(obj) {
            return Object.prototype.toString.call(obj);
        }
        function isView(arrbuf) {
            if (isBuffer(arrbuf)) {
                return false;
            }
            if (typeof global.ArrayBuffer !== "function") {
                return false;
            }
            if (typeof ArrayBuffer.isView === "function") {
                return ArrayBuffer.isView(arrbuf);
            }
            if (!arrbuf) {
                return false;
            }
            if (arrbuf instanceof DataView) {
                return true;
            }
            if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                return true;
            }
            return false;
        }
        var assert = module.exports = ok;
        var regex = /\s*function\s+([^\(\s]*)\s*/;
        function getName(func) {
            if (!util.isFunction(func)) {
                return;
            }
            if (functionsHaveNames) {
                return func.name;
            }
            var str = func.toString();
            var match = str.match(regex);
            return match && match[1];
        }
        assert.AssertionError = function AssertionError(options) {
            this.name = "AssertionError";
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
            } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
            }
            var stackStartFunction = options.stackStartFunction || fail;
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
            } else {
                var err = new Error();
                if (err.stack) {
                    var out = err.stack;
                    var fn_name = getName(stackStartFunction);
                    var idx = out.indexOf("\n" + fn_name);
                    if (idx >= 0) {
                        var next_line = out.indexOf("\n", idx + 1);
                        out = out.substring(next_line + 1);
                    }
                    this.stack = out;
                }
            }
        };
        util.inherits(assert.AssertionError, Error);
        function truncate(s, n) {
            if (typeof s === "string") {
                return s.length < n ? s : s.slice(0, n);
            } else {
                return s;
            }
        }
        function inspect(something) {
            if (functionsHaveNames || !util.isFunction(something)) {
                return util.inspect(something);
            }
            var rawname = getName(something);
            var name = rawname ? ": " + rawname : "";
            return "[Function" + name + "]";
        }
        function getMessage(self) {
            return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
        }
        function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
                message,
                actual,
                expected,
                operator,
                stackStartFunction
            });
        }
        assert.fail = fail;
        function ok(value, message) {
            if (!value) fail(value, true, message, "==", assert.ok);
        }
        assert.ok = ok;
        assert.equal = function equal(actual, expected, message) {
            if (actual != expected) fail(actual, expected, message, "==", assert.equal);
        };
        assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
                fail(actual, expected, message, "!=", assert.notEqual);
            }
        };
        assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "deepEqual", assert.deepEqual);
            }
        };
        assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
            }
        };
        function _deepEqual(actual, expected, strict, memos) {
            if (actual === expected) {
                return true;
            } else if (isBuffer(actual) && isBuffer(expected)) {
                return compare(actual, expected) === 0;
            } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
            } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
                return strict ? actual === expected : actual == expected;
            } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
            } else if (isBuffer(actual) !== isBuffer(expected)) {
                return false;
            } else {
                memos = memos || {
                    actual: [],
                    expected: []
                };
                var actualIndex = memos.actual.indexOf(actual);
                if (actualIndex !== -1) {
                    if (actualIndex === memos.expected.indexOf(expected)) {
                        return true;
                    }
                }
                memos.actual.push(actual);
                memos.expected.push(expected);
                return objEquiv(actual, expected, strict, memos);
            }
        }
        function isArguments(object) {
            return Object.prototype.toString.call(object) == "[object Arguments]";
        }
        function objEquiv(a, b, strict, actualVisitedObjects) {
            if (a === null || a === undefined || b === null || b === undefined) return false;
            if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
            if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
            var aIsArgs = isArguments(a);
            var bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
            if (aIsArgs) {
                a = pSlice.call(a);
                b = pSlice.call(b);
                return _deepEqual(a, b, strict);
            }
            var ka = objectKeys(a);
            var kb = objectKeys(b);
            var key, i;
            if (ka.length !== kb.length) return false;
            ka.sort();
            kb.sort();
            for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] !== kb[i]) return false;
            }
            for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
            }
            return true;
        }
        assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
            }
        };
        assert.notDeepStrictEqual = notDeepStrictEqual;
        function notDeepStrictEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
            }
        }
        assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
                fail(actual, expected, message, "===", assert.strictEqual);
            }
        };
        assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
                fail(actual, expected, message, "!==", assert.notStrictEqual);
            }
        };
        function expectedException(actual, expected) {
            if (!actual || !expected) {
                return false;
            }
            if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                return expected.test(actual);
            }
            try {
                if (actual instanceof expected) {
                    return true;
                }
            } catch (e) {}
            if (Error.isPrototypeOf(expected)) {
                return false;
            }
            return expected.call({}, actual) === true;
        }
        function _tryBlock(block) {
            var error;
            try {
                block();
            } catch (e) {
                error = e;
            }
            return error;
        }
        function _throws(shouldThrow, block, expected, message) {
            var actual;
            if (typeof block !== "function") {
                throw new TypeError('"block" argument must be a function');
            }
            if (typeof expected === "string") {
                message = expected;
                expected = null;
            }
            actual = _tryBlock(block);
            message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
            if (shouldThrow && !actual) {
                fail(actual, expected, "Missing expected exception" + message);
            }
            var userProvidedMessage = typeof message === "string";
            var isUnwantedException = !shouldThrow && util.isError(actual);
            var isUnexpectedException = !shouldThrow && actual && !expected;
            if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                fail(actual, expected, "Got unwanted exception" + message);
            }
            if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                throw actual;
            }
        }
        assert.throws = function(block, error, message) {
            _throws(true, block, error, message);
        };
        assert.doesNotThrow = function(block, error, message) {
            _throws(false, block, error, message);
        };
        assert.ifError = function(err) {
            if (err) throw err;
        };
        var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) {
                if (hasOwn.call(obj, key)) keys.push(key);
            }
            return keys;
        };
    }).call(this, __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.uportQRDisplay = exports.getQRDataURI = exports.openQr = exports.closeQr = undefined;
    var _qrImage = __webpack_require__(205);
    var _qrImage2 = _interopRequireDefault(_qrImage);
    var _assets = __webpack_require__(184);
    var _assets2 = _interopRequireDefault(_assets);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var getQRDataURI = function getQRDataURI(data) {
        var pngBuffer = _qrImage2.default.imageSync(data, {
            type: "png"
        });
        return "data:image/png;charset=utf-8;base64, " + pngBuffer.toString("base64");
    };
    var openQr = function openQr(data, cancel, appName, introModal) {
        var wrapper = document.createElement("div");
        wrapper.setAttribute("id", "uport-wrapper");
        wrapper.innerHTML = introModal ? introModalDisplay(appName) : uportQRDisplay({
            qrImageUri: getQRDataURI(data),
            cancel
        });
        var cancelClick = function cancelClick(event) {
            document.getElementById("uport-qr-text").innerHTML = "Cancelling";
            cancel();
        };
        var uportTransition = function uportTransition(event) {
            wrapper.innerHTML = uportQRDisplay({
                qrImageUri: getQRDataURI(data),
                cancel
            });
            document.getElementById("uport-qr-cancel").addEventListener("click", cancelClick);
        };
        document.body.appendChild(wrapper);
        document.getElementById("uport-qr-cancel").addEventListener("click", cancelClick);
        if (introModal) {
            document.getElementById("uport-continue-btn").addEventListener("click", uportTransition);
        }
    };
    var closeQr = function closeQr() {
        var uportWrapper = document.getElementById("uport-wrapper");
        document.body.removeChild(uportWrapper);
    };
    var introModalDisplay = function introModalDisplay(appName) {
        var content = '\n    <div style="' + uportModalIntroWrapper + '">\n      <div>\n        <p id="uport-qr-text" style="' + uportQRTextWithAppName + '">';
        if (appName && appName !== "uport-connect-app") {
            content += '\n              <span>Login Into</span>\n              <span> </span>\n              <span style="' + uportAppName + '">' + appName + "</span>";
        } else {
            content += "<span>Login</span>";
        }
        content += '\n            </p>\n          </div>\n        <div id="uport-continue-btn" style="' + uportModalContinueBtn + '">\n          <span style="' + uportModalLogo + '">' + _assets2.default.logo + '</span>\n          <span>&nbsp;&nbsp;</span>\n          <span>Continue with uPort</span>\n        </div>\n\n    </div>\n\n    <div style="' + uportModalNewUserFooterCSS + '">\n      <p style="' + uportModalNewUserFooterTitleCSS + '">New uPort User?</p>\n      <div style="' + uportModalNewUserFooterAppStoresCSS + '">\n        <a href="' + googleStoreLink + '" target="_blank"><div style="' + uportModalNewUserFooterAppStoresAndroidCSS + '">' + _assets2.default.androidApp + '</div></a>\n        <a href="' + apppleStoreLink + '" target="_blank"><div style="' + uportModalNewUserFooterAppStoresiOSCSS + '">' + _assets2.default.appleApp + "</div></a>\n      </div>\n    </div>\n  ";
        return uportModal(content);
    };
    var uportQRDisplay = function uportQRDisplay(_ref) {
        var qrImageUri = _ref.qrImageUri;
        return uportModal('\n  <div>\n    <div style="' + uportLogoWithBg + '">' + _assets2.default.logowithBG + '</div>\n    <p id="uport-qr-text" style="' + uportQRInstructions + '">Scan QR code with uPort Mobile App</p>\n    <img src="' + qrImageUri + '" style="' + uportQRIMG + '" />\n  </div>\n');
    };
    var uportModal = function uportModal(innerHTML) {
        return '\n  <div id="uport-qr" style="' + uportQRCSS + '">\n    <div style="' + uportModalCSS + '" class="animated fadeIn">\n      <div style="' + uportModalHeaderCSS + '">\n        <div id="uport-qr-cancel" style="' + uportModalHeaderCloseCSS + '">\n          ' + _assets2.default.close + "\n        </div>\n      </div>\n      <div>\n        " + innerHTML + "\n      </div>\n    </div>\n    " + animateCSS + "\n  </div>\n";
    };
    var animateCSS = "\n<style>\n  @keyframes fadeIn {\n    from { opacity: 0; }\n    to { opacity: 1; }\n  }\n  .animated {\n    animation-duration: 1s;\n    animation-fill-mode: both;\n  }\n  .fadeIn {\n    animation-name: fadeIn;\n  }\n</style>\n";
    var uportQRCSS = "\n  position:fixed;\n  top: 0;\n  width:100%;\n  height:100%;\n  z-index:100;\n  background-color:rgba(0,0,0,0.5);\n  text-align:center;\n";
    var uportModalCSS = "\n  position:relative;\n  top:50%;\n  display:inline-block;\n  z-index:101;\n  background:#fff;\n  transform:translateY(-50%);\n  margin:0 auto;\n  border-radius: 8px;\n  overflow: hidden;\n  box-shadow: 0 12px 24px 0 rgba(0,0,0,0.1);\n  min-width: 400px;\n  max-width: 100%;\n";
    var uportModalHeaderCSS = "\n  width: 100%;\n  height: 45px;\n";
    var uportModalHeaderCloseCSS = "\n  float: right;\n  height: 25px;\n  width: 25px;\n  margin: 15px;\n  cursor: pointer;\n";
    var uportModalNewUserFooterCSS = "\n  background-color: #F6F7F8;\n  padding: 26px 0;\n  min-height: 110px;\n";
    var uportModalNewUserFooterTitleCSS = "\n  font-size: 14px;\n  color: #7C828B;\n  font-family: Avenir;\n";
    var uportModalNewUserFooterAppStoresCSS = "\n  padding: 10px 20px;\n  display: flex;\n  justify-content: center;\n";
    var uportModalNewUserFooterAppStoresAndroidCSS = "\n  width: 128px;\n  height: 40px;\n  margin: 0 10px;\n  display: block;\n";
    var uportModalNewUserFooterAppStoresiOSCSS = "\n  width: 128px;\n  height: 40px;\n  display: inline-block;\n";
    var uportModalLogo = "\n  display:inline-block;\n  max-width: 50px;\n  vertical-align: middle;\n";
    var uportAppName = "\n  font-weight: 700;\n";
    var uportQRTextWithAppName = "\n  font-size: 18px;\n  color: #7C828B;\n  font-family: Avenir;\n";
    var uportLogoWithBg = "\n  width: 60px;\n  height: 60px;\n  margin: 0 auto 0 auto;\n";
    var uportQRInstructions = "\n  color: #7C828B;\n  font-family: Avenir;\n  font-size: 18px;\n  text-align: center;\n  margin-top: 0;\n";
    var uportModalIntroWrapper = '\n  text-align: center;\n  display: inline-block;\n  width: 100%;"\n';
    var uportQRIMG = "\n  z-index:102;\n  margin-bottom: 35px;\n";
    var uportModalContinueBtn = "\n  text-align: center;\n  padding: 17px 25px 17px 25px;\n  border-radius: 6px;\n  color: #fff;\n  margin: 75px auto 80px 0;\n  font-family: arial, sans-serif;\n  font-weight: 500;\n  letter-spacing: 0.8px;\n  border-color: #4f45af;\n  text-shadow: none;\n  background-color: #5C50CA;\n  background-position: left 18px bottom 11px;\n  background-repeat: no-repeat;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  display: inline-block;\n  position: relative;\n  white-space: nowrap;\n  box-sizing: border-box;\n  font-size: 16px;\n  text-decoration: noneuser-select: none;\n  transition: border-color 0.1s linear,background 0.1s linear,color 0.1s linear;\n  -o-transition: border-color 0.1s linear,background 0.1s linear,color 0.1s linear;\n  -ms-transition: border-color 0.1s linear,background 0.1s linear,color 0.1s linear;\n";
    var apppleStoreLink = "https://itunes.apple.com/us/app/uport-id/id1123434510?mt=8";
    var googleStoreLink = "https://play.google.com/store/apps/details?id=com.uportMobile";
    exports.closeQr = closeQr;
    exports.openQr = openQr;
    exports.getQRDataURI = getQRDataURI;
    exports.uportQRDisplay = uportQRDisplay;
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var coder = __webpack_require__(66);
    var formatters = __webpack_require__(22);
    var sha3 = __webpack_require__(37);
    var Filter = __webpack_require__(50);
    var watches = __webpack_require__(49);
    var SolidityEvent = function(requestManager, json, address) {
        this._requestManager = requestManager;
        this._params = json.inputs;
        this._name = utils.transformToFullName(json);
        this._address = address;
        this._anonymous = json.anonymous;
    };
    SolidityEvent.prototype.types = function(indexed) {
        return this._params.filter(function(i) {
            return i.indexed === indexed;
        }).map(function(i) {
            return i.type;
        });
    };
    SolidityEvent.prototype.displayName = function() {
        return utils.extractDisplayName(this._name);
    };
    SolidityEvent.prototype.typeName = function() {
        return utils.extractTypeName(this._name);
    };
    SolidityEvent.prototype.signature = function() {
        return sha3(this._name);
    };
    SolidityEvent.prototype.encode = function(indexed, options) {
        indexed = indexed || {};
        options = options || {};
        var result = {};
        [ "fromBlock", "toBlock" ].filter(function(f) {
            return options[f] !== undefined;
        }).forEach(function(f) {
            result[f] = formatters.inputBlockNumberFormatter(options[f]);
        });
        result.topics = [];
        result.address = this._address;
        if (!this._anonymous) {
            result.topics.push("0x" + this.signature());
        }
        var indexedTopics = this._params.filter(function(i) {
            return i.indexed === true;
        }).map(function(i) {
            var value = indexed[i.name];
            if (value === undefined || value === null) {
                return null;
            }
            if (utils.isArray(value)) {
                return value.map(function(v) {
                    return "0x" + coder.encodeParam(i.type, v);
                });
            }
            return "0x" + coder.encodeParam(i.type, value);
        });
        result.topics = result.topics.concat(indexedTopics);
        return result;
    };
    SolidityEvent.prototype.decode = function(data) {
        data.data = data.data || "";
        data.topics = data.topics || [];
        var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
        var indexedData = argTopics.map(function(topics) {
            return topics.slice(2);
        }).join("");
        var indexedParams = coder.decodeParams(this.types(true), indexedData);
        var notIndexedData = data.data.slice(2);
        var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);
        var result = formatters.outputLogFormatter(data);
        result.event = this.displayName();
        result.address = data.address;
        result.args = this._params.reduce(function(acc, current) {
            acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
            return acc;
        }, {});
        delete result.data;
        delete result.topics;
        return result;
    };
    SolidityEvent.prototype.execute = function(indexed, options, callback) {
        if (utils.isFunction(arguments[arguments.length - 1])) {
            callback = arguments[arguments.length - 1];
            if (arguments.length === 2) options = null;
            if (arguments.length === 1) {
                options = null;
                indexed = {};
            }
        }
        var o = this.encode(indexed, options);
        var formatter = this.decode.bind(this);
        return new Filter(this._requestManager, o, watches.eth(), formatter, callback);
    };
    SolidityEvent.prototype.attachToContract = function(contract) {
        var execute = this.execute.bind(this);
        var displayName = this.displayName();
        if (!contract[displayName]) {
            contract[displayName] = execute;
        }
        contract[displayName][this.typeName()] = this.execute.bind(this, contract);
    };
    module.exports = SolidityEvent;
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var SolidityParam = function(value, offset) {
        this.value = value || "";
        this.offset = offset;
    };
    SolidityParam.prototype.dynamicPartLength = function() {
        return this.dynamicPart().length / 2;
    };
    SolidityParam.prototype.withOffset = function(offset) {
        return new SolidityParam(this.value, offset);
    };
    SolidityParam.prototype.combine = function(param) {
        return new SolidityParam(this.value + param.value);
    };
    SolidityParam.prototype.isDynamic = function() {
        return this.offset !== undefined;
    };
    SolidityParam.prototype.offsetAsBytes = function() {
        return !this.isDynamic() ? "" : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
    };
    SolidityParam.prototype.staticPart = function() {
        if (!this.isDynamic()) {
            return this.value;
        }
        return this.offsetAsBytes();
    };
    SolidityParam.prototype.dynamicPart = function() {
        return this.isDynamic() ? this.value : "";
    };
    SolidityParam.prototype.encode = function() {
        return this.staticPart() + this.dynamicPart();
    };
    SolidityParam.encodeList = function(params) {
        var totalOffset = params.length * 32;
        var offsetParams = params.map(function(param) {
            if (!param.isDynamic()) {
                return param;
            }
            var offset = totalOffset;
            totalOffset += param.dynamicPartLength();
            return param.withOffset(offset);
        });
        return offsetParams.reduce(function(result, param) {
            return result + param.dynamicPart();
        }, offsetParams.reduce(function(result, param) {
            return result + param.staticPart();
        }, ""));
    };
    module.exports = SolidityParam;
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(53));
        } else {}
    })(this, function(CryptoJS) {
        (function(Math) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var C_algo = C.algo;
            var RHO_OFFSETS = [];
            var PI_INDEXES = [];
            var ROUND_CONSTANTS = [];
            (function() {
                var x = 1, y = 0;
                for (var t = 0; t < 24; t++) {
                    RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                    var newX = y % 5;
                    var newY = (2 * x + 3 * y) % 5;
                    x = newX;
                    y = newY;
                }
                for (var x = 0; x < 5; x++) {
                    for (var y = 0; y < 5; y++) {
                        PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
                    }
                }
                var LFSR = 1;
                for (var i = 0; i < 24; i++) {
                    var roundConstantMsw = 0;
                    var roundConstantLsw = 0;
                    for (var j = 0; j < 7; j++) {
                        if (LFSR & 1) {
                            var bitPosition = (1 << j) - 1;
                            if (bitPosition < 32) {
                                roundConstantLsw ^= 1 << bitPosition;
                            } else {
                                roundConstantMsw ^= 1 << bitPosition - 32;
                            }
                        }
                        if (LFSR & 128) {
                            LFSR = LFSR << 1 ^ 113;
                        } else {
                            LFSR <<= 1;
                        }
                    }
                    ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                }
            })();
            var T = [];
            (function() {
                for (var i = 0; i < 25; i++) {
                    T[i] = X64Word.create();
                }
            })();
            var SHA3 = C_algo.SHA3 = Hasher.extend({
                cfg: Hasher.cfg.extend({
                    outputLength: 512
                }),
                _doReset: function() {
                    var state = this._state = [];
                    for (var i = 0; i < 25; i++) {
                        state[i] = new X64Word.init();
                    }
                    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
                _doProcessBlock: function(M, offset) {
                    var state = this._state;
                    var nBlockSizeLanes = this.blockSize / 2;
                    for (var i = 0; i < nBlockSizeLanes; i++) {
                        var M2i = M[offset + 2 * i];
                        var M2i1 = M[offset + 2 * i + 1];
                        M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                        M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                        var lane = state[i];
                        lane.high ^= M2i1;
                        lane.low ^= M2i;
                    }
                    for (var round = 0; round < 24; round++) {
                        for (var x = 0; x < 5; x++) {
                            var tMsw = 0, tLsw = 0;
                            for (var y = 0; y < 5; y++) {
                                var lane = state[x + 5 * y];
                                tMsw ^= lane.high;
                                tLsw ^= lane.low;
                            }
                            var Tx = T[x];
                            Tx.high = tMsw;
                            Tx.low = tLsw;
                        }
                        for (var x = 0; x < 5; x++) {
                            var Tx4 = T[(x + 4) % 5];
                            var Tx1 = T[(x + 1) % 5];
                            var Tx1Msw = Tx1.high;
                            var Tx1Lsw = Tx1.low;
                            var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                            var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                            for (var y = 0; y < 5; y++) {
                                var lane = state[x + 5 * y];
                                lane.high ^= tMsw;
                                lane.low ^= tLsw;
                            }
                        }
                        for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                            var lane = state[laneIndex];
                            var laneMsw = lane.high;
                            var laneLsw = lane.low;
                            var rhoOffset = RHO_OFFSETS[laneIndex];
                            if (rhoOffset < 32) {
                                var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                                var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                            } else {
                                var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                                var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                            }
                            var TPiLane = T[PI_INDEXES[laneIndex]];
                            TPiLane.high = tMsw;
                            TPiLane.low = tLsw;
                        }
                        var T0 = T[0];
                        var state0 = state[0];
                        T0.high = state0.high;
                        T0.low = state0.low;
                        for (var x = 0; x < 5; x++) {
                            for (var y = 0; y < 5; y++) {
                                var laneIndex = x + 5 * y;
                                var lane = state[laneIndex];
                                var TLane = T[laneIndex];
                                var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                                var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                                lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                                lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                            }
                        }
                        var lane = state[0];
                        var roundConstant = ROUND_CONSTANTS[round];
                        lane.high ^= roundConstant.high;
                        lane.low ^= roundConstant.low;
                    }
                },
                _doFinalize: function() {
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    var blockSizeBits = this.blockSize * 32;
                    dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
                    dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
                    data.sigBytes = dataWords.length * 4;
                    this._process();
                    var state = this._state;
                    var outputLengthBytes = this.cfg.outputLength / 8;
                    var outputLengthLanes = outputLengthBytes / 8;
                    var hashWords = [];
                    for (var i = 0; i < outputLengthLanes; i++) {
                        var lane = state[i];
                        var laneMsw = lane.high;
                        var laneLsw = lane.low;
                        laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                        laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                        hashWords.push(laneLsw);
                        hashWords.push(laneMsw);
                    }
                    return new WordArray.init(hashWords, outputLengthBytes);
                },
                clone: function() {
                    var clone = Hasher.clone.call(this);
                    var state = clone._state = this._state.slice(0);
                    for (var i = 0; i < 25; i++) {
                        state[i] = state[i].clone();
                    }
                    return clone;
                }
            });
            C.SHA3 = Hasher._createHelper(SHA3);
            C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        })(Math);
        return CryptoJS.SHA3;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(53));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var Hasher = C_lib.Hasher;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C.algo;
            function X64Word_create() {
                return X64Word.create.apply(X64Word, arguments);
            }
            var K = [ X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591) ];
            var W = [];
            (function() {
                for (var i = 0; i < 80; i++) {
                    W[i] = X64Word_create();
                }
            })();
            var SHA512 = C_algo.SHA512 = Hasher.extend({
                _doReset: function() {
                    this._hash = new X64WordArray.init([ new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209) ]);
                },
                _doProcessBlock: function(M, offset) {
                    var H = this._hash.words;
                    var H0 = H[0];
                    var H1 = H[1];
                    var H2 = H[2];
                    var H3 = H[3];
                    var H4 = H[4];
                    var H5 = H[5];
                    var H6 = H[6];
                    var H7 = H[7];
                    var H0h = H0.high;
                    var H0l = H0.low;
                    var H1h = H1.high;
                    var H1l = H1.low;
                    var H2h = H2.high;
                    var H2l = H2.low;
                    var H3h = H3.high;
                    var H3l = H3.low;
                    var H4h = H4.high;
                    var H4l = H4.low;
                    var H5h = H5.high;
                    var H5l = H5.low;
                    var H6h = H6.high;
                    var H6l = H6.low;
                    var H7h = H7.high;
                    var H7l = H7.low;
                    var ah = H0h;
                    var al = H0l;
                    var bh = H1h;
                    var bl = H1l;
                    var ch = H2h;
                    var cl = H2l;
                    var dh = H3h;
                    var dl = H3l;
                    var eh = H4h;
                    var el = H4l;
                    var fh = H5h;
                    var fl = H5l;
                    var gh = H6h;
                    var gl = H6l;
                    var hh = H7h;
                    var hl = H7l;
                    for (var i = 0; i < 80; i++) {
                        var Wi = W[i];
                        if (i < 16) {
                            var Wih = Wi.high = M[offset + i * 2] | 0;
                            var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                        } else {
                            var gamma0x = W[i - 15];
                            var gamma0xh = gamma0x.high;
                            var gamma0xl = gamma0x.low;
                            var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                            var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                            var gamma1x = W[i - 2];
                            var gamma1xh = gamma1x.high;
                            var gamma1xl = gamma1x.low;
                            var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                            var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                            var Wi7 = W[i - 7];
                            var Wi7h = Wi7.high;
                            var Wi7l = Wi7.low;
                            var Wi16 = W[i - 16];
                            var Wi16h = Wi16.high;
                            var Wi16l = Wi16.low;
                            var Wil = gamma0l + Wi7l;
                            var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                            var Wil = Wil + gamma1l;
                            var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                            var Wil = Wil + Wi16l;
                            var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                            Wi.high = Wih;
                            Wi.low = Wil;
                        }
                        var chh = eh & fh ^ ~eh & gh;
                        var chl = el & fl ^ ~el & gl;
                        var majh = ah & bh ^ ah & ch ^ bh & ch;
                        var majl = al & bl ^ al & cl ^ bl & cl;
                        var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                        var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                        var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                        var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                        var Ki = K[i];
                        var Kih = Ki.high;
                        var Kil = Ki.low;
                        var t1l = hl + sigma1l;
                        var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                        var t1l = t1l + chl;
                        var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                        var t1l = t1l + Kil;
                        var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                        var t1l = t1l + Wil;
                        var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                        var t2l = sigma0l + majl;
                        var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                        hh = gh;
                        hl = gl;
                        gh = fh;
                        gl = fl;
                        fh = eh;
                        fl = el;
                        el = dl + t1l | 0;
                        eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                        dh = ch;
                        dl = cl;
                        ch = bh;
                        cl = bl;
                        bh = ah;
                        bl = al;
                        al = t1l + t2l | 0;
                        ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                    }
                    H0l = H0.low = H0l + al;
                    H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                    H1l = H1.low = H1l + bl;
                    H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                    H2l = H2.low = H2l + cl;
                    H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                    H3l = H3.low = H3l + dl;
                    H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                    H4l = H4.low = H4l + el;
                    H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                    H5l = H5.low = H5l + fl;
                    H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                    H6l = H6.low = H6l + gl;
                    H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                    H7l = H7.low = H7l + hl;
                    H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
                },
                _doFinalize: function() {
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
                    dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;
                    this._process();
                    var hash = this._hash.toX32();
                    return hash;
                },
                clone: function() {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
                    return clone;
                },
                blockSize: 1024 / 32
            });
            C.SHA512 = Hasher._createHelper(SHA512);
            C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
        })();
        return CryptoJS.SHA512;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function(Math) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
            var H = [];
            var K = [];
            (function() {
                function isPrime(n) {
                    var sqrtN = Math.sqrt(n);
                    for (var factor = 2; factor <= sqrtN; factor++) {
                        if (!(n % factor)) {
                            return false;
                        }
                    }
                    return true;
                }
                function getFractionalBits(n) {
                    return (n - (n | 0)) * 4294967296 | 0;
                }
                var n = 2;
                var nPrime = 0;
                while (nPrime < 64) {
                    if (isPrime(n)) {
                        if (nPrime < 8) {
                            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                        }
                        K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
                        nPrime++;
                    }
                    n++;
                }
            })();
            var W = [];
            var SHA256 = C_algo.SHA256 = Hasher.extend({
                _doReset: function() {
                    this._hash = new WordArray.init(H.slice(0));
                },
                _doProcessBlock: function(M, offset) {
                    var H = this._hash.words;
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];
                    var f = H[5];
                    var g = H[6];
                    var h = H[7];
                    for (var i = 0; i < 64; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var gamma0x = W[i - 15];
                            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                            var gamma1x = W[i - 2];
                            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                        }
                        var ch = e & f ^ ~e & g;
                        var maj = a & b ^ a & c ^ b & c;
                        var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                        var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                        var t1 = h + sigma1 + ch + K[i] + W[i];
                        var t2 = sigma0 + maj;
                        h = g;
                        g = f;
                        f = e;
                        e = d + t1 | 0;
                        d = c;
                        c = b;
                        b = a;
                        a = t1 + t2 | 0;
                    }
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                    H[4] = H[4] + e | 0;
                    H[5] = H[5] + f | 0;
                    H[6] = H[6] + g | 0;
                    H[7] = H[7] + h | 0;
                },
                _doFinalize: function() {
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;
                    this._process();
                    return this._hash;
                },
                clone: function() {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
                    return clone;
                }
            });
            C.SHA256 = Hasher._createHelper(SHA256);
            C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        })(Math);
        return CryptoJS.SHA256;
    });
}, function(module, exports) {
    var Jsonrpc = {
        messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
        if (!method) console.error("jsonrpc method should be specified!");
        Jsonrpc.messageId++;
        return {
            jsonrpc: "2.0",
            id: Jsonrpc.messageId,
            method,
            params: params || []
        };
    };
    Jsonrpc.isValidResponse = function(response) {
        return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
        function validateSingleMessage(message) {
            return !!message && !message.error && message.jsonrpc === "2.0" && typeof message.id === "number" && message.result !== undefined;
        }
    };
    Jsonrpc.toBatchPayload = function(messages) {
        return messages.map(function(message) {
            return Jsonrpc.toPayload(message.method, message.params);
        });
    };
    module.exports = Jsonrpc;
}, function(module, exports, __webpack_require__) {
    var errors = __webpack_require__(31);
    if (typeof window !== "undefined" && window.XMLHttpRequest) {
        XMLHttpRequest = window.XMLHttpRequest;
    } else {
        XMLHttpRequest = __webpack_require__(263).XMLHttpRequest;
    }
    var XHR2 = __webpack_require__(262);
    var HttpProvider = function(host, timeout) {
        this.host = host || "http://localhost:8545";
        this.timeout = timeout || 0;
    };
    HttpProvider.prototype.prepareRequest = function(async) {
        var request;
        if (async) {
            request = new XHR2();
            request.timeout = this.timeout;
        } else {
            request = new XMLHttpRequest();
        }
        request.open("POST", this.host, async);
        request.setRequestHeader("Content-Type", "application/json");
        return request;
    };
    HttpProvider.prototype.send = function(payload) {
        var request = this.prepareRequest(false);
        try {
            request.send(JSON.stringify(payload));
        } catch (error) {
            throw errors.InvalidConnection(this.host);
        }
        var result = request.responseText;
        try {
            result = JSON.parse(result);
        } catch (e) {
            throw errors.InvalidResponse(request.responseText);
        }
        return result;
    };
    HttpProvider.prototype.sendAsync = function(payload, callback) {
        var request = this.prepareRequest(true);
        request.onreadystatechange = function() {
            if (request.readyState === 4 && request.timeout !== 1) {
                var result = request.responseText;
                var error = null;
                try {
                    result = JSON.parse(result);
                } catch (e) {
                    error = errors.InvalidResponse(request.responseText);
                }
                callback(error, result);
            }
        };
        request.ontimeout = function() {
            callback(errors.ConnectionTimeout(this.timeout));
        };
        try {
            request.send(JSON.stringify(payload));
        } catch (error) {
            callback(errors.InvalidConnection(this.host));
        }
    };
    HttpProvider.prototype.isConnected = function() {
        try {
            this.send({
                id: 9999999999,
                jsonrpc: "2.0",
                method: "net_listening",
                params: []
            });
            return true;
        } catch (e) {
            return false;
        }
    };
    module.exports = HttpProvider;
}, function(module, exports) {
    module.exports = function isHexPrefixed(str) {
        if (typeof str !== "string") {
            throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
        }
        return str.slice(0, 2) === "0x";
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = blacklist;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function blacklist(str, chars) {
        (0, _assertString2.default)(str);
        return str.replace(new RegExp("[" + chars + "]+", "g"), "");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = rtrim;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function rtrim(str, chars) {
        (0, _assertString2.default)(str);
        var pattern = chars ? new RegExp("[" + chars + "]") : /\s/;
        var idx = str.length - 1;
        while (idx >= 0 && pattern.test(str[idx])) {
            idx--;
        }
        return idx < str.length ? str.substr(0, idx + 1) : str;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = ltrim;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function ltrim(str, chars) {
        (0, _assertString2.default)(str);
        var pattern = chars ? new RegExp("^[" + chars + "]+", "g") : /^\s+/g;
        return str.replace(pattern, "");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isHexadecimal;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var hexadecimal = /^[0-9A-F]+$/i;
    function isHexadecimal(str) {
        (0, _assertString2.default)(str);
        return hexadecimal.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.halfWidth = undefined;
    exports.default = isHalfWidth;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var halfWidth = exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function isHalfWidth(str) {
        (0, _assertString2.default)(str);
        return halfWidth.test(str);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.fullWidth = undefined;
    exports.default = isFullWidth;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var fullWidth = exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function isFullWidth(str) {
        (0, _assertString2.default)(str);
        return fullWidth.test(str);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var alpha = exports.alpha = {
        "en-US": /^[A-Z]+$/i,
        "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
        "da-DK": /^[A-ZÆØÅ]+$/i,
        "de-DE": /^[A-ZÄÖÜß]+$/i,
        "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
        "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
        "nl-NL": /^[A-ZÉËÏÓÖÜ]+$/i,
        "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
        "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
        "pt-PT": /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
        "ru-RU": /^[А-ЯЁ]+$/i,
        "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
        "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
        "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
        "uk-UA": /^[А-ЩЬЮЯЄIЇҐ]+$/i,
        ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    var alphanumeric = exports.alphanumeric = {
        "en-US": /^[0-9A-Z]+$/i,
        "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
        "da-DK": /^[0-9A-ZÆØÅ]$/i,
        "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
        "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
        "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
        "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
        "nl-NL": /^[0-9A-ZÉËÏÓÖÜ]+$/i,
        "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
        "pt-PT": /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
        "ru-RU": /^[0-9А-ЯЁ]+$/i,
        "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
        "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
        "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
        "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐ]+$/i,
        ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
    };
    var englishLocales = exports.englishLocales = [ "AU", "GB", "HK", "IN", "NZ", "ZA", "ZM" ];
    for (var locale, i = 0; i < englishLocales.length; i++) {
        locale = "en-" + englishLocales[i];
        alpha[locale] = alpha["en-US"];
        alphanumeric[locale] = alphanumeric["en-US"];
    }
    alpha["pt-BR"] = alpha["pt-PT"];
    alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
    var arabicLocales = exports.arabicLocales = [ "AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE" ];
    for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
        _locale = "ar-" + arabicLocales[_i];
        alpha[_locale] = alpha.ar;
        alphanumeric[_locale] = alphanumeric.ar;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isIP;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    var ipv6Block = /^[0-9A-F]{1,4}$/i;
    function isIP(str) {
        var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        (0, _assertString2.default)(str);
        version = String(version);
        if (!version) {
            return isIP(str, 4) || isIP(str, 6);
        } else if (version === "4") {
            if (!ipv4Maybe.test(str)) {
                return false;
            }
            var parts = str.split(".").sort(function(a, b) {
                return a - b;
            });
            return parts[3] <= 255;
        } else if (version === "6") {
            var blocks = str.split(":");
            var foundOmissionBlock = false;
            var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
            var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
            if (blocks.length > expectedNumberOfBlocks) {
                return false;
            }
            if (str === "::") {
                return true;
            } else if (str.substr(0, 2) === "::") {
                blocks.shift();
                blocks.shift();
                foundOmissionBlock = true;
            } else if (str.substr(str.length - 2) === "::") {
                blocks.pop();
                blocks.pop();
                foundOmissionBlock = true;
            }
            for (var i = 0; i < blocks.length; ++i) {
                if (blocks[i] === "" && i > 0 && i < blocks.length - 1) {
                    if (foundOmissionBlock) {
                        return false;
                    }
                    foundOmissionBlock = true;
                } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {} else if (!ipv6Block.test(blocks[i])) {
                    return false;
                }
            }
            if (foundOmissionBlock) {
                return blocks.length >= 1;
            }
            return blocks.length === expectedNumberOfBlocks;
        }
        return false;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = isByteLength;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isByteLength(str, options) {
        (0, _assertString2.default)(str);
        var min = void 0;
        var max = void 0;
        if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
            min = options.min || 0;
            max = options.max;
        } else {
            min = arguments[1];
            max = arguments[2];
        }
        var len = encodeURI(str).split(/%..|./).length - 1;
        return len >= min && (typeof max === "undefined" || len <= max);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isEmail;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _merge = __webpack_require__(39);
    var _merge2 = _interopRequireDefault(_merge);
    var _isByteLength = __webpack_require__(118);
    var _isByteLength2 = _interopRequireDefault(_isByteLength);
    var _isFQDN = __webpack_require__(70);
    var _isFQDN2 = _interopRequireDefault(_isFQDN);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var default_email_options = {
        allow_display_name: false,
        require_display_name: false,
        allow_utf8_local_part: true,
        require_tld: true
    };
    var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    function isEmail(str, options) {
        (0, _assertString2.default)(str);
        options = (0, _merge2.default)(options, default_email_options);
        if (options.require_display_name || options.allow_display_name) {
            var display_email = str.match(displayName);
            if (display_email) {
                str = display_email[1];
            } else if (options.require_display_name) {
                return false;
            }
        }
        var parts = str.split("@");
        var domain = parts.pop();
        var user = parts.join("@");
        var lower_domain = domain.toLowerCase();
        if (lower_domain === "gmail.com" || lower_domain === "googlemail.com") {
            user = user.replace(/\./g, "").toLowerCase();
        }
        if (!(0, _isByteLength2.default)(user, {
            max: 64
        }) || !(0, _isByteLength2.default)(domain, {
            max: 254
        })) {
            return false;
        }
        if (!(0, _isFQDN2.default)(domain, {
            require_tld: options.require_tld
        })) {
            return false;
        }
        if (user[0] === '"') {
            user = user.slice(1, user.length - 1);
            return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
        }
        var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
        var user_parts = user.split(".");
        for (var i = 0; i < user_parts.length; i++) {
            if (!pattern.test(user_parts[i])) {
                return false;
            }
        }
        return true;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = toFloat;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function toFloat(str) {
        (0, _assertString2.default)(str);
        return parseFloat(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Buffer = __webpack_require__(4).Buffer;
    var asn1 = __webpack_require__(32);
    var base = asn1.base;
    var bignum = asn1.bignum;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
    }
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
        base.Node.call(this, "der", parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
        if (content.length < 128) {
            var header = new Buffer(2);
            header[0] = encodedTag;
            header[1] = content.length;
            return this._createEncoderBuffer([ header, content ]);
        }
        var lenOctets = 1;
        for (var i = content.length; i >= 256; i >>= 8) lenOctets++;
        var header = new Buffer(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 128 | lenOctets;
        for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 255;
        return this._createEncoderBuffer([ header, content ]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === "octstr") return this._createEncoderBuffer(str); else if (tag === "bitstr") return this._createEncoderBuffer([ str.unused | 0, str.data ]); else if (tag === "ia5str" || tag === "utf8str") return this._createEncoderBuffer(str);
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === "string") {
            if (!values) return this.reporter.error("string objid given, but no values map found");
            if (!values.hasOwnProperty(id)) return this.reporter.error("objid not found in values map");
            id = values[id].split(/[\s\.]+/g);
            for (var i = 0; i < id.length; i++) id[i] |= 0;
        } else if (Array.isArray(id)) {
            id = id.slice();
            for (var i = 0; i < id.length; i++) id[i] |= 0;
        }
        if (!Array.isArray(id)) {
            return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
        }
        if (!relative) {
            if (id[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            id.splice(0, 2, id[0] * 40 + id[1]);
        }
        var size = 0;
        for (var i = 0; i < id.length; i++) {
            var ident = id[i];
            for (size++; ident >= 128; ident >>= 7) size++;
        }
        var objid = new Buffer(size);
        var offset = objid.length - 1;
        for (var i = id.length - 1; i >= 0; i--) {
            var ident = id[i];
            objid[offset--] = ident & 127;
            while ((ident >>= 7) > 0) objid[offset--] = 128 | ident & 127;
        }
        return this._createEncoderBuffer(objid);
    };
    function two(num) {
        if (num < 10) return "0" + num; else return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        var str;
        var date = new Date(time);
        if (tag === "gentime") {
            str = [ two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z" ].join("");
        } else if (tag === "utctime") {
            str = [ two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z" ].join("");
        } else {
            this.reporter.error("Encoding " + tag + " time is not supported yet");
        }
        return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === "string") {
            if (!values) return this.reporter.error("String int or enum given, but no values map");
            if (!values.hasOwnProperty(num)) {
                return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
            }
            num = values[num];
        }
        if (typeof num !== "number" && !Buffer.isBuffer(num)) {
            var numArray = num.toArray();
            if (num.sign === false && numArray[0] & 128) {
                numArray.unshift(0);
            }
            num = new Buffer(numArray);
        }
        if (Buffer.isBuffer(num)) {
            var size = num.length;
            if (num.length === 0) size++;
            var out = new Buffer(size);
            num.copy(out);
            if (num.length === 0) out[0] = 0;
            return this._createEncoderBuffer(out);
        }
        if (num < 128) return this._createEncoderBuffer(num);
        if (num < 256) return this._createEncoderBuffer([ 0, num ]);
        var size = 1;
        for (var i = num; i >= 256; i >>= 8) size++;
        var out = new Array(size);
        for (var i = out.length - 1; i >= 0; i--) {
            out[i] = num & 255;
            num >>= 8;
        }
        if (out[0] & 128) {
            out.unshift(0);
        }
        return this._createEncoderBuffer(new Buffer(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function") entity = entity(obj);
        return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState;
        var i;
        if (state["default"] === null) return false;
        var data = dataBuffer.join();
        if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
        if (data.length !== state.defaultBuffer.length) return false;
        for (i = 0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false;
        return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
        var res;
        if (tag === "seqof") tag = "seq"; else if (tag === "setof") tag = "set";
        if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag]; else if (typeof tag === "number" && (tag | 0) === tag) res = tag; else return reporter.error("Unknown tag: " + tag);
        if (res >= 31) return reporter.error("Multi-octet tag encoding unsupported");
        if (!primitive) res |= 32;
        res |= der.tagClassByName[cls || "universal"] << 6;
        return res;
    }
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var asn1 = __webpack_require__(32);
    var base = asn1.base;
    var bignum = asn1.bignum;
    var der = asn1.constants.der;
    function DERDecoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
    }
    module.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
        if (!(data instanceof base.DecoderBuffer)) data = new base.DecoderBuffer(data, options);
        return this.tree._decode(data, options);
    };
    function DERNode(parent) {
        base.Node.call(this, "der", parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
        if (buffer.isEmpty()) return false;
        var state = buffer.save();
        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
        if (buffer.isError(decodedTag)) return decodedTag;
        buffer.restore(state);
        return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
        var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
        if (buffer.isError(decodedTag)) return decodedTag;
        var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
        if (buffer.isError(len)) return len;
        if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
            return buffer.error('Failed to match tag: "' + tag + '"');
        }
        if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
        var state = buffer.save();
        var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer.isError(res)) return res;
        len = buffer.offset - state.offset;
        buffer.restore(state);
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
        while (true) {
            var tag = derDecodeTag(buffer, fail);
            if (buffer.isError(tag)) return tag;
            var len = derDecodeLen(buffer, tag.primitive, fail);
            if (buffer.isError(len)) return len;
            var res;
            if (tag.primitive || len !== null) res = buffer.skip(len); else res = this._skipUntilEnd(buffer, fail);
            if (buffer.isError(res)) return res;
            if (tag.tagStr === "end") break;
        }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
        var result = [];
        while (!buffer.isEmpty()) {
            var possibleEnd = this._peekTag(buffer, "end");
            if (buffer.isError(possibleEnd)) return possibleEnd;
            var res = decoder.decode(buffer, "der");
            if (buffer.isError(res) && possibleEnd) break;
            result.push(res);
        }
        return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
        if (tag === "octstr") {
            return buffer.raw();
        } else if (tag === "bitstr") {
            var unused = buffer.readUInt8();
            if (buffer.isError(unused)) return unused;
            return {
                unused,
                data: buffer.raw()
            };
        } else if (tag === "ia5str" || tag === "utf8str") {
            return buffer.raw().toString();
        } else {
            return this.error("Decoding of string type: " + tag + " unsupported");
        }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
        var identifiers = [];
        var ident = 0;
        while (!buffer.isEmpty()) {
            var subident = buffer.readUInt8();
            ident <<= 7;
            ident |= subident & 127;
            if ((subident & 128) === 0) {
                identifiers.push(ident);
                ident = 0;
            }
        }
        if (subident & 128) identifiers.push(ident);
        var first = identifiers[0] / 40 | 0;
        var second = identifiers[0] % 40;
        if (relative) result = identifiers; else result = [ first, second ].concat(identifiers.slice(1));
        if (values) result = values[result.join(" ")];
        return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
        var str = buffer.raw().toString();
        if (tag === "gentime") {
            var year = str.slice(0, 4) | 0;
            var mon = str.slice(4, 6) | 0;
            var day = str.slice(6, 8) | 0;
            var hour = str.slice(8, 10) | 0;
            var min = str.slice(10, 12) | 0;
            var sec = str.slice(12, 14) | 0;
        } else if (tag === "utctime") {
            var year = str.slice(0, 2) | 0;
            var mon = str.slice(2, 4) | 0;
            var day = str.slice(4, 6) | 0;
            var hour = str.slice(6, 8) | 0;
            var min = str.slice(8, 10) | 0;
            var sec = str.slice(10, 12) | 0;
            if (year < 70) year = 2e3 + year; else year = 1900 + year;
        } else {
            return this.error("Decoding " + tag + " time is not supported yet");
        }
        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull(buffer) {
        return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
        var res = buffer.readUInt8();
        if (buffer.isError(res)) return res; else return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
        var raw = buffer.raw();
        var res = new bignum(raw);
        if (values) res = values[res.toString(10)] || res;
        return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function") entity = entity(obj);
        return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
        var tag = buf.readUInt8(fail);
        if (buf.isError(tag)) return tag;
        var cls = der.tagClass[tag >> 6];
        var primitive = (tag & 32) === 0;
        if ((tag & 31) === 31) {
            var oct = tag;
            tag = 0;
            while ((oct & 128) === 128) {
                oct = buf.readUInt8(fail);
                if (buf.isError(oct)) return oct;
                tag <<= 7;
                tag |= oct & 127;
            }
        } else {
            tag &= 31;
        }
        var tagStr = der.tag[tag];
        return {
            cls,
            primitive,
            tag,
            tagStr
        };
    }
    function derDecodeLen(buf, primitive, fail) {
        var len = buf.readUInt8(fail);
        if (buf.isError(len)) return len;
        if (!primitive && len === 128) return null;
        if ((len & 128) === 0) {
            return len;
        }
        var num = len & 127;
        if (num >= 4) return buf.error("length octect is too long");
        len = 0;
        for (var i = 0; i < num; i++) {
            len <<= 8;
            var j = buf.readUInt8(fail);
            if (buf.isError(j)) return j;
            len |= j;
        }
        return len;
    }
}, function(module, exports, __webpack_require__) {
    var constants = exports;
    constants._reverse = function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
            if ((key | 0) == key) key = key | 0;
            var value = map[key];
            res[value] = key;
        });
        return res;
    };
    constants.der = __webpack_require__(346);
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Reporter = __webpack_require__(58).Reporter;
    var Buffer = __webpack_require__(4).Buffer;
    function DecoderBuffer(base, options) {
        Reporter.call(this, options);
        if (!Buffer.isBuffer(base)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = base;
        this.offset = 0;
        this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
        return {
            offset: this.offset,
            reporter: Reporter.prototype.save.call(this)
        };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
        var res = new DecoderBuffer(this.base);
        res.offset = save.offset;
        res.length = this.offset;
        this.offset = save.offset;
        Reporter.prototype.restore.call(this, save.reporter);
        return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true); else return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length)) return this.error(fail || "DecoderBuffer overrun");
        var res = new DecoderBuffer(this.base);
        res._reporterState = this._reporterState;
        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
        if (Array.isArray(value)) {
            this.length = 0;
            this.value = value.map(function(item) {
                if (!(item instanceof EncoderBuffer)) item = new EncoderBuffer(item, reporter);
                this.length += item.length;
                return item;
            }, this);
        } else if (typeof value === "number") {
            if (!(0 <= value && value <= 255)) return reporter.error("non-byte EncoderBuffer value");
            this.value = value;
            this.length = 1;
        } else if (typeof value === "string") {
            this.value = value;
            this.length = Buffer.byteLength(value);
        } else if (Buffer.isBuffer(value)) {
            this.value = value;
            this.length = value.length;
        } else {
            return reporter.error("Unsupported type: " + typeof value);
        }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out) out = new Buffer(this.length);
        if (!offset) offset = 0;
        if (this.length === 0) return out;
        if (Array.isArray(this.value)) {
            this.value.forEach(function(item) {
                item.join(out, offset);
                offset += item.length;
            });
        } else {
            if (typeof this.value === "number") out[offset] = this.value; else if (typeof this.value === "string") out.write(this.value, offset); else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
            offset += this.length;
        }
        return out;
    };
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var bn = __webpack_require__(9);
        function withPublic(paddedMsg, key) {
            return new Buffer(paddedMsg.toRed(bn.mont(key.modulus)).redPow(new bn(key.publicExponent)).fromRed().toArray());
        }
        module.exports = withPublic;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports) {
    module.exports = function xor(a, b) {
        var len = a.length;
        var i = -1;
        while (++i < len) {
            a[i] ^= b[i];
        }
        return a;
    };
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var createHash = __webpack_require__(44);
        module.exports = function(seed, len) {
            var t = new Buffer("");
            var i = 0, c;
            while (t.length < len) {
                c = i2ops(i++);
                t = Buffer.concat([ t, createHash("sha1").update(seed).update(c).digest() ]);
            }
            return t.slice(0, len);
        };
        function i2ops(c) {
            var out = new Buffer(4);
            out.writeUInt32BE(c, 0);
            return out;
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module) {
    module.exports = {
        "1.3.132.0.10": "secp256k1",
        "1.3.132.0.33": "p224",
        "1.2.840.10045.3.1.1": "p192",
        "1.2.840.10045.3.1.7": "p256",
        "1.3.132.0.34": "p384",
        "1.3.132.0.35": "p521"
    };
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Buffer = __webpack_require__(4).Buffer;
    var asn1 = __webpack_require__(33);
    var base = asn1.base;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
    }
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
        base.Node.call(this, "der", parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
        if (content.length < 128) {
            var header = new Buffer(2);
            header[0] = encodedTag;
            header[1] = content.length;
            return this._createEncoderBuffer([ header, content ]);
        }
        var lenOctets = 1;
        for (var i = content.length; i >= 256; i >>= 8) lenOctets++;
        var header = new Buffer(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 128 | lenOctets;
        for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 255;
        return this._createEncoderBuffer([ header, content ]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === "bitstr") {
            return this._createEncoderBuffer([ str.unused | 0, str.data ]);
        } else if (tag === "bmpstr") {
            var buf = new Buffer(str.length * 2);
            for (var i = 0; i < str.length; i++) {
                buf.writeUInt16BE(str.charCodeAt(i), i * 2);
            }
            return this._createEncoderBuffer(buf);
        } else if (tag === "numstr") {
            if (!this._isNumstr(str)) {
                return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
            }
            return this._createEncoderBuffer(str);
        } else if (tag === "printstr") {
            if (!this._isPrintstr(str)) {
                return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
            }
            return this._createEncoderBuffer(str);
        } else if (/str$/.test(tag)) {
            return this._createEncoderBuffer(str);
        } else if (tag === "objDesc") {
            return this._createEncoderBuffer(str);
        } else {
            return this.reporter.error("Encoding of string type: " + tag + " unsupported");
        }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === "string") {
            if (!values) return this.reporter.error("string objid given, but no values map found");
            if (!values.hasOwnProperty(id)) return this.reporter.error("objid not found in values map");
            id = values[id].split(/[\s\.]+/g);
            for (var i = 0; i < id.length; i++) id[i] |= 0;
        } else if (Array.isArray(id)) {
            id = id.slice();
            for (var i = 0; i < id.length; i++) id[i] |= 0;
        }
        if (!Array.isArray(id)) {
            return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
        }
        if (!relative) {
            if (id[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            id.splice(0, 2, id[0] * 40 + id[1]);
        }
        var size = 0;
        for (var i = 0; i < id.length; i++) {
            var ident = id[i];
            for (size++; ident >= 128; ident >>= 7) size++;
        }
        var objid = new Buffer(size);
        var offset = objid.length - 1;
        for (var i = id.length - 1; i >= 0; i--) {
            var ident = id[i];
            objid[offset--] = ident & 127;
            while ((ident >>= 7) > 0) objid[offset--] = 128 | ident & 127;
        }
        return this._createEncoderBuffer(objid);
    };
    function two(num) {
        if (num < 10) return "0" + num; else return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        var str;
        var date = new Date(time);
        if (tag === "gentime") {
            str = [ two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z" ].join("");
        } else if (tag === "utctime") {
            str = [ two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z" ].join("");
        } else {
            this.reporter.error("Encoding " + tag + " time is not supported yet");
        }
        return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === "string") {
            if (!values) return this.reporter.error("String int or enum given, but no values map");
            if (!values.hasOwnProperty(num)) {
                return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
            }
            num = values[num];
        }
        if (typeof num !== "number" && !Buffer.isBuffer(num)) {
            var numArray = num.toArray();
            if (!num.sign && numArray[0] & 128) {
                numArray.unshift(0);
            }
            num = new Buffer(numArray);
        }
        if (Buffer.isBuffer(num)) {
            var size = num.length;
            if (num.length === 0) size++;
            var out = new Buffer(size);
            num.copy(out);
            if (num.length === 0) out[0] = 0;
            return this._createEncoderBuffer(out);
        }
        if (num < 128) return this._createEncoderBuffer(num);
        if (num < 256) return this._createEncoderBuffer([ 0, num ]);
        var size = 1;
        for (var i = num; i >= 256; i >>= 8) size++;
        var out = new Array(size);
        for (var i = out.length - 1; i >= 0; i--) {
            out[i] = num & 255;
            num >>= 8;
        }
        if (out[0] & 128) {
            out.unshift(0);
        }
        return this._createEncoderBuffer(new Buffer(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function") entity = entity(obj);
        return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState;
        var i;
        if (state["default"] === null) return false;
        var data = dataBuffer.join();
        if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
        if (data.length !== state.defaultBuffer.length) return false;
        for (i = 0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false;
        return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
        var res;
        if (tag === "seqof") tag = "seq"; else if (tag === "setof") tag = "set";
        if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag]; else if (typeof tag === "number" && (tag | 0) === tag) res = tag; else return reporter.error("Unknown tag: " + tag);
        if (res >= 31) return reporter.error("Multi-octet tag encoding unsupported");
        if (!primitive) res |= 32;
        res |= der.tagClassByName[cls || "universal"] << 6;
        return res;
    }
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var asn1 = __webpack_require__(33);
    var base = asn1.base;
    var bignum = asn1.bignum;
    var der = asn1.constants.der;
    function DERDecoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
    }
    module.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
        if (!(data instanceof base.DecoderBuffer)) data = new base.DecoderBuffer(data, options);
        return this.tree._decode(data, options);
    };
    function DERNode(parent) {
        base.Node.call(this, "der", parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
        if (buffer.isEmpty()) return false;
        var state = buffer.save();
        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
        if (buffer.isError(decodedTag)) return decodedTag;
        buffer.restore(state);
        return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
        var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
        if (buffer.isError(decodedTag)) return decodedTag;
        var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
        if (buffer.isError(len)) return len;
        if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
            return buffer.error('Failed to match tag: "' + tag + '"');
        }
        if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
        var state = buffer.save();
        var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer.isError(res)) return res;
        len = buffer.offset - state.offset;
        buffer.restore(state);
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
        while (true) {
            var tag = derDecodeTag(buffer, fail);
            if (buffer.isError(tag)) return tag;
            var len = derDecodeLen(buffer, tag.primitive, fail);
            if (buffer.isError(len)) return len;
            var res;
            if (tag.primitive || len !== null) res = buffer.skip(len); else res = this._skipUntilEnd(buffer, fail);
            if (buffer.isError(res)) return res;
            if (tag.tagStr === "end") break;
        }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
        var result = [];
        while (!buffer.isEmpty()) {
            var possibleEnd = this._peekTag(buffer, "end");
            if (buffer.isError(possibleEnd)) return possibleEnd;
            var res = decoder.decode(buffer, "der", options);
            if (buffer.isError(res) && possibleEnd) break;
            result.push(res);
        }
        return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
        if (tag === "bitstr") {
            var unused = buffer.readUInt8();
            if (buffer.isError(unused)) return unused;
            return {
                unused,
                data: buffer.raw()
            };
        } else if (tag === "bmpstr") {
            var raw = buffer.raw();
            if (raw.length % 2 === 1) return buffer.error("Decoding of string type: bmpstr length mismatch");
            var str = "";
            for (var i = 0; i < raw.length / 2; i++) {
                str += String.fromCharCode(raw.readUInt16BE(i * 2));
            }
            return str;
        } else if (tag === "numstr") {
            var numstr = buffer.raw().toString("ascii");
            if (!this._isNumstr(numstr)) {
                return buffer.error("Decoding of string type: " + "numstr unsupported characters");
            }
            return numstr;
        } else if (tag === "octstr") {
            return buffer.raw();
        } else if (tag === "objDesc") {
            return buffer.raw();
        } else if (tag === "printstr") {
            var printstr = buffer.raw().toString("ascii");
            if (!this._isPrintstr(printstr)) {
                return buffer.error("Decoding of string type: " + "printstr unsupported characters");
            }
            return printstr;
        } else if (/str$/.test(tag)) {
            return buffer.raw().toString();
        } else {
            return buffer.error("Decoding of string type: " + tag + " unsupported");
        }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
        var result;
        var identifiers = [];
        var ident = 0;
        while (!buffer.isEmpty()) {
            var subident = buffer.readUInt8();
            ident <<= 7;
            ident |= subident & 127;
            if ((subident & 128) === 0) {
                identifiers.push(ident);
                ident = 0;
            }
        }
        if (subident & 128) identifiers.push(ident);
        var first = identifiers[0] / 40 | 0;
        var second = identifiers[0] % 40;
        if (relative) result = identifiers; else result = [ first, second ].concat(identifiers.slice(1));
        if (values) {
            var tmp = values[result.join(" ")];
            if (tmp === undefined) tmp = values[result.join(".")];
            if (tmp !== undefined) result = tmp;
        }
        return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
        var str = buffer.raw().toString();
        if (tag === "gentime") {
            var year = str.slice(0, 4) | 0;
            var mon = str.slice(4, 6) | 0;
            var day = str.slice(6, 8) | 0;
            var hour = str.slice(8, 10) | 0;
            var min = str.slice(10, 12) | 0;
            var sec = str.slice(12, 14) | 0;
        } else if (tag === "utctime") {
            var year = str.slice(0, 2) | 0;
            var mon = str.slice(2, 4) | 0;
            var day = str.slice(4, 6) | 0;
            var hour = str.slice(6, 8) | 0;
            var min = str.slice(8, 10) | 0;
            var sec = str.slice(10, 12) | 0;
            if (year < 70) year = 2e3 + year; else year = 1900 + year;
        } else {
            return buffer.error("Decoding " + tag + " time is not supported yet");
        }
        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull(buffer) {
        return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
        var res = buffer.readUInt8();
        if (buffer.isError(res)) return res; else return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
        var raw = buffer.raw();
        var res = new bignum(raw);
        if (values) res = values[res.toString(10)] || res;
        return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function") entity = entity(obj);
        return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
        var tag = buf.readUInt8(fail);
        if (buf.isError(tag)) return tag;
        var cls = der.tagClass[tag >> 6];
        var primitive = (tag & 32) === 0;
        if ((tag & 31) === 31) {
            var oct = tag;
            tag = 0;
            while ((oct & 128) === 128) {
                oct = buf.readUInt8(fail);
                if (buf.isError(oct)) return oct;
                tag <<= 7;
                tag |= oct & 127;
            }
        } else {
            tag &= 31;
        }
        var tagStr = der.tag[tag];
        return {
            cls,
            primitive,
            tag,
            tagStr
        };
    }
    function derDecodeLen(buf, primitive, fail) {
        var len = buf.readUInt8(fail);
        if (buf.isError(len)) return len;
        if (!primitive && len === 128) return null;
        if ((len & 128) === 0) {
            return len;
        }
        var num = len & 127;
        if (num > 4) return buf.error("length octect is too long");
        len = 0;
        for (var i = 0; i < num; i++) {
            len <<= 8;
            var j = buf.readUInt8(fail);
            if (buf.isError(j)) return j;
            len |= j;
        }
        return len;
    }
}, function(module, exports, __webpack_require__) {
    var constants = exports;
    constants._reverse = function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
            if ((key | 0) == key) key = key | 0;
            var value = map[key];
            res[value] = key;
        });
        return res;
    };
    constants.der = __webpack_require__(366);
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Reporter = __webpack_require__(40).Reporter;
    var Buffer = __webpack_require__(4).Buffer;
    function DecoderBuffer(base, options) {
        Reporter.call(this, options);
        if (!Buffer.isBuffer(base)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = base;
        this.offset = 0;
        this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
        return {
            offset: this.offset,
            reporter: Reporter.prototype.save.call(this)
        };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
        var res = new DecoderBuffer(this.base);
        res.offset = save.offset;
        res.length = this.offset;
        this.offset = save.offset;
        Reporter.prototype.restore.call(this, save.reporter);
        return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true); else return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length)) return this.error(fail || "DecoderBuffer overrun");
        var res = new DecoderBuffer(this.base);
        res._reporterState = this._reporterState;
        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
        if (Array.isArray(value)) {
            this.length = 0;
            this.value = value.map(function(item) {
                if (!(item instanceof EncoderBuffer)) item = new EncoderBuffer(item, reporter);
                this.length += item.length;
                return item;
            }, this);
        } else if (typeof value === "number") {
            if (!(0 <= value && value <= 255)) return reporter.error("non-byte EncoderBuffer value");
            this.value = value;
            this.length = 1;
        } else if (typeof value === "string") {
            this.value = value;
            this.length = Buffer.byteLength(value);
        } else if (Buffer.isBuffer(value)) {
            this.value = value;
            this.length = value.length;
        } else {
            return reporter.error("Unsupported type: " + typeof value);
        }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out) out = new Buffer(this.length);
        if (!offset) offset = 0;
        if (this.length === 0) return out;
        if (Array.isArray(this.value)) {
            this.value.forEach(function(item) {
                item.join(out, offset);
                offset += item.length;
            });
        } else {
            if (typeof this.value === "number") out[offset] = this.value; else if (typeof this.value === "string") out.write(this.value, offset); else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
            offset += this.length;
        }
        return out;
    };
}, function(module, exports, __webpack_require__) {
    var indexOf = __webpack_require__(369);
    var Object_keys = function(obj) {
        if (Object.keys) return Object.keys(obj); else {
            var res = [];
            for (var key in obj) res.push(key);
            return res;
        }
    };
    var forEach = function(xs, fn) {
        if (xs.forEach) return xs.forEach(fn); else for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
    };
    var defineProp = function() {
        try {
            Object.defineProperty({}, "_", {});
            return function(obj, name, value) {
                Object.defineProperty(obj, name, {
                    writable: true,
                    enumerable: false,
                    configurable: true,
                    value
                });
            };
        } catch (e) {
            return function(obj, name, value) {
                obj[name] = value;
            };
        }
    }();
    var globals = [ "Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape" ];
    function Context() {}
    Context.prototype = {};
    var Script = exports.Script = function NodeScript(code) {
        if (!(this instanceof Script)) return new Script(code);
        this.code = code;
    };
    Script.prototype.runInContext = function(context) {
        if (!(context instanceof Context)) {
            throw new TypeError("needs a 'context' argument.");
        }
        var iframe = document.createElement("iframe");
        if (!iframe.style) iframe.style = {};
        iframe.style.display = "none";
        document.body.appendChild(iframe);
        var win = iframe.contentWindow;
        var wEval = win.eval, wExecScript = win.execScript;
        if (!wEval && wExecScript) {
            wExecScript.call(win, "null");
            wEval = win.eval;
        }
        forEach(Object_keys(context), function(key) {
            win[key] = context[key];
        });
        forEach(globals, function(key) {
            if (context[key]) {
                win[key] = context[key];
            }
        });
        var winKeys = Object_keys(win);
        var res = wEval.call(win, this.code);
        forEach(Object_keys(win), function(key) {
            if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
            }
        });
        forEach(globals, function(key) {
            if (!(key in context)) {
                defineProp(context, key, win[key]);
            }
        });
        document.body.removeChild(iframe);
        return res;
    };
    Script.prototype.runInThisContext = function() {
        return eval(this.code);
    };
    Script.prototype.runInNewContext = function(context) {
        var ctx = Script.createContext(context);
        var res = this.runInContext(ctx);
        forEach(Object_keys(ctx), function(key) {
            context[key] = ctx[key];
        });
        return res;
    };
    forEach(Object_keys(Script.prototype), function(name) {
        exports[name] = Script[name] = function(code) {
            var s = Script(code);
            return s[name].apply(s, [].slice.call(arguments, 1));
        };
    });
    exports.createScript = function(code) {
        return exports.Script(code);
    };
    exports.createContext = Script.createContext = function(context) {
        var copy = new Context();
        if (typeof context === "object") {
            forEach(Object_keys(context), function(key) {
                copy[key] = context[key];
            });
        }
        return copy;
    };
}, function(module, exports, __webpack_require__) {
    var bn = __webpack_require__(9);
    var brorand = __webpack_require__(84);
    function MillerRabin(rand) {
        this.rand = rand || new brorand.Rand();
    }
    module.exports = MillerRabin;
    MillerRabin.create = function create(rand) {
        return new MillerRabin(rand);
    };
    MillerRabin.prototype._randbelow = function _randbelow(n) {
        var len = n.bitLength();
        var min_bytes = Math.ceil(len / 8);
        do {
            var a = new bn(this.rand.generate(min_bytes));
        } while (a.cmp(n) >= 0);
        return a;
    };
    MillerRabin.prototype._randrange = function _randrange(start, stop) {
        var size = stop.sub(start);
        return start.add(this._randbelow(size));
    };
    MillerRabin.prototype.test = function test(n, k, cb) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k) k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {}
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        var prime = true;
        for (;k > 0; k--) {
            var a = this._randrange(new bn(2), n1);
            if (cb) cb(a);
            var x = a.toRed(red).redPow(d);
            if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
            for (var i = 1; i < s; i++) {
                x = x.redSqr();
                if (x.cmp(rone) === 0) return false;
                if (x.cmp(rn1) === 0) break;
            }
            if (i === s) return false;
        }
        return prime;
    };
    MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k) k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {}
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        for (;k > 0; k--) {
            var a = this._randrange(new bn(2), n1);
            var g = n.gcd(a);
            if (g.cmpn(1) !== 0) return g;
            var x = a.toRed(red).redPow(d);
            if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
            for (var i = 1; i < s; i++) {
                x = x.redSqr();
                if (x.cmp(rone) === 0) return x.fromRed().subn(1).gcd(n);
                if (x.cmp(rn1) === 0) break;
            }
            if (i === s) {
                x = x.redSqr();
                return x.fromRed().subn(1).gcd(n);
            }
        }
        return false;
    };
}, function(module, exports, __webpack_require__) {
    var randomBytes = __webpack_require__(35);
    module.exports = findPrime;
    findPrime.simpleSieve = simpleSieve;
    findPrime.fermatTest = fermatTest;
    var BN = __webpack_require__(9);
    var TWENTYFOUR = new BN(24);
    var MillerRabin = __webpack_require__(134);
    var millerRabin = new MillerRabin();
    var ONE = new BN(1);
    var TWO = new BN(2);
    var FIVE = new BN(5);
    var SIXTEEN = new BN(16);
    var EIGHT = new BN(8);
    var TEN = new BN(10);
    var THREE = new BN(3);
    var SEVEN = new BN(7);
    var ELEVEN = new BN(11);
    var FOUR = new BN(4);
    var TWELVE = new BN(12);
    var primes = null;
    function _getPrimes() {
        if (primes !== null) return primes;
        var limit = 1048576;
        var res = [];
        res[0] = 2;
        for (var i = 1, k = 3; k < limit; k += 2) {
            var sqrt = Math.ceil(Math.sqrt(k));
            for (var j = 0; j < i && res[j] <= sqrt; j++) if (k % res[j] === 0) break;
            if (i !== j && res[j] <= sqrt) continue;
            res[i++] = k;
        }
        primes = res;
        return res;
    }
    function simpleSieve(p) {
        var primes = _getPrimes();
        for (var i = 0; i < primes.length; i++) if (p.modn(primes[i]) === 0) {
            if (p.cmpn(primes[i]) === 0) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }
    function fermatTest(p) {
        var red = BN.mont(p);
        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
    }
    function findPrime(bits, gen) {
        if (bits < 16) {
            if (gen === 2 || gen === 5) {
                return new BN([ 140, 123 ]);
            } else {
                return new BN([ 140, 39 ]);
            }
        }
        gen = new BN(gen);
        var num, n2;
        while (true) {
            num = new BN(randomBytes(Math.ceil(bits / 8)));
            while (num.bitLength() > bits) {
                num.ishrn(1);
            }
            if (num.isEven()) {
                num.iadd(ONE);
            }
            if (!num.testn(1)) {
                num.iadd(TWO);
            }
            if (!gen.cmp(TWO)) {
                while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
                    num.iadd(FOUR);
                }
            } else if (!gen.cmp(FIVE)) {
                while (num.mod(TEN).cmp(THREE)) {
                    num.iadd(FOUR);
                }
            }
            n2 = num.shrn(1);
            if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
                return num;
            }
        }
    }
}, function(module, exports, __webpack_require__) {
    var aes = __webpack_require__(61);
    var Buffer = __webpack_require__(7).Buffer;
    var Transform = __webpack_require__(23);
    var inherits = __webpack_require__(3);
    function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._cache = Buffer.allocUnsafe(0);
        this._secCache = Buffer.allocUnsafe(0);
        this._decrypt = decrypt;
        this._mode = mode;
    }
    inherits(StreamCipher, Transform);
    StreamCipher.prototype._update = function(chunk) {
        return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
        this._cipher.scrub();
    };
    module.exports = StreamCipher;
}, function(module, exports, __webpack_require__) {
    var aes = __webpack_require__(61);
    var Buffer = __webpack_require__(7).Buffer;
    var Transform = __webpack_require__(23);
    var inherits = __webpack_require__(3);
    var GHASH = __webpack_require__(379);
    var xor = __webpack_require__(41);
    var incr32 = __webpack_require__(139);
    function xorTest(a, b) {
        var out = 0;
        if (a.length !== b.length) out++;
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; ++i) {
            out += a[i] ^ b[i];
        }
        return out;
    }
    function calcIv(self, iv, ck) {
        if (iv.length === 12) {
            self._finID = Buffer.concat([ iv, Buffer.from([ 0, 0, 0, 1 ]) ]);
            return Buffer.concat([ iv, Buffer.from([ 0, 0, 0, 2 ]) ]);
        }
        var ghash = new GHASH(ck);
        var len = iv.length;
        var toPad = len % 16;
        ghash.update(iv);
        if (toPad) {
            toPad = 16 - toPad;
            ghash.update(Buffer.alloc(toPad, 0));
        }
        ghash.update(Buffer.alloc(8, 0));
        var ivBits = len * 8;
        var tail = Buffer.alloc(8);
        tail.writeUIntBE(ivBits, 0, 8);
        ghash.update(tail);
        self._finID = ghash.state;
        var out = Buffer.from(self._finID);
        incr32(out);
        return out;
    }
    function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        var h = Buffer.alloc(4, 0);
        this._cipher = new aes.AES(key);
        var ck = this._cipher.encryptBlock(h);
        this._ghash = new GHASH(ck);
        iv = calcIv(this, iv, ck);
        this._prev = Buffer.from(iv);
        this._cache = Buffer.allocUnsafe(0);
        this._secCache = Buffer.allocUnsafe(0);
        this._decrypt = decrypt;
        this._alen = 0;
        this._len = 0;
        this._mode = mode;
        this._authTag = null;
        this._called = false;
    }
    inherits(StreamCipher, Transform);
    StreamCipher.prototype._update = function(chunk) {
        if (!this._called && this._alen) {
            var rump = 16 - this._alen % 16;
            if (rump < 16) {
                rump = Buffer.alloc(rump, 0);
                this._ghash.update(rump);
            }
        }
        this._called = true;
        var out = this._mode.encrypt(this, chunk);
        if (this._decrypt) {
            this._ghash.update(chunk);
        } else {
            this._ghash.update(out);
        }
        this._len += chunk.length;
        return out;
    };
    StreamCipher.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && xorTest(tag, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = tag;
        this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
        if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = tag;
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(buf);
        this._alen += buf.length;
    };
    module.exports = StreamCipher;
}, function(module) {
    module.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
}, function(module, exports) {
    function incr32(iv) {
        var len = iv.length;
        var item;
        while (len--) {
            item = iv.readUInt8(len);
            if (item === 255) {
                iv.writeUInt8(0, len);
            } else {
                item++;
                iv.writeUInt8(item, len);
                break;
            }
        }
    }
    module.exports = incr32;
}, function(module, exports, __webpack_require__) {
    var xor = __webpack_require__(41);
    var Buffer = __webpack_require__(7).Buffer;
    var incr32 = __webpack_require__(139);
    function getBlock(self) {
        var out = self._cipher.encryptBlockRaw(self._prev);
        incr32(self._prev);
        return out;
    }
    var blockSize = 16;
    exports.encrypt = function(self, chunk) {
        var chunkNum = Math.ceil(chunk.length / blockSize);
        var start = self._cache.length;
        self._cache = Buffer.concat([ self._cache, Buffer.allocUnsafe(chunkNum * blockSize) ]);
        for (var i = 0; i < chunkNum; i++) {
            var out = getBlock(self);
            var offset = start + i * blockSize;
            self._cache.writeUInt32BE(out[0], offset + 0);
            self._cache.writeUInt32BE(out[1], offset + 4);
            self._cache.writeUInt32BE(out[2], offset + 8);
            self._cache.writeUInt32BE(out[3], offset + 12);
        }
        var pad = self._cache.slice(0, chunk.length);
        self._cache = self._cache.slice(chunk.length);
        return xor(chunk, pad);
    };
}, function(module, exports, __webpack_require__) {
    var md5 = __webpack_require__(146);
    var rmd160 = __webpack_require__(78);
    var sha = __webpack_require__(77);
    var checkParameters = __webpack_require__(143);
    var defaultEncoding = __webpack_require__(142);
    var Buffer = __webpack_require__(7).Buffer;
    var ZEROS = Buffer.alloc(128);
    var sizes = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function Hmac(alg, key, saltLen) {
        var hash = getDigest(alg);
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = hash(key);
        } else if (key.length < blocksize) {
            key = Buffer.concat([ key, ZEROS ], blocksize);
        }
        var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        for (var i = 0; i < blocksize; i++) {
            ipad[i] = key[i] ^ 54;
            opad[i] = key[i] ^ 92;
        }
        var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.hash = hash;
        this.size = sizes[alg];
    }
    Hmac.prototype.run = function(data, ipad) {
        data.copy(ipad, this.blocksize);
        var h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    };
    function getDigest(alg) {
        function shaFunc(data) {
            return sha(alg).update(data).digest();
        }
        if (alg === "rmd160" || alg === "ripemd160") return rmd160;
        if (alg === "md5") return md5;
        return shaFunc;
    }
    function pbkdf2(password, salt, iterations, keylen, digest) {
        checkParameters(password, salt, iterations, keylen);
        if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding);
        if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding);
        digest = digest || "sha1";
        var hmac = new Hmac(digest, password, salt.length);
        var DK = Buffer.allocUnsafe(keylen);
        var block1 = Buffer.allocUnsafe(salt.length + 4);
        salt.copy(block1, 0, 0, salt.length);
        var destPos = 0;
        var hLen = sizes[digest];
        var l = Math.ceil(keylen / hLen);
        for (var i = 1; i <= l; i++) {
            block1.writeUInt32BE(i, salt.length);
            var T = hmac.run(block1, hmac.ipad1);
            var U = T;
            for (var j = 1; j < iterations; j++) {
                U = hmac.run(U, hmac.ipad2);
                for (var k = 0; k < hLen; k++) T[k] ^= U[k];
            }
            T.copy(DK, destPos);
            destPos += hLen;
        }
        return DK;
    }
    module.exports = pbkdf2;
}, function(module, exports, __webpack_require__) {
    (function(process) {
        var defaultEncoding;
        if (process.browser) {
            defaultEncoding = "utf-8";
        } else {
            var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
            defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
        }
        module.exports = defaultEncoding;
    }).call(this, __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var MAX_ALLOC = Math.pow(2, 30) - 1;
        function checkBuffer(buf, name) {
            if (typeof buf !== "string" && !Buffer.isBuffer(buf)) {
                throw new TypeError(name + " must be a buffer or string");
            }
        }
        module.exports = function(password, salt, iterations, keylen) {
            checkBuffer(password, "Password");
            checkBuffer(salt, "Salt");
            if (typeof iterations !== "number") {
                throw new TypeError("Iterations not a number");
            }
            if (iterations < 0) {
                throw new TypeError("Bad iterations");
            }
            if (typeof keylen !== "number") {
                throw new TypeError("Key length not a number");
            }
            if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
                throw new TypeError("Bad key length");
            }
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    exports.pbkdf2 = __webpack_require__(394);
    exports.pbkdf2Sync = __webpack_require__(141);
}, function(module) {
    module.exports = {
        sha224WithRSAEncryption: {
            sign: "rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        "RSA-SHA224": {
            sign: "ecdsa/rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        sha256WithRSAEncryption: {
            sign: "rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        "RSA-SHA256": {
            sign: "ecdsa/rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        sha384WithRSAEncryption: {
            sign: "rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        "RSA-SHA384": {
            sign: "ecdsa/rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        sha512WithRSAEncryption: {
            sign: "rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA512": {
            sign: "ecdsa/rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA1": {
            sign: "rsa",
            hash: "sha1",
            id: "3021300906052b0e03021a05000414"
        },
        "ecdsa-with-SHA1": {
            sign: "ecdsa",
            hash: "sha1",
            id: ""
        },
        sha256: {
            sign: "ecdsa",
            hash: "sha256",
            id: ""
        },
        sha224: {
            sign: "ecdsa",
            hash: "sha224",
            id: ""
        },
        sha384: {
            sign: "ecdsa",
            hash: "sha384",
            id: ""
        },
        sha512: {
            sign: "ecdsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-SHA1": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        DSA: {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-WITH-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-WITH-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-WITH-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-WITH-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-RIPEMD160": {
            sign: "dsa",
            hash: "rmd160",
            id: ""
        },
        ripemd160WithRSA: {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        "RSA-RIPEMD160": {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        md5WithRSAEncryption: {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        },
        "RSA-MD5": {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        }
    };
}, function(module, exports, __webpack_require__) {
    var MD5 = __webpack_require__(83);
    module.exports = function(buffer) {
        return new MD5().update(buffer).digest();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var inherits = __webpack_require__(3);
    var Legacy = __webpack_require__(396);
    var Base = __webpack_require__(23);
    var Buffer = __webpack_require__(7).Buffer;
    var md5 = __webpack_require__(146);
    var RIPEMD160 = __webpack_require__(78);
    var sha = __webpack_require__(77);
    var ZEROS = Buffer.alloc(128);
    function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
            key = Buffer.from(key);
        }
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
            var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
            key = hash.update(key).digest();
        } else if (key.length < blocksize) {
            key = Buffer.concat([ key, ZEROS ], blocksize);
        }
        var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
        var opad = this._opad = Buffer.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
            ipad[i] = key[i] ^ 54;
            opad[i] = key[i] ^ 92;
        }
        this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        this._hash.update(ipad);
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
        this._hash.update(data);
    };
    Hmac.prototype._final = function() {
        var h = this._hash.digest();
        var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
        return hash.update(this._opad).update(h).digest();
    };
    module.exports = function createHmac(alg, key) {
        alg = alg.toLowerCase();
        if (alg === "rmd160" || alg === "ripemd160") {
            return new Hmac("rmd160", key);
        }
        if (alg === "md5") {
            return new Legacy(md5, key);
        }
        return new Hmac(alg, key);
    };
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Hash = __webpack_require__(34);
    var Buffer = __webpack_require__(7).Buffer;
    var K = [ 1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591 ];
    var W = new Array(160);
    function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
    };
    function Ch(x, y, z) {
        return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
        return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
        var W = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
            W[i] = M.readInt32BE(i * 4);
            W[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (;i < 160; i += 2) {
            var xh = W[i - 15 * 2];
            var xl = W[i - 15 * 2 + 1];
            var gamma0 = Gamma0(xh, xl);
            var gamma0l = Gamma0l(xl, xh);
            xh = W[i - 2 * 2];
            xl = W[i - 2 * 2 + 1];
            var gamma1 = Gamma1(xh, xl);
            var gamma1l = Gamma1l(xl, xh);
            var Wi7h = W[i - 7 * 2];
            var Wi7l = W[i - 7 * 2 + 1];
            var Wi16h = W[i - 16 * 2];
            var Wi16l = W[i - 16 * 2 + 1];
            var Wil = gamma0l + Wi7l | 0;
            var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
            Wil = Wil + gamma1l | 0;
            Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
            Wil = Wil + Wi16l | 0;
            Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
            W[i] = Wih;
            W[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
            Wih = W[j];
            Wil = W[j + 1];
            var majh = maj(ah, bh, ch);
            var majl = maj(al, bl, cl);
            var sigma0h = sigma0(ah, al);
            var sigma0l = sigma0(al, ah);
            var sigma1h = sigma1(eh, el);
            var sigma1l = sigma1(el, eh);
            var Kih = K[j];
            var Kil = K[j + 1];
            var chh = Ch(eh, fh, gh);
            var chl = Ch(el, fl, gl);
            var t1l = hl + sigma1l | 0;
            var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
            t1l = t1l + chl | 0;
            t1h = t1h + chh + getCarry(t1l, chl) | 0;
            t1l = t1l + Kil | 0;
            t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
            t1l = t1l + Wil | 0;
            t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
            var t2l = sigma0l + majl | 0;
            var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
            hh = gh;
            hl = gl;
            gh = fh;
            gl = fl;
            fh = eh;
            fl = el;
            el = dl + t1l | 0;
            eh = dh + t1h + getCarry(el, dl) | 0;
            dh = ch;
            dl = cl;
            ch = bh;
            cl = bl;
            bh = ah;
            bl = al;
            al = t1l + t2l | 0;
            ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
        var H = Buffer.allocUnsafe(64);
        function writeInt64BE(h, l, offset) {
            H.writeInt32BE(h, offset);
            H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
    };
    module.exports = Sha512;
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Hash = __webpack_require__(34);
    var Buffer = __webpack_require__(7).Buffer;
    var K = [ 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 ];
    var W = new Array(64);
    function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
    };
    function ch(x, y, z) {
        return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
        return x & y | z & (x | y);
    }
    function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
        var W = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h = this._h | 0;
        for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
        for (;i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
        for (var j = 0; j < 64; ++j) {
            var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
            var T2 = sigma0(a) + maj(a, b, c) | 0;
            h = g;
            g = f;
            f = e;
            e = d + T1 | 0;
            d = c;
            c = b;
            b = a;
            a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
        var H = Buffer.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
    };
    module.exports = Sha256;
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = Transform;
    var Duplex = __webpack_require__(26);
    var util = __webpack_require__(42);
    util.inherits = __webpack_require__(3);
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) {
            return this.emit("error", new Error("write callback called multiple times"));
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null) this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
        }
    }
    function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
            if (typeof options.transform === "function") this._transform = options.transform;
            if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
    }
    function prefinish() {
        var _this = this;
        if (typeof this._flush === "function") {
            this._flush(function(er, data) {
                done(_this, er, data);
            });
        } else {
            done(this, null, null);
        }
    }
    Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
    };
    Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
            ts.needTransform = true;
        }
    };
    Transform.prototype._destroy = function(err, cb) {
        var _this2 = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
            _this2.emit("close");
        });
    };
    function done(stream, er, data) {
        if (er) return stream.emit("error", er);
        if (data != null) stream.push(data);
        if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return stream.push(null);
    }
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
        var apply = Function.prototype.apply;
        exports.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
        };
        exports.setInterval = function() {
            return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
        };
        exports.clearTimeout = exports.clearInterval = function(timeout) {
            if (timeout) {
                timeout.close();
            }
        };
        function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
        }
        Timeout.prototype.unref = Timeout.prototype.ref = function() {};
        Timeout.prototype.close = function() {
            this._clearFn.call(scope, this._id);
        };
        exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
        };
        exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
        };
        exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout) item._onTimeout();
                }, msecs);
            }
        };
        __webpack_require__(407);
        exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
        exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
    }).call(this, __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var pna = __webpack_require__(62);
    function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
            if (cb) {
                cb(err);
            } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
                pna.nextTick(emitErrorNT, this, err);
            }
            return this;
        }
        if (this._readableState) {
            this._readableState.destroyed = true;
        }
        if (this._writableState) {
            this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err) {
            if (!cb && err) {
                pna.nextTick(emitErrorNT, _this, err);
                if (_this._writableState) {
                    _this._writableState.errorEmitted = true;
                }
            } else if (cb) {
                cb(err);
            }
        });
        return this;
    }
    function undestroy() {
        if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
        }
        if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
        }
    }
    function emitErrorNT(self, err) {
        self.emit("error", err);
    }
    module.exports = {
        destroy,
        undestroy
    };
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(82).EventEmitter;
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(global, process) {
        var pna = __webpack_require__(62);
        module.exports = Readable;
        var isArray = __webpack_require__(165);
        var Duplex;
        Readable.ReadableState = ReadableState;
        var EE = __webpack_require__(82).EventEmitter;
        var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length;
        };
        var Stream = __webpack_require__(153);
        var Buffer = __webpack_require__(7).Buffer;
        var OurUint8Array = global.Uint8Array || function() {};
        function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var util = __webpack_require__(42);
        util.inherits = __webpack_require__(3);
        var debugUtil = __webpack_require__(410);
        var debug = void 0;
        if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
        } else {
            debug = function() {};
        }
        var BufferList = __webpack_require__(409);
        var destroyImpl = __webpack_require__(152);
        var StringDecoder;
        util.inherits(Readable, Stream);
        var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];
        function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [ fn, emitter._events[event] ];
        }
        function ReadableState(options, stream) {
            Duplex = Duplex || __webpack_require__(26);
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
            var hwm = options.highWaterMark;
            var readableHwm = options.readableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
                if (!StringDecoder) StringDecoder = __webpack_require__(79).StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
            }
        }
        function Readable(options) {
            Duplex = Duplex || __webpack_require__(26);
            if (!(this instanceof Readable)) return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            if (options) {
                if (typeof options.read === "function") this._read = options.read;
                if (typeof options.destroy === "function") this._destroy = options.destroy;
            }
            Stream.call(this);
        }
        Object.defineProperty(Readable.prototype, "destroyed", {
            get: function() {
                if (this._readableState === undefined) {
                    return false;
                }
                return this._readableState.destroyed;
            },
            set: function(value) {
                if (!this._readableState) {
                    return;
                }
                this._readableState.destroyed = value;
            }
        });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;
        Readable.prototype._destroy = function(err, cb) {
            this.push(null);
            cb(err);
        };
        Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
                if (typeof chunk === "string") {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                        chunk = Buffer.from(chunk, encoding);
                        encoding = "";
                    }
                    skipChunkCheck = true;
                }
            } else {
                skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        };
        Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
        };
        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;
            if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
            } else {
                var er;
                if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                if (er) {
                    stream.emit("error", er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                        chunk = _uint8ArrayToBuffer(chunk);
                    }
                    if (addToFront) {
                        if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event")); else addChunk(stream, state, chunk, true);
                    } else if (state.ended) {
                        stream.emit("error", new Error("stream.push() after EOF"));
                    } else {
                        state.reading = false;
                        if (state.decoder && !encoding) {
                            chunk = state.decoder.write(chunk);
                            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                        } else {
                            addChunk(stream, state, chunk, false);
                        }
                    }
                } else if (!addToFront) {
                    state.reading = false;
                }
            }
            return needMoreData(state);
        }
        function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
            } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);
                if (state.needReadable) emitReadable(stream);
            }
            maybeReadMore(stream, state);
        }
        function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
                er = new TypeError("Invalid non-string/buffer chunk");
            }
            return er;
        }
        function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
        }
        Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
        };
        Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder) StringDecoder = __webpack_require__(79).StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
        };
        var MAX_HWM = 8388608;
        function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
                n = MAX_HWM;
            } else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
            }
            return n;
        }
        function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended) return 0;
            if (state.objectMode) return 1;
            if (n !== n) {
                if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
            }
            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length) return n;
            if (!state.ended) {
                state.needReadable = true;
                return 0;
            }
            return state.length;
        }
        Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0) state.emittedReadable = false;
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
                return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
                if (state.length === 0) endReadable(this);
                return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
            } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0) state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading) n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0) ret = fromList(n, state); else ret = null;
            if (ret === null) {
                state.needReadable = true;
                n = 0;
            } else {
                state.length -= n;
            }
            if (state.length === 0) {
                if (!state.ended) state.needReadable = true;
                if (nOrig !== n && state.ended) endReadable(this);
            }
            if (ret !== null) this.emit("data", ret);
            return ret;
        };
        function onEofChunk(stream, state) {
            if (state.ended) return;
            if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                }
            }
            state.ended = true;
            emitReadable(stream);
        }
        function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                if (state.sync) pna.nextTick(emitReadable_, stream); else emitReadable_(stream);
            }
        }
        function emitReadable_(stream) {
            debug("emit readable");
            stream.emit("readable");
            flow(stream);
        }
        function maybeReadMore(stream, state) {
            if (!state.readingMore) {
                state.readingMore = true;
                pna.nextTick(maybeReadMore_, stream, state);
            }
        }
        function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length) break; else len = state.length;
            }
            state.readingMore = false;
        }
        Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"));
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;

              case 1:
                state.pipes = [ state.pipes, dest ];
                break;

              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted) pna.nextTick(endFn); else src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                    if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                        unpipeInfo.hasUnpiped = true;
                        cleanup();
                    }
                }
            }
            function onend() {
                debug("onend");
                dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
            }
            var increasedAwaitDrain = false;
            src.on("data", ondata);
            function ondata(chunk) {
                debug("ondata");
                increasedAwaitDrain = false;
                var ret = dest.write(chunk);
                if (false === ret && !increasedAwaitDrain) {
                    if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                        debug("false write response, pause", src._readableState.awaitDrain);
                        src._readableState.awaitDrain++;
                        increasedAwaitDrain = true;
                    }
                    src.pause();
                }
            }
            function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
                debug("pipe resume");
                src.resume();
            }
            return dest;
        };
        function pipeOnDrain(src) {
            return function() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain) state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                    state.flowing = true;
                    flow(src);
                }
            };
        }
        Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = {
                hasUnpiped: false
            };
            if (state.pipesCount === 0) return this;
            if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes) return this;
                if (!dest) dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest) dest.emit("unpipe", this, unpipeInfo);
                return this;
            }
            if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) {
                    dests[i].emit("unpipe", this, unpipeInfo);
                }
                return this;
            }
            var index = indexOf(state.pipes, dest);
            if (index === -1) return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1) state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
        };
        Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === "data") {
                if (this._readableState.flowing !== false) this.resume();
            } else if (ev === "readable") {
                var state = this._readableState;
                if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true;
                    state.emittedReadable = false;
                    if (!state.reading) {
                        pna.nextTick(nReadingNextTick, this);
                    } else if (state.length) {
                        emitReadable(this);
                    }
                }
            }
            return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;
        function nReadingNextTick(self) {
            debug("readable nexttick read 0");
            self.read(0);
        }
        Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
                debug("resume");
                state.flowing = true;
                resume(this, state);
            }
            return this;
        };
        function resume(stream, state) {
            if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                pna.nextTick(resume_, stream, state);
            }
        }
        function resume_(stream, state) {
            if (!state.reading) {
                debug("resume read 0");
                stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading) stream.read(0);
        }
        Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (false !== this._readableState.flowing) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
            }
            return this;
        };
        function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {}
        }
        Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) _this.push(chunk);
                }
                _this.push(null);
            });
            stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder) chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;
                var ret = _this.push(chunk);
                if (!ret) {
                    paused = true;
                    stream.pause();
                }
            });
            for (var i in stream) {
                if (this[i] === undefined && typeof stream[i] === "function") {
                    this[i] = function(method) {
                        return function() {
                            return stream[method].apply(stream, arguments);
                        };
                    }(i);
                }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
                stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n) {
                debug("wrapped _read", n);
                if (paused) {
                    paused = false;
                    stream.resume();
                }
            };
            return this;
        };
        Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            enumerable: false,
            get: function() {
                return this._readableState.highWaterMark;
            }
        });
        Readable._fromList = fromList;
        function fromList(n, state) {
            if (state.length === 0) return null;
            var ret;
            if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
                if (state.decoder) ret = state.buffer.join(""); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);
                state.buffer.clear();
            } else {
                ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
        }
        function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
                ret = list.head.data.slice(0, n);
                list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
                ret = list.shift();
            } else {
                ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }
            return ret;
        }
        function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
                var str = p.data;
                var nb = n > str.length ? str.length : n;
                if (nb === str.length) ret += str; else ret += str.slice(0, n);
                n -= nb;
                if (n === 0) {
                    if (nb === str.length) {
                        ++c;
                        if (p.next) list.head = p.next; else list.head = list.tail = null;
                    } else {
                        list.head = p;
                        p.data = str.slice(nb);
                    }
                    break;
                }
                ++c;
            }
            list.length -= c;
            return ret;
        }
        function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
                var buf = p.data;
                var nb = n > buf.length ? buf.length : n;
                buf.copy(ret, ret.length - n, 0, nb);
                n -= nb;
                if (n === 0) {
                    if (nb === buf.length) {
                        ++c;
                        if (p.next) list.head = p.next; else list.head = list.tail = null;
                    } else {
                        list.head = p;
                        p.data = buf.slice(nb);
                    }
                    break;
                }
                ++c;
            }
            list.length -= c;
            return ret;
        }
        function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
                state.ended = true;
                pna.nextTick(endReadableNT, state, stream);
            }
        }
        function endReadableNT(state, stream) {
            if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
            }
        }
        function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
            }
            return -1;
        }
    }).call(this, __webpack_require__(12), __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Buffer = __webpack_require__(7).Buffer;
    var Transform = __webpack_require__(43).Transform;
    var inherits = __webpack_require__(3);
    function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer.isBuffer(val) && typeof val !== "string") {
            throw new TypeError(prefix + " must be a string or a buffer");
        }
    }
    function HashBase(blockSize) {
        Transform.call(this);
        this._block = Buffer.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [ 0, 0, 0, 0 ];
        this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
            this.update(chunk, encoding);
        } catch (err) {
            error = err;
        }
        callback(error);
    };
    HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
            this.push(this.digest());
        } catch (err) {
            error = err;
        }
        callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized) throw new Error("Digest already called");
        if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
            for (var i = this._blockOffset; i < this._blockSize; ) block[i++] = data[offset++];
            this._update();
            this._blockOffset = 0;
        }
        while (offset < data.length) block[this._blockOffset++] = data[offset++];
        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
            this._length[j] += carry;
            carry = this._length[j] / 4294967296 | 0;
            if (carry > 0) this._length[j] -= 4294967296 * carry;
        }
        return this;
    };
    HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== undefined) digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i) this._length[i] = 0;
        return digest;
    };
    HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var common = __webpack_require__(45);
    var assert = __webpack_require__(15);
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [ 1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591 ];
    function SHA512() {
        if (!(this instanceof SHA512)) return new SHA512();
        BlockHash.call(this);
        this.h = [ 1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209 ];
        this.k = sha512_K;
        this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++) W[i] = msg[start + i];
        for (;i < W.length; i += 2) {
            var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
            var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
            var c1_hi = W[i - 14];
            var c1_lo = W[i - 13];
            var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
            var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
            var c3_hi = W[i - 32];
            var c3_lo = W[i - 31];
            W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
            W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
    };
    SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
            var c0_hi = hh;
            var c0_lo = hl;
            var c1_hi = s1_512_hi(eh, el);
            var c1_lo = s1_512_lo(eh, el);
            var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
            var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
            var c3_hi = this.k[i];
            var c3_lo = this.k[i + 1];
            var c4_hi = W[i];
            var c4_lo = W[i + 1];
            var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
            var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
            c0_hi = s0_512_hi(ah, al);
            c0_lo = s0_512_lo(ah, al);
            c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
            c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
            var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
            var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
            hh = gh;
            hl = gl;
            gh = fh;
            gl = fl;
            fh = eh;
            fl = el;
            eh = sum64_hi(dh, dl, T1_hi, T1_lo);
            el = sum64_lo(dl, dl, T1_hi, T1_lo);
            dh = ch;
            dl = cl;
            ch = bh;
            cl = bl;
            bh = ah;
            bl = al;
            ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
            al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils.toHex32(this.h, "big"); else return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0) r += 4294967296;
        return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0) r += 4294967296;
        return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0) r += 4294967296;
        return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var common = __webpack_require__(45);
    var shaCommon = __webpack_require__(158);
    var assert = __webpack_require__(15);
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [ 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 ];
    function SHA256() {
        if (!(this instanceof SHA256)) return new SHA256();
        BlockHash.call(this);
        this.h = [ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ];
        this.k = sha256_K;
        this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) W[i] = msg[start + i];
        for (;i < W.length; i++) W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
            var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
            var T2 = sum32(s0_256(a), maj32(a, b, c));
            h = g;
            g = f;
            f = e;
            e = sum32(d, T1);
            d = c;
            c = b;
            b = a;
            a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils.toHex32(this.h, "big"); else return utils.split32(this.h, "big");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
        if (s === 0) return ch32(x, y, z);
        if (s === 1 || s === 3) return p32(x, y, z);
        if (s === 2) return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
        return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
        return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
        if (Array.isArray(msg)) return msg.slice();
        if (!msg) return [];
        var res = [];
        if (typeof msg !== "string") {
            for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
            return res;
        }
        if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/gi, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
            for (var i = 0; i < msg.length; i++) {
                var c = msg.charCodeAt(i);
                var hi = c >> 8;
                var lo = c & 255;
                if (hi) res.push(hi, lo); else res.push(lo);
            }
        }
        return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
        if (word.length === 1) return "0" + word; else return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
        return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
        if (enc === "hex") return toHex(arr); else return arr;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.IAT_SKEW = undefined;
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    exports.createJWT = createJWT;
    exports.verifyJWT = verifyJWT;
    var _jsontokens = __webpack_require__(86);
    var _mnid = __webpack_require__(55);
    var _base64url = __webpack_require__(64);
    var _base64url2 = _interopRequireDefault(_base64url);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var JOSE_HEADER = {
        typ: "JWT",
        alg: "ES256K"
    };
    function encodeSection(data) {
        return _base64url2.default.encode(JSON.stringify(data));
    }
    var ENCODED_HEADER = encodeSection(JOSE_HEADER);
    var LEGACY_MS = 1e12;
    var IAT_SKEW = exports.IAT_SKEW = 60;
    function createJWT(_ref, payload) {
        var address = _ref.address, signer = _ref.signer;
        var signingInput = [ ENCODED_HEADER, encodeSection(_extends({
            iss: address,
            iat: Math.floor(Date.now() / 1e3)
        }, payload)) ].join(".");
        return new Promise(function(resolve, reject) {
            if (!signer) return reject(new Error("No Signer functionality has been configured"));
            if (!address) return reject(new Error("No application identity address has been configured"));
            return signer(signingInput, function(error, signature) {
                if (error) return reject(error);
                resolve([ signingInput, signature ].join("."));
            });
        });
    }
    function verifyJWT(_ref2, jwt) {
        var registry = _ref2.registry, address = _ref2.address;
        var callbackUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        return new Promise(function(resolve, reject) {
            var _decodeToken = (0, _jsontokens.decodeToken)(jwt), payload = _decodeToken.payload;
            registry(payload.iss).then(function(profile) {
                if (!profile) return reject(new Error("No profile found, unable to verify JWT"));
                var publicKey = profile.publicKey.match(/^0x/) ? profile.publicKey.slice(2) : profile.publicKey;
                var verifier = new _jsontokens.TokenVerifier("ES256K", publicKey);
                if (verifier.verify(jwt)) {
                    if (payload.iat >= LEGACY_MS && payload.iat > Date.now() + IAT_SKEW * 1e3 || payload.iat < LEGACY_MS && payload.iat > Date.now() / 1e3 + IAT_SKEW) {
                        return reject(new Error("JWT not valid yet (issued in the future): iat: " + payload.iat + " > now: " + Date.now() / 1e3));
                    }
                    if (payload.exp && payload.exp >= LEGACY_MS && payload.exp <= Date.now() || payload.iat < LEGACY_MS && payload.exp <= Date.now() / 1e3) {
                        return reject(new Error("JWT has expired: exp: " + payload.exp + " < now: " + Date.now() / 1e3));
                    }
                    if (payload.aud) {
                        if (payload.aud.match(/^0x[0-9a-fA-F]+$/) || (0, _mnid.isMNID)(payload.aud)) {
                            if (!address) {
                                return reject(new Error("JWT audience is required but your app address has not been configured"));
                            }
                            var addressHex = (0, _mnid.isMNID)(address) ? (0, _mnid.decode)(address).address : address;
                            var audHex = (0, _mnid.isMNID)(payload.aud) ? (0, _mnid.decode)(payload.aud).address : payload.aud;
                            if (audHex !== addressHex) {
                                return reject(new Error("JWT audience does not match your address: aud: " + payload.aud + " !== yours: " + address));
                            }
                        } else {
                            if (!callbackUrl) {
                                return reject(new Error("JWT audience matching your callback url is required but one wasn't passed in"));
                            }
                            if (payload.aud !== callbackUrl) {
                                return reject(new Error("JWT audience does not match the callback url: aud: " + payload.aud + " !== url: " + callbackUrl));
                            }
                        }
                    }
                    resolve({
                        payload,
                        profile,
                        jwt
                    });
                } else {
                    return reject(new Error("Signature invalid for JWT"));
                }
            }).catch(reject);
        });
    }
    exports.default = {
        createJWT,
        verifyJWT
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _Credentials = __webpack_require__(439);
    var _Credentials2 = _interopRequireDefault(_Credentials);
    var _SimpleSigner = __webpack_require__(269);
    var _SimpleSigner2 = _interopRequireDefault(_SimpleSigner);
    var _Contract = __webpack_require__(268);
    var _JWT = __webpack_require__(160);
    var _JWT2 = _interopRequireDefault(_JWT);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    module.exports = {
        Credentials: _Credentials2.default,
        SimpleSigner: _SimpleSigner2.default,
        Contract: _Contract.Contract,
        ContractFactory: _Contract.ContractFactory,
        JWT: _JWT2.default
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var hexTable = function() {
        var array = new Array(256);
        for (var i = 0; i < 256; ++i) {
            array[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
        }
        return array;
    }();
    var has = Object.prototype.hasOwnProperty;
    exports.arrayToObject = function(source, options) {
        var obj = options.plainObjects ? Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== "undefined") {
                obj[i] = source[i];
            }
        }
        return obj;
    };
    exports.merge = function(target, source, options) {
        if (!source) {
            return target;
        }
        if (typeof source !== "object") {
            if (Array.isArray(target)) {
                target.push(source);
            } else if (typeof target === "object") {
                if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                    target[source] = true;
                }
            } else {
                return [ target, source ];
            }
            return target;
        }
        if (typeof target !== "object") {
            return [ target ].concat(source);
        }
        var mergeTarget = target;
        if (Array.isArray(target) && !Array.isArray(source)) {
            mergeTarget = exports.arrayToObject(target, options);
        }
        return Object.keys(source).reduce(function(acc, key) {
            var value = source[key];
            if (has.call(acc, key)) {
                acc[key] = exports.merge(acc[key], value, options);
            } else {
                acc[key] = value;
            }
            return acc;
        }, mergeTarget);
    };
    exports.decode = function(str) {
        try {
            return decodeURIComponent(str.replace(/\+/g, " "));
        } catch (e) {
            return str;
        }
    };
    exports.encode = function(str) {
        if (str.length === 0) {
            return str;
        }
        var string = typeof str === "string" ? str : String(str);
        var out = "";
        for (var i = 0; i < string.length; ++i) {
            var c = string.charCodeAt(i);
            if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
                out += string.charAt(i);
                continue;
            }
            if (c < 128) {
                out = out + hexTable[c];
                continue;
            }
            if (c < 2048) {
                out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
                continue;
            }
            if (c < 55296 || c >= 57344) {
                out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
                continue;
            }
            i += 1;
            c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
            out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        return out;
    };
    exports.compact = function(obj, references) {
        if (typeof obj !== "object" || obj === null) {
            return obj;
        }
        var refs = references || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }
        refs.push(obj);
        if (Array.isArray(obj)) {
            var compacted = [];
            for (var i = 0; i < obj.length; ++i) {
                if (obj[i] && typeof obj[i] === "object") {
                    compacted.push(exports.compact(obj[i], refs));
                } else if (typeof obj[i] !== "undefined") {
                    compacted.push(obj[i]);
                }
            }
            return compacted;
        }
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            obj[key] = exports.compact(obj[key], refs);
        }
        return obj;
    };
    exports.isRegExp = function(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    exports.isBuffer = function(obj) {
        if (obj === null || typeof obj === "undefined") {
            return false;
        }
        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
}, function(module, exports, __webpack_require__) {
    (function(define, undefined) {
        define(function() {
            "use strict";
            var impl = {};
            impl.mobileDetectRules = {
                phones: {
                    iPhone: "\\biPhone\\b|\\biPod\\b",
                    BlackBerry: "BlackBerry|\\bBB10\\b|rim[0-9]+",
                    HTC: "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
                    Nexus: "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
                    Dell: "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
                    Motorola: "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092",
                    Samsung: "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F",
                    LG: "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323)",
                    Sony: "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
                    Asus: "Asus.*Galaxy|PadFone.*Mobile",
                    NokiaLumia: "Lumia [0-9]{3,4}",
                    Micromax: "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
                    Palm: "PalmSource|Palm",
                    Vertu: "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
                    Pantech: "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
                    Fly: "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
                    Wiko: "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
                    iMobile: "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
                    SimValley: "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
                    Wolfgang: "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
                    Alcatel: "Alcatel",
                    Nintendo: "Nintendo 3DS",
                    Amoi: "Amoi",
                    INQ: "INQ",
                    GenericPhone: "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
                },
                tablets: {
                    iPad: "iPad|iPad.*Mobile",
                    NexusTablet: "Android.*Nexus[\\s]+(7|9|10)",
                    SamsungTablet: "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y",
                    Kindle: "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk/[0-9.]+ like Chrome/[0-9.]+ (?!Mobile)",
                    SurfaceTablet: "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
                    HPTablet: "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
                    AsusTablet: "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b",
                    BlackBerryTablet: "PlayBook|RIM Tablet",
                    HTCtablet: "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
                    MotorolaTablet: "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
                    NookTablet: "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
                    AcerTablet: "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
                    ToshibaTablet: "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
                    LGTablet: "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
                    FujitsuTablet: "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
                    PrestigioTablet: "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
                    LenovoTablet: "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304F|TB-8703F",
                    DellTablet: "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
                    YarvikTablet: "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
                    MedionTablet: "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
                    ArnovaTablet: "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
                    IntensoTablet: "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
                    IRUTablet: "M702pro",
                    MegafonTablet: "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
                    EbodaTablet: "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
                    AllViewTablet: "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
                    ArchosTablet: "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
                    AinolTablet: "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
                    NokiaLumiaTablet: "Lumia 2520",
                    SonyTablet: "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP612|SOT31",
                    PhilipsTablet: "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
                    CubeTablet: "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
                    CobyTablet: "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
                    MIDTablet: "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
                    MSITablet: "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
                    SMiTTablet: "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
                    RockChipTablet: "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
                    FlyTablet: "IQ310|Fly Vision",
                    bqTablet: "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))|Maxwell.*Lite|Maxwell.*Plus",
                    HuaweiTablet: "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L",
                    NecTablet: "\\bN-06D|\\bN-08D",
                    PantechTablet: "Pantech.*P4100",
                    BronchoTablet: "Broncho.*(N701|N708|N802|a710)",
                    VersusTablet: "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
                    ZyncTablet: "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",
                    PositivoTablet: "TB07STA|TB10STA|TB07FTA|TB10FTA",
                    NabiTablet: "Android.*\\bNabi",
                    KoboTablet: "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
                    DanewTablet: "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
                    TexetTablet: "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
                    PlaystationTablet: "Playstation.*(Portable|Vita)",
                    TrekstorTablet: "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
                    PyleAudioTablet: "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
                    AdvanTablet: "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
                    DanyTechTablet: "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
                    GalapadTablet: "Android.*\\bG1\\b",
                    MicromaxTablet: "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
                    KarbonnTablet: "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
                    AllFineTablet: "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
                    PROSCANTablet: "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
                    YONESTablet: "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
                    ChangJiaTablet: "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
                    GUTablet: "TX-A1301|TX-M9002|Q702|kf026",
                    PointOfViewTablet: "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
                    OvermaxTablet: "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
                    HCLTablet: "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
                    DPSTablet: "DPS Dream 9|DPS Dual 7",
                    VistureTablet: "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
                    CrestaTablet: "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
                    MediatekTablet: "\\bMT8125|MT8389|MT8135|MT8377\\b",
                    ConcordeTablet: "Concorde([ ]+)?Tab|ConCorde ReadMan",
                    GoCleverTablet: "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
                    ModecomTablet: "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
                    VoninoTablet: "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
                    ECSTablet: "V07OT2|TM105A|S10OT1|TR10CS1",
                    StorexTablet: "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
                    VodafoneTablet: "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497",
                    EssentielBTablet: "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
                    RossMoorTablet: "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
                    iMobileTablet: "i-mobile i-note",
                    TolinoTablet: "tolino tab [0-9.]+|tolino shine",
                    AudioSonicTablet: "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
                    AMPETablet: "Android.* A78 ",
                    SkkTablet: "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
                    TecnoTablet: "TECNO P9",
                    JXDTablet: "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
                    iJoyTablet: "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
                    FX2Tablet: "FX2 PAD7|FX2 PAD10",
                    XoroTablet: "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
                    ViewsonicTablet: "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
                    VerizonTablet: "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
                    OdysTablet: "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
                    CaptivaTablet: "CAPTIVA PAD",
                    IconbitTablet: "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
                    TeclastTablet: "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
                    OndaTablet: "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+",
                    JaytechTablet: "TPC-PA762",
                    BlaupunktTablet: "Endeavour 800NG|Endeavour 1010",
                    DigmaTablet: "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
                    EvolioTablet: "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
                    LavaTablet: "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
                    AocTablet: "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
                    MpmanTablet: "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
                    CelkonTablet: "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
                    WolderTablet: "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
                    MiTablet: "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
                    NibiruTablet: "Nibiru M1|Nibiru Jupiter One",
                    NexoTablet: "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
                    LeaderTablet: "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
                    UbislateTablet: "UbiSlate[\\s]?7C",
                    PocketBookTablet: "Pocketbook",
                    KocasoTablet: "\\b(TB-1207)\\b",
                    HisenseTablet: "\\b(F5281|E2371)\\b",
                    Hudl: "Hudl HT7S3|Hudl 2",
                    TelstraTablet: "T-Hub2",
                    GenericTablet: "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b"
                },
                oss: {
                    AndroidOS: "Android",
                    BlackBerryOS: "blackberry|\\bBB10\\b|rim tablet os",
                    PalmOS: "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
                    SymbianOS: "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
                    WindowsMobileOS: "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",
                    WindowsPhoneOS: "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
                    iOS: "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
                    MeeGoOS: "MeeGo",
                    MaemoOS: "Maemo",
                    JavaOS: "J2ME/|\\bMIDP\\b|\\bCLDC\\b",
                    webOS: "webOS|hpwOS",
                    badaOS: "\\bBada\\b",
                    BREWOS: "BREW"
                },
                uas: {
                    Chrome: "\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?",
                    Dolfin: "\\bDolfin\\b",
                    Opera: "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+|Coast/[0-9.]+",
                    Skyfire: "Skyfire",
                    Edge: "Mobile Safari/[.0-9]* Edge",
                    IE: "IEMobile|MSIEMobile",
                    Firefox: "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
                    Bolt: "bolt",
                    TeaShark: "teashark",
                    Blazer: "Blazer",
                    Safari: "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
                    UCBrowser: "UC.*Browser|UCWEB",
                    baiduboxapp: "baiduboxapp",
                    baidubrowser: "baidubrowser",
                    DiigoBrowser: "DiigoBrowser",
                    Puffin: "Puffin",
                    Mercury: "\\bMercury\\b",
                    ObigoBrowser: "Obigo",
                    NetFront: "NF-Browser",
                    GenericBrowser: "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
                    PaleMoon: "Android.*PaleMoon|Mobile.*PaleMoon"
                },
                props: {
                    Mobile: "Mobile/[VER]",
                    Build: "Build/[VER]",
                    Version: "Version/[VER]",
                    VendorID: "VendorID/[VER]",
                    iPad: "iPad.*CPU[a-z ]+[VER]",
                    iPhone: "iPhone.*CPU[a-z ]+[VER]",
                    iPod: "iPod.*CPU[a-z ]+[VER]",
                    Kindle: "Kindle/[VER]",
                    Chrome: [ "Chrome/[VER]", "CriOS/[VER]", "CrMo/[VER]" ],
                    Coast: [ "Coast/[VER]" ],
                    Dolfin: "Dolfin/[VER]",
                    Firefox: [ "Firefox/[VER]", "FxiOS/[VER]" ],
                    Fennec: "Fennec/[VER]",
                    Edge: "Edge/[VER]",
                    IE: [ "IEMobile/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident/[0-9.]+;.*rv:[VER]" ],
                    NetFront: "NetFront/[VER]",
                    NokiaBrowser: "NokiaBrowser/[VER]",
                    Opera: [ " OPR/[VER]", "Opera Mini/[VER]", "Version/[VER]" ],
                    "Opera Mini": "Opera Mini/[VER]",
                    "Opera Mobi": "Version/[VER]",
                    UCBrowser: [ "UCWEB[VER]", "UC.*Browser/[VER]" ],
                    MQQBrowser: "MQQBrowser/[VER]",
                    MicroMessenger: "MicroMessenger/[VER]",
                    baiduboxapp: "baiduboxapp/[VER]",
                    baidubrowser: "baidubrowser/[VER]",
                    SamsungBrowser: "SamsungBrowser/[VER]",
                    Iron: "Iron/[VER]",
                    Safari: [ "Version/[VER]", "Safari/[VER]" ],
                    Skyfire: "Skyfire/[VER]",
                    Tizen: "Tizen/[VER]",
                    Webkit: "webkit[ /][VER]",
                    PaleMoon: "PaleMoon/[VER]",
                    Gecko: "Gecko/[VER]",
                    Trident: "Trident/[VER]",
                    Presto: "Presto/[VER]",
                    Goanna: "Goanna/[VER]",
                    iOS: " \\bi?OS\\b [VER][ ;]{1}",
                    Android: "Android [VER]",
                    BlackBerry: [ "BlackBerry[\\w]+/[VER]", "BlackBerry.*Version/[VER]", "Version/[VER]" ],
                    BREW: "BREW [VER]",
                    Java: "Java/[VER]",
                    "Windows Phone OS": [ "Windows Phone OS [VER]", "Windows Phone [VER]" ],
                    "Windows Phone": "Windows Phone [VER]",
                    "Windows CE": "Windows CE/[VER]",
                    "Windows NT": "Windows NT [VER]",
                    Symbian: [ "SymbianOS/[VER]", "Symbian/[VER]" ],
                    webOS: [ "webOS/[VER]", "hpwOS/[VER];" ]
                },
                utils: {
                    Bot: "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",
                    MobileBot: "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2",
                    DesktopMode: "WPDesktop",
                    TV: "SonyDTV|HbbTV",
                    WebKit: "(webkit)[ /]([\\w.]+)",
                    Console: "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|PLAYSTATION|Xbox)\\b",
                    Watch: "SM-V700"
                }
            };
            impl.detectMobileBrowsers = {
                fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
                shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
                tabletPattern: /android|ipad|playbook|silk/i
            };
            var hasOwnProp = Object.prototype.hasOwnProperty, isArray;
            impl.FALLBACK_PHONE = "UnknownPhone";
            impl.FALLBACK_TABLET = "UnknownTablet";
            impl.FALLBACK_MOBILE = "UnknownMobile";
            isArray = "isArray" in Array ? Array.isArray : function(value) {
                return Object.prototype.toString.call(value) === "[object Array]";
            };
            function equalIC(a, b) {
                return a != null && b != null && a.toLowerCase() === b.toLowerCase();
            }
            function containsIC(array, value) {
                var valueLC, i, len = array.length;
                if (!len || !value) {
                    return false;
                }
                valueLC = value.toLowerCase();
                for (i = 0; i < len; ++i) {
                    if (valueLC === array[i].toLowerCase()) {
                        return true;
                    }
                }
                return false;
            }
            function convertPropsToRegExp(object) {
                for (var key in object) {
                    if (hasOwnProp.call(object, key)) {
                        object[key] = new RegExp(object[key], "i");
                    }
                }
            }
            function prepareUserAgent(userAgent) {
                return (userAgent || "").substr(0, 500);
            }
            (function init() {
                var key, values, value, i, len, verPos, mobileDetectRules = impl.mobileDetectRules;
                for (key in mobileDetectRules.props) {
                    if (hasOwnProp.call(mobileDetectRules.props, key)) {
                        values = mobileDetectRules.props[key];
                        if (!isArray(values)) {
                            values = [ values ];
                        }
                        len = values.length;
                        for (i = 0; i < len; ++i) {
                            value = values[i];
                            verPos = value.indexOf("[VER]");
                            if (verPos >= 0) {
                                value = value.substring(0, verPos) + "([\\w._\\+]+)" + value.substring(verPos + 5);
                            }
                            values[i] = new RegExp(value, "i");
                        }
                        mobileDetectRules.props[key] = values;
                    }
                }
                convertPropsToRegExp(mobileDetectRules.oss);
                convertPropsToRegExp(mobileDetectRules.phones);
                convertPropsToRegExp(mobileDetectRules.tablets);
                convertPropsToRegExp(mobileDetectRules.uas);
                convertPropsToRegExp(mobileDetectRules.utils);
                mobileDetectRules.oss0 = {
                    WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
                    WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
                };
            })();
            impl.findMatch = function(rules, userAgent) {
                for (var key in rules) {
                    if (hasOwnProp.call(rules, key)) {
                        if (rules[key].test(userAgent)) {
                            return key;
                        }
                    }
                }
                return null;
            };
            impl.findMatches = function(rules, userAgent) {
                var result = [];
                for (var key in rules) {
                    if (hasOwnProp.call(rules, key)) {
                        if (rules[key].test(userAgent)) {
                            result.push(key);
                        }
                    }
                }
                return result;
            };
            impl.getVersionStr = function(propertyName, userAgent) {
                var props = impl.mobileDetectRules.props, patterns, i, len, match;
                if (hasOwnProp.call(props, propertyName)) {
                    patterns = props[propertyName];
                    len = patterns.length;
                    for (i = 0; i < len; ++i) {
                        match = patterns[i].exec(userAgent);
                        if (match !== null) {
                            return match[1];
                        }
                    }
                }
                return null;
            };
            impl.getVersion = function(propertyName, userAgent) {
                var version = impl.getVersionStr(propertyName, userAgent);
                return version ? impl.prepareVersionNo(version) : NaN;
            };
            impl.prepareVersionNo = function(version) {
                var numbers;
                numbers = version.split(/[a-z._ \/\-]/i);
                if (numbers.length === 1) {
                    version = numbers[0];
                }
                if (numbers.length > 1) {
                    version = numbers[0] + ".";
                    numbers.shift();
                    version += numbers.join("");
                }
                return Number(version);
            };
            impl.isMobileFallback = function(userAgent) {
                return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
            };
            impl.isTabletFallback = function(userAgent) {
                return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
            };
            impl.prepareDetectionCache = function(cache, userAgent, maxPhoneWidth) {
                if (cache.mobile !== undefined) {
                    return;
                }
                var phone, tablet, phoneSized;
                tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
                if (tablet) {
                    cache.mobile = cache.tablet = tablet;
                    cache.phone = null;
                    return;
                }
                phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
                if (phone) {
                    cache.mobile = cache.phone = phone;
                    cache.tablet = null;
                    return;
                }
                if (impl.isMobileFallback(userAgent)) {
                    phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
                    if (phoneSized === undefined) {
                        cache.mobile = impl.FALLBACK_MOBILE;
                        cache.tablet = cache.phone = null;
                    } else if (phoneSized) {
                        cache.mobile = cache.phone = impl.FALLBACK_PHONE;
                        cache.tablet = null;
                    } else {
                        cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                        cache.phone = null;
                    }
                } else if (impl.isTabletFallback(userAgent)) {
                    cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                    cache.phone = null;
                } else {
                    cache.mobile = cache.tablet = cache.phone = null;
                }
            };
            impl.mobileGrade = function(t) {
                var $isMobile = t.mobile() !== null;
                if (t.os("iOS") && t.version("iPad") >= 4.3 || t.os("iOS") && t.version("iPhone") >= 3.1 || t.os("iOS") && t.version("iPod") >= 3.1 || t.version("Android") > 2.1 && t.is("Webkit") || t.version("Windows Phone OS") >= 7 || t.is("BlackBerry") && t.version("BlackBerry") >= 6 || t.match("Playbook.*Tablet") || t.version("webOS") >= 1.4 && t.match("Palm|Pre|Pixi") || t.match("hp.*TouchPad") || t.is("Firefox") && t.version("Firefox") >= 12 || t.is("Chrome") && t.is("AndroidOS") && t.version("Android") >= 4 || t.is("Skyfire") && t.version("Skyfire") >= 4.1 && t.is("AndroidOS") && t.version("Android") >= 2.3 || t.is("Opera") && t.version("Opera Mobi") > 11 && t.is("AndroidOS") || t.is("MeeGoOS") || t.is("Tizen") || t.is("Dolfin") && t.version("Bada") >= 2 || (t.is("UC Browser") || t.is("Dolfin")) && t.version("Android") >= 2.3 || (t.match("Kindle Fire") || t.is("Kindle") && t.version("Kindle") >= 3) || t.is("AndroidOS") && t.is("NookTablet") || t.version("Chrome") >= 11 && !$isMobile || t.version("Safari") >= 5 && !$isMobile || t.version("Firefox") >= 4 && !$isMobile || t.version("MSIE") >= 7 && !$isMobile || t.version("Opera") >= 10 && !$isMobile) {
                    return "A";
                }
                if (t.os("iOS") && t.version("iPad") < 4.3 || t.os("iOS") && t.version("iPhone") < 3.1 || t.os("iOS") && t.version("iPod") < 3.1 || t.is("Blackberry") && t.version("BlackBerry") >= 5 && t.version("BlackBerry") < 6 || t.version("Opera Mini") >= 5 && t.version("Opera Mini") <= 6.5 && (t.version("Android") >= 2.3 || t.is("iOS")) || t.match("NokiaN8|NokiaC7|N97.*Series60|Symbian/3") || t.version("Opera Mobi") >= 11 && t.is("SymbianOS")) {
                    return "B";
                }
                if (t.version("BlackBerry") < 5 || t.match("MSIEMobile|Windows CE.*Mobile") || t.version("Windows Mobile") <= 5.2) {
                    return "C";
                }
                return "C";
            };
            impl.detectOS = function(ua) {
                return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
            };
            impl.getDeviceSmallerSide = function() {
                return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
            };
            function MobileDetect(userAgent, maxPhoneWidth) {
                this.ua = prepareUserAgent(userAgent);
                this._cache = {};
                this.maxPhoneWidth = maxPhoneWidth || 600;
            }
            MobileDetect.prototype = {
                constructor: MobileDetect,
                mobile: function() {
                    impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                    return this._cache.mobile;
                },
                phone: function() {
                    impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                    return this._cache.phone;
                },
                tablet: function() {
                    impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                    return this._cache.tablet;
                },
                userAgent: function() {
                    if (this._cache.userAgent === undefined) {
                        this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
                    }
                    return this._cache.userAgent;
                },
                userAgents: function() {
                    if (this._cache.userAgents === undefined) {
                        this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
                    }
                    return this._cache.userAgents;
                },
                os: function() {
                    if (this._cache.os === undefined) {
                        this._cache.os = impl.detectOS(this.ua);
                    }
                    return this._cache.os;
                },
                version: function(key) {
                    return impl.getVersion(key, this.ua);
                },
                versionStr: function(key) {
                    return impl.getVersionStr(key, this.ua);
                },
                is: function(key) {
                    return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
                },
                match: function(pattern) {
                    if (!(pattern instanceof RegExp)) {
                        pattern = new RegExp(pattern, "i");
                    }
                    return pattern.test(this.ua);
                },
                isPhoneSized: function(maxPhoneWidth) {
                    return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
                },
                mobileGrade: function() {
                    if (this._cache.grade === undefined) {
                        this._cache.grade = impl.mobileGrade(this);
                    }
                    return this._cache.grade;
                }
            };
            if (typeof window !== "undefined" && window.screen) {
                MobileDetect.isPhoneSized = function(maxPhoneWidth) {
                    return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
                };
            } else {
                MobileDetect.isPhoneSized = function() {};
            }
            MobileDetect._impl = impl;
            MobileDetect.version = "1.4.1 2017-12-24";
            return MobileDetect;
        });
    })(function(undefined) {
        if (typeof module !== "undefined" && module.exports) {
            return function(factory) {
                module.exports = factory();
            };
        } else if (true) {
            return __webpack_require__(444);
        } else {}
    }());
}, function(module, exports) {
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
        var string = toString.call(fn);
        return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
}, function(module, exports) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
    };
}, function(module, exports, __webpack_require__) {
    (function(process, Buffer) {
        var req = __webpack_require__(450);
        module.exports = Nets;
        function Nets(opts, cb) {
            if (typeof opts === "string") opts = {
                uri: opts
            };
            if (!opts.hasOwnProperty("encoding")) opts.encoding = null;
            if (process.browser && !opts.hasOwnProperty("json") && opts.encoding === null) {
                opts.responseType = "arraybuffer";
                var originalCb = cb;
                cb = bufferify;
            }
            function bufferify(err, resp, body) {
                if (body) body = new Buffer(new Uint8Array(body));
                originalCb(err, resp, body);
            }
            return req(opts, cb);
        }
    }).call(this, __webpack_require__(13), __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _topicFactory = __webpack_require__(453);
    var _topicFactory2 = _interopRequireDefault(_topicFactory);
    var _uport = __webpack_require__(161);
    var _mobileDetect = __webpack_require__(163);
    var _mobileDetect2 = _interopRequireDefault(_mobileDetect);
    var _uportSubprovider = __webpack_require__(265);
    var _uportSubprovider2 = _interopRequireDefault(_uportSubprovider);
    var _httpprovider = __webpack_require__(108);
    var _httpprovider2 = _interopRequireDefault(_httpprovider);
    var _mnid = __webpack_require__(55);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }
        return obj;
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var networks = {
        mainnet: {
            id: "0x1",
            registry: "0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6",
            rpcUrl: "https://mainnet.infura.io"
        },
        ropsten: {
            id: "0x3",
            registry: "0x41566e3a081f5032bdcad470adb797635ddfe1f0",
            rpcUrl: "https://ropsten.infura.io"
        },
        kovan: {
            id: "0x2a",
            registry: "0x5f8e9351dc2d238fb878b6ae43aa740d62fc9758",
            rpcUrl: "https://kovan.infura.io"
        },
        rinkeby: {
            id: "0x4",
            registry: "0x2cc31912b2b0f3075a87b3640923d45a26cef3ee",
            rpcUrl: "https://rinkeby.infura.io"
        }
    };
    var DEFAULTNETWORK = "rinkeby";
    var configNetwork = function configNetwork() {
        var net = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULTNETWORK;
        if ((typeof net === "undefined" ? "undefined" : _typeof(net)) === "object") {
            [ "id", "registry", "rpcUrl" ].forEach(function(key) {
                if (!net.hasOwnProperty(key)) throw new Error("Malformed network config object, object must have '" + key + "' key specified.");
            });
            return net;
        } else if (typeof net === "string") {
            if (!networks[net]) throw new Error("Network configuration not available for '" + net + "'");
            return networks[net];
        }
        throw new Error("Network configuration object or network string required");
    };
    var ConnectCore = function() {
        function ConnectCore(appName) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, ConnectCore);
            this.appName = appName || "uport-connect-app";
            this.infuraApiKey = opts.infuraApiKey || this.appName.replace(/\W+/g, "-");
            this.provider = opts.provider;
            this.accountType = opts.accountType;
            this.isOnMobile = opts.isMobile === undefined ? isMobile() : opts.isMobile;
            this.topicFactory = opts.topicFactory || (0, _topicFactory2.default)(this.isOnMobile);
            this.uriHandler = opts.uriHandler || defaultUriHandler;
            this.mobileUriHandler = opts.mobileUriHandler;
            this.closeUriHandler = opts.closeUriHandler;
            this.clientId = opts.clientId;
            this.network = configNetwork(opts.network);
            var credentialsNetwork = _defineProperty({}, this.network.id, {
                registry: this.network.registry,
                rpcUrl: this.network.rpcUrl
            });
            this.credentials = opts.credentials || new _uport.Credentials({
                address: this.clientId,
                signer: opts.signer,
                networks: credentialsNetwork
            });
            this.canSign = !!this.credentials.settings.signer && !!this.credentials.settings.address;
            this.pushToken = null;
            this.address = null;
            this.firstReq = true;
            this.publicEncKey = null;
        }
        _createClass(ConnectCore, [ {
            key: "getProvider",
            value: function getProvider() {
                var subProvider = new _uportSubprovider2.default({
                    requestAddress: this.requestAddress.bind(this),
                    sendTransaction: this.sendTransaction.bind(this),
                    provider: this.provider || new _httpprovider2.default(this.network.rpcUrl),
                    networkId: this.network.id
                });
                if (this.address) subProvider.setAccount(this.address);
                return subProvider;
            }
        }, {
            key: "requestCredentials",
            value: function requestCredentials() {
                var _this = this;
                var request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var uriHandler = arguments[1];
                var topic = this.topicFactory("access_token");
                if (this.accountType) request.accountType = this.accountType;
                return new Promise(function(resolve, reject) {
                    if (_this.canSign) {
                        _this.credentials.createRequest(_extends({}, request, {
                            network_id: _this.network.id,
                            callbackUrl: topic.url
                        })).then(function(requestToken) {
                            return resolve("https://id.uport.me/me?requestToken=" + encodeURIComponent(requestToken));
                        });
                    } else {
                        if (request.requested && request.requested.length > 0) {
                            return reject(new Error("Specific data can not be requested without a signer configured"));
                        }
                        if (request.notifications) {
                            return reject(new Error("Notifications rights can not currently be requested without a signer configured"));
                        }
                        resolve(paramsToUri(_this.addAppParameters({
                            to: "me"
                        }, topic.url)));
                    }
                }).then(function(uri) {
                    return _this.request({
                        uri,
                        topic,
                        uriHandler
                    });
                }).then(function(jwt) {
                    return _this.credentials.receive(jwt, topic.url);
                }).then(function(res) {
                    if (res && res.pushToken) _this.pushToken = res.pushToken;
                    _this.address = res.address;
                    _this.publicEncKey = res.publicEncKey;
                    return res;
                });
            }
        }, {
            key: "requestAddress",
            value: function requestAddress(uriHandler) {
                return this.requestCredentials({}, uriHandler).then(function(profile) {
                    return profile.networkAddress || profile.address;
                });
            }
        }, {
            key: "attestCredentials",
            value: function attestCredentials(_ref, uriHandler) {
                var _this2 = this;
                var sub = _ref.sub, claim = _ref.claim, exp = _ref.exp;
                var topic = this.topicFactory("status");
                return this.credentials.attest({
                    sub,
                    claim,
                    exp
                }).then(function(jwt) {
                    return _this2.request({
                        uri: "https://id.uport.me/add?attestations=" + encodeURIComponent(jwt) + "&callback_url=" + encodeURIComponent(topic.url),
                        topic,
                        uriHandler
                    });
                });
            }
        }, {
            key: "request",
            value: function request(_ref2) {
                var _this3 = this;
                var uri = _ref2.uri, topic = _ref2.topic, uriHandler = _ref2.uriHandler;
                var defaultUriHandler = !uriHandler;
                if (defaultUriHandler) {
                    uriHandler = this.uriHandler;
                }
                if (this.pushToken && !this.isOnMobile) {
                    this.credentials.push(this.pushToken, this.publicEncKey, {
                        url: uri
                    });
                    return topic;
                }
                this.isOnMobile && this.mobileUriHandler ? this.mobileUriHandler(uri) : uriHandler(uri, topic.cancel, this.appName, this.firstReq);
                this.firstReq = false;
                if (defaultUriHandler && !this.isOnMobile && this.closeUriHandler) {
                    return new Promise(function(resolve, reject) {
                        topic.then(function(res) {
                            _this3.closeUriHandler();
                            resolve(res);
                        }, function(error) {
                            _this3.closeUriHandler();
                            reject(error);
                        });
                    });
                } else return topic;
            }
        }, {
            key: "contract",
            value: function contract(abi) {
                var _this4 = this;
                var txObjectHandler = function txObjectHandler(methodTxObject, uriHandler) {
                    return _this4.sendTransaction(methodTxObject, uriHandler);
                };
                return new _uport.ContractFactory(txObjectHandler)(abi);
            }
        }, {
            key: "sendTransaction",
            value: function sendTransaction(txobj, uriHandler) {
                var topic = this.topicFactory("tx");
                var uri = paramsToUri(this.addAppParameters(txobj, topic.url));
                return this.request({
                    uri,
                    topic,
                    uriHandler
                });
            }
        }, {
            key: "addAppParameters",
            value: function addAppParameters(txObject, callbackUrl) {
                var appTxObject = Object.assign({}, txObject);
                if (callbackUrl) {
                    appTxObject.callback_url = callbackUrl;
                }
                if (this.appName) {
                    appTxObject.label = this.appName;
                }
                if (this.clientId) {
                    appTxObject.client_id = this.clientId;
                }
                appTxObject.network_id = this.network.id;
                return appTxObject;
            }
        } ]);
        return ConnectCore;
    }();
    var paramsToUri = function paramsToUri(params) {
        if (!params.to) {
            throw new Error("Contract creation is not supported by uportProvider");
        }
        var networkId = params.network_id || undefined.network.id;
        params.to = (0, _mnid.isMNID)(params.to) || params.to === "me" ? params.to : (0, 
        _mnid.encode)({
            network: networkId,
            address: params.to
        });
        var uri = "https://id.uport.me/" + params.to;
        var pairs = [];
        if (params.value) {
            pairs.push([ "value", parseInt(params.value, 16) ]);
        }
        if (params.function) {
            pairs.push([ "function", params.function ]);
        } else if (params.data) {
            pairs.push([ "bytecode", params.data ]);
        }
        var paramsAdd = [ "label", "callback_url", "client_id", "gasPrice" ];
        if (params.to === "me") {
            pairs.push([ "network_id", networkId ]);
        }
        paramsAdd.map(function(param) {
            if (params[param]) {
                pairs.push([ param, params[param] ]);
            }
        });
        return uri + "?" + pairs.map(function(kv) {
            return kv[0] + "=" + encodeURIComponent(kv[1]);
        }).join("&");
    };
    function isMobile() {
        if (typeof navigator !== "undefined") {
            return !!new _mobileDetect2.default(navigator.userAgent).mobile();
        } else return false;
    }
    function defaultUriHandler(uri) {
        throw new Error("No Url handler set to handle " + uri);
    }
    exports.default = ConnectCore;
}, function(module, exports, __webpack_require__) {
    var stylesInDom = {};
    var memoize = function(fn) {
        var memo;
        return function() {
            if (typeof memo === "undefined") memo = fn.apply(this, arguments);
            return memo;
        };
    };
    var isOldIE = memoize(function() {
        return window && document && document.all && !window.atob;
    });
    var getTarget = function(target) {
        return document.querySelector(target);
    };
    var getElement = function(fn) {
        var memo = {};
        return function(target) {
            if (typeof target === "function") {
                return target();
            }
            if (typeof memo[target] === "undefined") {
                var styleTarget = getTarget.call(this, target);
                if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                    try {
                        styleTarget = styleTarget.contentDocument.head;
                    } catch (e) {
                        styleTarget = null;
                    }
                }
                memo[target] = styleTarget;
            }
            return memo[target];
        };
    }();
    var singleton = null;
    var singletonCounter = 0;
    var stylesInsertedAtTop = [];
    var fixUrls = __webpack_require__(464);
    module.exports = function(list, options) {
        if (typeof DEBUG !== "undefined" && DEBUG) {
            if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
        }
        options = options || {};
        options.attrs = typeof options.attrs === "object" ? options.attrs : {};
        if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();
        if (!options.insertInto) options.insertInto = "head";
        if (!options.insertAt) options.insertAt = "bottom";
        var styles = listToStyles(list, options);
        addStylesToDom(styles, options);
        return function update(newList) {
            var mayRemove = [];
            for (var i = 0; i < styles.length; i++) {
                var item = styles[i];
                var domStyle = stylesInDom[item.id];
                domStyle.refs--;
                mayRemove.push(domStyle);
            }
            if (newList) {
                var newStyles = listToStyles(newList, options);
                addStylesToDom(newStyles, options);
            }
            for (var i = 0; i < mayRemove.length; i++) {
                var domStyle = mayRemove[i];
                if (domStyle.refs === 0) {
                    for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
                    delete stylesInDom[domStyle.id];
                }
            }
        };
    };
    function addStylesToDom(styles, options) {
        for (var i = 0; i < styles.length; i++) {
            var item = styles[i];
            var domStyle = stylesInDom[item.id];
            if (domStyle) {
                domStyle.refs++;
                for (var j = 0; j < domStyle.parts.length; j++) {
                    domStyle.parts[j](item.parts[j]);
                }
                for (;j < item.parts.length; j++) {
                    domStyle.parts.push(addStyle(item.parts[j], options));
                }
            } else {
                var parts = [];
                for (var j = 0; j < item.parts.length; j++) {
                    parts.push(addStyle(item.parts[j], options));
                }
                stylesInDom[item.id] = {
                    id: item.id,
                    refs: 1,
                    parts
                };
            }
        }
    }
    function listToStyles(list, options) {
        var styles = [];
        var newStyles = {};
        for (var i = 0; i < list.length; i++) {
            var item = list[i];
            var id = options.base ? item[0] + options.base : item[0];
            var css = item[1];
            var media = item[2];
            var sourceMap = item[3];
            var part = {
                css,
                media,
                sourceMap
            };
            if (!newStyles[id]) styles.push(newStyles[id] = {
                id,
                parts: [ part ]
            }); else newStyles[id].parts.push(part);
        }
        return styles;
    }
    function insertStyleElement(options, style) {
        var target = getElement(options.insertInto);
        if (!target) {
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        }
        var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
        if (options.insertAt === "top") {
            if (!lastStyleElementInsertedAtTop) {
                target.insertBefore(style, target.firstChild);
            } else if (lastStyleElementInsertedAtTop.nextSibling) {
                target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
            } else {
                target.appendChild(style);
            }
            stylesInsertedAtTop.push(style);
        } else if (options.insertAt === "bottom") {
            target.appendChild(style);
        } else if (typeof options.insertAt === "object" && options.insertAt.before) {
            var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
            target.insertBefore(style, nextSibling);
        } else {
            throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
        }
    }
    function removeStyleElement(style) {
        if (style.parentNode === null) return false;
        style.parentNode.removeChild(style);
        var idx = stylesInsertedAtTop.indexOf(style);
        if (idx >= 0) {
            stylesInsertedAtTop.splice(idx, 1);
        }
    }
    function createStyleElement(options) {
        var style = document.createElement("style");
        if (options.attrs.type === undefined) {
            options.attrs.type = "text/css";
        }
        addAttrs(style, options.attrs);
        insertStyleElement(options, style);
        return style;
    }
    function createLinkElement(options) {
        var link = document.createElement("link");
        if (options.attrs.type === undefined) {
            options.attrs.type = "text/css";
        }
        options.attrs.rel = "stylesheet";
        addAttrs(link, options.attrs);
        insertStyleElement(options, link);
        return link;
    }
    function addAttrs(el, attrs) {
        Object.keys(attrs).forEach(function(key) {
            el.setAttribute(key, attrs[key]);
        });
    }
    function addStyle(obj, options) {
        var style, update, remove, result;
        if (options.transform && obj.css) {
            result = options.transform(obj.css);
            if (result) {
                obj.css = result;
            } else {
                return function() {};
            }
        }
        if (options.singleton) {
            var styleIndex = singletonCounter++;
            style = singleton || (singleton = createStyleElement(options));
            update = applyToSingletonTag.bind(null, style, styleIndex, false);
            remove = applyToSingletonTag.bind(null, style, styleIndex, true);
        } else if (obj.sourceMap && typeof URL === "function" && typeof URL.createObjectURL === "function" && typeof URL.revokeObjectURL === "function" && typeof Blob === "function" && typeof btoa === "function") {
            style = createLinkElement(options);
            update = updateLink.bind(null, style, options);
            remove = function() {
                removeStyleElement(style);
                if (style.href) URL.revokeObjectURL(style.href);
            };
        } else {
            style = createStyleElement(options);
            update = applyToTag.bind(null, style);
            remove = function() {
                removeStyleElement(style);
            };
        }
        update(obj);
        return function updateStyle(newObj) {
            if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                    return;
                }
                update(obj = newObj);
            } else {
                remove();
            }
        };
    }
    var replaceText = function() {
        var textStore = [];
        return function(index, replacement) {
            textStore[index] = replacement;
            return textStore.filter(Boolean).join("\n");
        };
    }();
    function applyToSingletonTag(style, index, remove, obj) {
        var css = remove ? "" : obj.css;
        if (style.styleSheet) {
            style.styleSheet.cssText = replaceText(index, css);
        } else {
            var cssNode = document.createTextNode(css);
            var childNodes = style.childNodes;
            if (childNodes[index]) style.removeChild(childNodes[index]);
            if (childNodes.length) {
                style.insertBefore(cssNode, childNodes[index]);
            } else {
                style.appendChild(cssNode);
            }
        }
    }
    function applyToTag(style, obj) {
        var css = obj.css;
        var media = obj.media;
        if (media) {
            style.setAttribute("media", media);
        }
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            while (style.firstChild) {
                style.removeChild(style.firstChild);
            }
            style.appendChild(document.createTextNode(css));
        }
    }
    function updateLink(link, options, obj) {
        var css = obj.css;
        var sourceMap = obj.sourceMap;
        var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;
        if (options.convertToAbsoluteUrls || autoFixUrls) {
            css = fixUrls(css);
        }
        if (sourceMap) {
            css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
        }
        var blob = new Blob([ css ], {
            type: "text/css"
        });
        var oldSrc = link.href;
        link.href = URL.createObjectURL(blob);
        if (oldSrc) URL.revokeObjectURL(oldSrc);
    }
}, function(module, exports) {
    module.exports = function(useSourceMap) {
        var list = [];
        list.toString = function toString() {
            return this.map(function(item) {
                var content = cssWithMappingToString(item, useSourceMap);
                if (item[2]) {
                    return "@media " + item[2] + "{" + content + "}";
                } else {
                    return content;
                }
            }).join("");
        };
        list.i = function(modules, mediaQuery) {
            if (typeof modules === "string") modules = [ [ null, modules, "" ] ];
            var alreadyImportedModules = {};
            for (var i = 0; i < this.length; i++) {
                var id = this[i][0];
                if (typeof id === "number") alreadyImportedModules[id] = true;
            }
            for (i = 0; i < modules.length; i++) {
                var item = modules[i];
                if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                    if (mediaQuery && !item[2]) {
                        item[2] = mediaQuery;
                    } else if (mediaQuery) {
                        item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                    }
                    list.push(item);
                }
            }
        };
        return list;
    };
    function cssWithMappingToString(item, useSourceMap) {
        var content = item[1] || "";
        var cssMapping = item[3];
        if (!cssMapping) {
            return content;
        }
        if (useSourceMap && typeof btoa === "function") {
            var sourceMapping = toComment(cssMapping);
            var sourceURLs = cssMapping.sources.map(function(source) {
                return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
            });
            return [ content ].concat(sourceURLs).concat([ sourceMapping ]).join("\n");
        }
        return [ content ].join("\n");
    }
    function toComment(sourceMap) {
        var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
        var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
        return "/*# " + data + " */";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var canUseDOM = exports.canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
        return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent("on" + event, listener);
    };
    var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
        return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent("on" + event, listener);
    };
    var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
        return callback(window.confirm(message));
    };
    var supportsHistory = exports.supportsHistory = function supportsHistory() {
        var ua = window.navigator.userAgent;
        if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1) return false;
        return window.history && "pushState" in window.history;
    };
    var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
        return window.navigator.userAgent.indexOf("Trident") === -1;
    };
    var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
        return window.navigator.userAgent.indexOf("Firefox") === -1;
    };
    var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
        return event.state === undefined && navigator.userAgent.indexOf("CriOS") === -1;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
            return;
        }
        if (false) {}
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
            console.error(err);
        }
    }
    if (true) {
        checkDCE();
        module.exports = __webpack_require__(478);
    } else {}
}, function(module, exports, __webpack_require__) {
    "use strict";
    var emptyObject = {};
    if (false) {}
    module.exports = emptyObject;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
        if (val === null || val === undefined) {
            throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
    }
    function shouldUseNative() {
        try {
            if (!Object.assign) {
                return false;
            }
            var test1 = new String("abc");
            test1[5] = "de";
            if (Object.getOwnPropertyNames(test1)[0] === "5") {
                return false;
            }
            var test2 = {};
            for (var i = 0; i < 10; i++) {
                test2["_" + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
            });
            if (order2.join("") !== "0123456789") {
                return false;
            }
            var test3 = {};
            "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                return false;
            }
            return true;
        } catch (err) {
            return false;
        }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                }
            }
            if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                    }
                }
            }
        }
        return to;
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return symbolObservablePonyfill;
    });
    function symbolObservablePonyfill(root) {
        var result;
        var Symbol = root.Symbol;
        if (typeof Symbol === "function") {
            if (Symbol.observable) {
                result = Symbol.observable;
            } else {
                result = Symbol("observable");
                Symbol.observable = result;
            }
        } else {
            result = "@@observable";
        }
        return result;
    }
}, function(module, exports, __webpack_require__) {
    var isarray = __webpack_require__(469);
    module.exports = pathToRegexp;
    module.exports.parse = parse;
    module.exports.compile = compile;
    module.exports.tokensToFunction = tokensToFunction;
    module.exports.tokensToRegExp = tokensToRegExp;
    var PATH_REGEXP = new RegExp([ "(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))" ].join("|"), "g");
    function parse(str, options) {
        var tokens = [];
        var key = 0;
        var index = 0;
        var path = "";
        var defaultDelimiter = options && options.delimiter || "/";
        var res;
        while ((res = PATH_REGEXP.exec(str)) != null) {
            var m = res[0];
            var escaped = res[1];
            var offset = res.index;
            path += str.slice(index, offset);
            index = offset + m.length;
            if (escaped) {
                path += escaped[1];
                continue;
            }
            var next = str[index];
            var prefix = res[2];
            var name = res[3];
            var capture = res[4];
            var group = res[5];
            var modifier = res[6];
            var asterisk = res[7];
            if (path) {
                tokens.push(path);
                path = "";
            }
            var partial = prefix != null && next != null && next !== prefix;
            var repeat = modifier === "+" || modifier === "*";
            var optional = modifier === "?" || modifier === "*";
            var delimiter = res[2] || defaultDelimiter;
            var pattern = capture || group;
            tokens.push({
                name: name || key++,
                prefix: prefix || "",
                delimiter,
                optional,
                repeat,
                partial,
                asterisk: !!asterisk,
                pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
            });
        }
        if (index < str.length) {
            path += str.substr(index);
        }
        if (path) {
            tokens.push(path);
        }
        return tokens;
    }
    function compile(str, options) {
        return tokensToFunction(parse(str, options));
    }
    function encodeURIComponentPretty(str) {
        return encodeURI(str).replace(/[\/?#]/g, function(c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
    }
    function encodeAsterisk(str) {
        return encodeURI(str).replace(/[?#]/g, function(c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
    }
    function tokensToFunction(tokens) {
        var matches = new Array(tokens.length);
        for (var i = 0; i < tokens.length; i++) {
            if (typeof tokens[i] === "object") {
                matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$");
            }
        }
        return function(obj, opts) {
            var path = "";
            var data = obj || {};
            var options = opts || {};
            var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                var value = data[token.name];
                var segment;
                if (value == null) {
                    if (token.optional) {
                        if (token.partial) {
                            path += token.prefix;
                        }
                        continue;
                    } else {
                        throw new TypeError('Expected "' + token.name + '" to be defined');
                    }
                }
                if (isarray(value)) {
                    if (!token.repeat) {
                        throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
                    }
                    if (value.length === 0) {
                        if (token.optional) {
                            continue;
                        } else {
                            throw new TypeError('Expected "' + token.name + '" to not be empty');
                        }
                    }
                    for (var j = 0; j < value.length; j++) {
                        segment = encode(value[j]);
                        if (!matches[i].test(segment)) {
                            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
                        }
                        path += (j === 0 ? token.prefix : token.delimiter) + segment;
                    }
                    continue;
                }
                segment = token.asterisk ? encodeAsterisk(value) : encode(value);
                if (!matches[i].test(segment)) {
                    throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
                }
                path += token.prefix + segment;
            }
            return path;
        };
    }
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
    }
    function escapeGroup(group) {
        return group.replace(/([=!:$\/()])/g, "\\$1");
    }
    function attachKeys(re, keys) {
        re.keys = keys;
        return re;
    }
    function flags(options) {
        return options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path, keys) {
        var groups = path.source.match(/\((?!\?)/g);
        if (groups) {
            for (var i = 0; i < groups.length; i++) {
                keys.push({
                    name: i,
                    prefix: null,
                    delimiter: null,
                    optional: false,
                    repeat: false,
                    partial: false,
                    asterisk: false,
                    pattern: null
                });
            }
        }
        return attachKeys(path, keys);
    }
    function arrayToRegexp(path, keys, options) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
            parts.push(pathToRegexp(path[i], keys, options).source);
        }
        var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
        return attachKeys(regexp, keys);
    }
    function stringToRegexp(path, keys, options) {
        return tokensToRegExp(parse(path, options), keys, options);
    }
    function tokensToRegExp(tokens, keys, options) {
        if (!isarray(keys)) {
            options = keys || options;
            keys = [];
        }
        options = options || {};
        var strict = options.strict;
        var end = options.end !== false;
        var route = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                route += escapeString(token);
            } else {
                var prefix = escapeString(token.prefix);
                var capture = "(?:" + token.pattern + ")";
                keys.push(token);
                if (token.repeat) {
                    capture += "(?:" + prefix + capture + ")*";
                }
                if (token.optional) {
                    if (!token.partial) {
                        capture = "(?:" + prefix + "(" + capture + "))?";
                    } else {
                        capture = prefix + "(" + capture + ")?";
                    }
                } else {
                    capture = prefix + "(" + capture + ")";
                }
                route += capture;
            }
        }
        var delimiter = escapeString(options.delimiter || "/");
        var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
        if (!strict) {
            route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
        }
        if (end) {
            route += "$";
        } else {
            route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
        }
        return attachKeys(new RegExp("^" + route, flags(options)), keys);
    }
    function pathToRegexp(path, keys, options) {
        if (!isarray(keys)) {
            options = keys || options;
            keys = [];
        }
        options = options || {};
        if (path instanceof RegExp) {
            return regexpToRegexp(path, keys);
        }
        if (isarray(path)) {
            return arrayToRegexp(path, keys, options);
        }
        return stringToRegexp(path, keys, options);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _warning = __webpack_require__(5);
    var _warning2 = _interopRequireDefault(_warning);
    var _PathUtils = __webpack_require__(20);
    var _LocationUtils = __webpack_require__(89);
    var _createTransitionManager = __webpack_require__(88);
    var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var clamp = function clamp(n, lowerBound, upperBound) {
        return Math.min(Math.max(n, lowerBound), upperBound);
    };
    var createMemoryHistory = function createMemoryHistory() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var getUserConfirmation = props.getUserConfirmation, _props$initialEntries = props.initialEntries, initialEntries = _props$initialEntries === undefined ? [ "/" ] : _props$initialEntries, _props$initialIndex = props.initialIndex, initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex, _props$keyLength = props.keyLength, keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;
        var transitionManager = (0, _createTransitionManager2.default)();
        var setState = function setState(nextState) {
            _extends(history, nextState);
            history.length = history.entries.length;
            transitionManager.notifyListeners(history.location, history.action);
        };
        var createKey = function createKey() {
            return Math.random().toString(36).substr(2, keyLength);
        };
        var index = clamp(initialIndex, 0, initialEntries.length - 1);
        var entries = initialEntries.map(function(entry) {
            return typeof entry === "string" ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, 
            _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
        });
        var createHref = _PathUtils.createPath;
        var push = function push(path, state) {
            (0, _warning2.default)(!((typeof path === "undefined" ? "undefined" : _typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to push when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "PUSH";
            var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var prevIndex = history.index;
                var nextIndex = prevIndex + 1;
                var nextEntries = history.entries.slice(0);
                if (nextEntries.length > nextIndex) {
                    nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
                } else {
                    nextEntries.push(location);
                }
                setState({
                    action,
                    location,
                    index: nextIndex,
                    entries: nextEntries
                });
            });
        };
        var replace = function replace(path, state) {
            (0, _warning2.default)(!((typeof path === "undefined" ? "undefined" : _typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to replace when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "REPLACE";
            var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                history.entries[history.index] = location;
                setState({
                    action,
                    location
                });
            });
        };
        var go = function go(n) {
            var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
            var action = "POP";
            var location = history.entries[nextIndex];
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (ok) {
                    setState({
                        action,
                        location,
                        index: nextIndex
                    });
                } else {
                    setState();
                }
            });
        };
        var goBack = function goBack() {
            return go(-1);
        };
        var goForward = function goForward() {
            return go(1);
        };
        var canGo = function canGo(n) {
            var nextIndex = history.index + n;
            return nextIndex >= 0 && nextIndex < history.entries.length;
        };
        var block = function block() {
            var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            return transitionManager.setPrompt(prompt);
        };
        var listen = function listen(listener) {
            return transitionManager.appendListener(listener);
        };
        var history = {
            length: entries.length,
            action: "POP",
            location: entries[index],
            index,
            entries,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            canGo,
            block,
            listen
        };
        return history;
    };
    exports.default = createMemoryHistory;
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _warning = __webpack_require__(5);
    var _warning2 = _interopRequireDefault(_warning);
    var _invariant = __webpack_require__(8);
    var _invariant2 = _interopRequireDefault(_invariant);
    var _LocationUtils = __webpack_require__(89);
    var _PathUtils = __webpack_require__(20);
    var _createTransitionManager = __webpack_require__(88);
    var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
    var _DOMUtils = __webpack_require__(170);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var HashChangeEvent = "hashchange";
    var HashPathCoders = {
        hashbang: {
            encodePath: function encodePath(path) {
                return path.charAt(0) === "!" ? path : "!/" + (0, _PathUtils.stripLeadingSlash)(path);
            },
            decodePath: function decodePath(path) {
                return path.charAt(0) === "!" ? path.substr(1) : path;
            }
        },
        noslash: {
            encodePath: _PathUtils.stripLeadingSlash,
            decodePath: _PathUtils.addLeadingSlash
        },
        slash: {
            encodePath: _PathUtils.addLeadingSlash,
            decodePath: _PathUtils.addLeadingSlash
        }
    };
    var getHashPath = function getHashPath() {
        var href = window.location.href;
        var hashIndex = href.indexOf("#");
        return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
    };
    var pushHashPath = function pushHashPath(path) {
        return window.location.hash = path;
    };
    var replaceHashPath = function replaceHashPath(path) {
        var hashIndex = window.location.href.indexOf("#");
        window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + "#" + path);
    };
    var createHashHistory = function createHashHistory() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _invariant2.default)(_DOMUtils.canUseDOM, "Hash history needs a DOM");
        var globalHistory = window.history;
        var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();
        var _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$hashType = props.hashType, hashType = _props$hashType === undefined ? "slash" : _props$hashType;
        var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : "";
        var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath;
        var getDOMLocation = function getDOMLocation() {
            var path = decodePath(getHashPath());
            (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), "You are attempting to use a basename on a page whose URL path does not begin " + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
            if (basename) path = (0, _PathUtils.stripBasename)(path, basename);
            return (0, _LocationUtils.createLocation)(path);
        };
        var transitionManager = (0, _createTransitionManager2.default)();
        var setState = function setState(nextState) {
            _extends(history, nextState);
            history.length = globalHistory.length;
            transitionManager.notifyListeners(history.location, history.action);
        };
        var forceNextPop = false;
        var ignorePath = null;
        var handleHashChange = function handleHashChange() {
            var path = getHashPath();
            var encodedPath = encodePath(path);
            if (path !== encodedPath) {
                replaceHashPath(encodedPath);
            } else {
                var location = getDOMLocation();
                var prevLocation = history.location;
                if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return;
                if (ignorePath === (0, _PathUtils.createPath)(location)) return;
                ignorePath = null;
                handlePop(location);
            }
        };
        var handlePop = function handlePop(location) {
            if (forceNextPop) {
                forceNextPop = false;
                setState();
            } else {
                var action = "POP";
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        setState({
                            action,
                            location
                        });
                    } else {
                        revertPop(location);
                    }
                });
            }
        };
        var revertPop = function revertPop(fromLocation) {
            var toLocation = history.location;
            var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));
            if (toIndex === -1) toIndex = 0;
            var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));
            if (fromIndex === -1) fromIndex = 0;
            var delta = toIndex - fromIndex;
            if (delta) {
                forceNextPop = true;
                go(delta);
            }
        };
        var path = getHashPath();
        var encodedPath = encodePath(path);
        if (path !== encodedPath) replaceHashPath(encodedPath);
        var initialLocation = getDOMLocation();
        var allPaths = [ (0, _PathUtils.createPath)(initialLocation) ];
        var createHref = function createHref(location) {
            return "#" + encodePath(basename + (0, _PathUtils.createPath)(location));
        };
        var push = function push(path, state) {
            (0, _warning2.default)(state === undefined, "Hash history cannot push state; it is ignored");
            var action = "PUSH";
            var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var path = (0, _PathUtils.createPath)(location);
                var encodedPath = encodePath(basename + path);
                var hashChanged = getHashPath() !== encodedPath;
                if (hashChanged) {
                    ignorePath = path;
                    pushHashPath(encodedPath);
                    var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
                    var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                    nextPaths.push(path);
                    allPaths = nextPaths;
                    setState({
                        action,
                        location
                    });
                } else {
                    (0, _warning2.default)(false, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack");
                    setState();
                }
            });
        };
        var replace = function replace(path, state) {
            (0, _warning2.default)(state === undefined, "Hash history cannot replace state; it is ignored");
            var action = "REPLACE";
            var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var path = (0, _PathUtils.createPath)(location);
                var encodedPath = encodePath(basename + path);
                var hashChanged = getHashPath() !== encodedPath;
                if (hashChanged) {
                    ignorePath = path;
                    replaceHashPath(encodedPath);
                }
                var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));
                if (prevIndex !== -1) allPaths[prevIndex] = path;
                setState({
                    action,
                    location
                });
            });
        };
        var go = function go(n) {
            (0, _warning2.default)(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser");
            globalHistory.go(n);
        };
        var goBack = function goBack() {
            return go(-1);
        };
        var goForward = function goForward() {
            return go(1);
        };
        var listenerCount = 0;
        var checkDOMListeners = function checkDOMListeners(delta) {
            listenerCount += delta;
            if (listenerCount === 1) {
                (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
            } else if (listenerCount === 0) {
                (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
            }
        };
        var isBlocked = false;
        var block = function block() {
            var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var unblock = transitionManager.setPrompt(prompt);
            if (!isBlocked) {
                checkDOMListeners(1);
                isBlocked = true;
            }
            return function() {
                if (isBlocked) {
                    isBlocked = false;
                    checkDOMListeners(-1);
                }
                return unblock();
            };
        };
        var listen = function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            checkDOMListeners(1);
            return function() {
                checkDOMListeners(-1);
                unlisten();
            };
        };
        var history = {
            length: globalHistory.length,
            action: "POP",
            location: initialLocation,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            block,
            listen
        };
        return history;
    };
    exports.default = createHashHistory;
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _warning = __webpack_require__(5);
    var _warning2 = _interopRequireDefault(_warning);
    var _invariant = __webpack_require__(8);
    var _invariant2 = _interopRequireDefault(_invariant);
    var _LocationUtils = __webpack_require__(89);
    var _PathUtils = __webpack_require__(20);
    var _createTransitionManager = __webpack_require__(88);
    var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
    var _DOMUtils = __webpack_require__(170);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var PopStateEvent = "popstate";
    var HashChangeEvent = "hashchange";
    var getHistoryState = function getHistoryState() {
        try {
            return window.history.state || {};
        } catch (e) {
            return {};
        }
    };
    var createBrowserHistory = function createBrowserHistory() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _invariant2.default)(_DOMUtils.canUseDOM, "Browser history needs a DOM");
        var globalHistory = window.history;
        var canUseHistory = (0, _DOMUtils.supportsHistory)();
        var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();
        var _props$forceRefresh = props.forceRefresh, forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$keyLength = props.keyLength, keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;
        var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : "";
        var getDOMLocation = function getDOMLocation(historyState) {
            var _ref = historyState || {}, key = _ref.key, state = _ref.state;
            var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
            var path = pathname + search + hash;
            (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), "You are attempting to use a basename on a page whose URL path does not begin " + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
            if (basename) path = (0, _PathUtils.stripBasename)(path, basename);
            return (0, _LocationUtils.createLocation)(path, state, key);
        };
        var createKey = function createKey() {
            return Math.random().toString(36).substr(2, keyLength);
        };
        var transitionManager = (0, _createTransitionManager2.default)();
        var setState = function setState(nextState) {
            _extends(history, nextState);
            history.length = globalHistory.length;
            transitionManager.notifyListeners(history.location, history.action);
        };
        var handlePopState = function handlePopState(event) {
            if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;
            handlePop(getDOMLocation(event.state));
        };
        var handleHashChange = function handleHashChange() {
            handlePop(getDOMLocation(getHistoryState()));
        };
        var forceNextPop = false;
        var handlePop = function handlePop(location) {
            if (forceNextPop) {
                forceNextPop = false;
                setState();
            } else {
                var action = "POP";
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        setState({
                            action,
                            location
                        });
                    } else {
                        revertPop(location);
                    }
                });
            }
        };
        var revertPop = function revertPop(fromLocation) {
            var toLocation = history.location;
            var toIndex = allKeys.indexOf(toLocation.key);
            if (toIndex === -1) toIndex = 0;
            var fromIndex = allKeys.indexOf(fromLocation.key);
            if (fromIndex === -1) fromIndex = 0;
            var delta = toIndex - fromIndex;
            if (delta) {
                forceNextPop = true;
                go(delta);
            }
        };
        var initialLocation = getDOMLocation(getHistoryState());
        var allKeys = [ initialLocation.key ];
        var createHref = function createHref(location) {
            return basename + (0, _PathUtils.createPath)(location);
        };
        var push = function push(path, state) {
            (0, _warning2.default)(!((typeof path === "undefined" ? "undefined" : _typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to push when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "PUSH";
            var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var href = createHref(location);
                var key = location.key, state = location.state;
                if (canUseHistory) {
                    globalHistory.pushState({
                        key,
                        state
                    }, null, href);
                    if (forceRefresh) {
                        window.location.href = href;
                    } else {
                        var prevIndex = allKeys.indexOf(history.location.key);
                        var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                        nextKeys.push(location.key);
                        allKeys = nextKeys;
                        setState({
                            action,
                            location
                        });
                    }
                } else {
                    (0, _warning2.default)(state === undefined, "Browser history cannot push state in browsers that do not support HTML5 history");
                    window.location.href = href;
                }
            });
        };
        var replace = function replace(path, state) {
            (0, _warning2.default)(!((typeof path === "undefined" ? "undefined" : _typeof(path)) === "object" && path.state !== undefined && state !== undefined), "You should avoid providing a 2nd state argument to replace when the 1st " + "argument is a location-like object that already has state; it is ignored");
            var action = "REPLACE";
            var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                if (!ok) return;
                var href = createHref(location);
                var key = location.key, state = location.state;
                if (canUseHistory) {
                    globalHistory.replaceState({
                        key,
                        state
                    }, null, href);
                    if (forceRefresh) {
                        window.location.replace(href);
                    } else {
                        var prevIndex = allKeys.indexOf(history.location.key);
                        if (prevIndex !== -1) allKeys[prevIndex] = location.key;
                        setState({
                            action,
                            location
                        });
                    }
                } else {
                    (0, _warning2.default)(state === undefined, "Browser history cannot replace state in browsers that do not support HTML5 history");
                    window.location.replace(href);
                }
            });
        };
        var go = function go(n) {
            globalHistory.go(n);
        };
        var goBack = function goBack() {
            return go(-1);
        };
        var goForward = function goForward() {
            return go(1);
        };
        var listenerCount = 0;
        var checkDOMListeners = function checkDOMListeners(delta) {
            listenerCount += delta;
            if (listenerCount === 1) {
                (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);
                if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
            } else if (listenerCount === 0) {
                (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);
                if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
            }
        };
        var isBlocked = false;
        var block = function block() {
            var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var unblock = transitionManager.setPrompt(prompt);
            if (!isBlocked) {
                checkDOMListeners(1);
                isBlocked = true;
            }
            return function() {
                if (isBlocked) {
                    isBlocked = false;
                    checkDOMListeners(-1);
                }
                return unblock();
            };
        };
        var listen = function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            checkDOMListeners(1);
            return function() {
                checkDOMListeners(-1);
                unlisten();
            };
        };
        var history = {
            length: globalHistory.length,
            action: "POP",
            location: initialLocation,
            createHref,
            push,
            replace,
            go,
            goBack,
            goForward,
            block,
            listen
        };
        return history;
    };
    exports.default = createBrowserHistory;
}, function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(169)(false);
    exports.push([ module.i, '/* Always set the map height explicitly to define the size of the div\n * element that contains the map. */\n#map {\n  height: 100%;\n}\n/* Optional: Makes the sample page fill the window. */\nhtml, body {\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}\n</style>\n<link type="text/css" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:\\300,400,500">\n<style>\n  #locationField, #controls {\n    position: relative;\n    width: 480px;\n  }\n/*  #autocomplete {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 99%;\n  }*/\n  .label {\n    text-align: right;\n    font-weight: bold;\n    width: 100px;\n    color: #303030;\n  }\n  #address {\n    border: 1px solid #000090;\n    background-color: #f0f0ff;\n    width: 480px;\n    padding-right: 2px;\n  }\n  #address td {\n    font-size: 10pt;\n  }\n  .field {\n    width: 99%;\n  }\n  .slimField {\n    width: 80px;\n  }\n  .wideField {\n    width: 200px;\n  }\n  #locationField {\n    height: 20px;\n    margin-bottom: 25px;\n  }', "" ]);
}, function(module, exports, __webpack_require__) {
    var content = __webpack_require__(179);
    if (typeof content === "string") content = [ [ module.i, content, "" ] ];
    var transform;
    var insertInto;
    var options = {
        hmr: true
    };
    options.transform = transform;
    options.insertInto = undefined;
    var update = __webpack_require__(168)(content, options);
    if (content.locals) module.exports = content.locals;
    if (false) {}
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _react = __webpack_require__(2);
    var _react2 = _interopRequireDefault(_react);
    __webpack_require__(180);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var AutoComplete = function(_Component) {
        _inherits(AutoComplete, _Component);
        function AutoComplete(props) {
            _classCallCheck(this, AutoComplete);
            var _this = _possibleConstructorReturn(this, (AutoComplete.__proto__ || Object.getPrototypeOf(AutoComplete)).call(this, props));
            _this.componentForm = {
                street_number: "short_name",
                route: "long_name",
                locality: "long_name",
                administrative_area_level_1: "short_name",
                country: "long_name",
                postal_code: "short_name"
            };
            console.log(_this.componentForm);
            _this.fillInAddress = _this.fillInAddress.bind(_this);
            _this.geolocate = _this.geolocate.bind(_this);
            return _this;
        }
        _createClass(AutoComplete, [ {
            key: "fillInAddress",
            value: function fillInAddress() {
                var place = this.autocomplete.getPlace();
                for (var component in this.componentForm) {
                    document.getElementById(component).value = "";
                    document.getElementById(component).disabled = false;
                }
                for (var i = 0; i < place.address_components.length; i++) {
                    var addressType = place.address_components[i].types[0];
                    if (this.componentForm[addressType]) {
                        var val = place.address_components[i][this.componentForm[addressType]];
                        document.getElementById(addressType).value = val;
                    }
                }
            }
        }, {
            key: "geolocate",
            value: function geolocate() {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(function(position) {
                        var geolocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        var circle = new google.maps.Circle({
                            center: geolocation,
                            radius: position.coords.accuracy
                        });
                        this.autocomplete.setBounds(circle.getBounds());
                        console.log("geolocate: " + this.autocomplete);
                    });
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                console.log(document.getElementById("autocomplete"));
                this.autocomplete = new google.maps.places.Autocomplete(document.getElementById("autocomplete"), {
                    types: [ "geocode" ]
                });
                console.log(this.autocomplete);
                this.autocomplete.addListener("place_changed", this.fillInAddress);
            }
        }, {
            key: "render",
            value: function render() {
                return _react2.default.createElement("div", null, _react2.default.createElement("table", {
                    id: "address"
                }, _react2.default.createElement("tr", null, _react2.default.createElement("td", {
                    class: "label"
                }, "Street address"), _react2.default.createElement("td", {
                    class: "slimField"
                }, _react2.default.createElement("input", {
                    class: "field",
                    id: "street_number",
                    disabled: "true"
                })), _react2.default.createElement("td", {
                    class: "wideField",
                    colspan: "2"
                }, _react2.default.createElement("input", {
                    class: "field",
                    id: "route",
                    disabled: "true"
                }))), _react2.default.createElement("tr", null, _react2.default.createElement("td", {
                    class: "label"
                }, "City"), _react2.default.createElement("td", {
                    class: "wideField",
                    colspan: "3"
                }, _react2.default.createElement("input", {
                    class: "field",
                    id: "locality",
                    disabled: "true"
                }))), _react2.default.createElement("tr", null, _react2.default.createElement("td", {
                    class: "label"
                }, "State"), _react2.default.createElement("td", {
                    class: "slimField"
                }, _react2.default.createElement("input", {
                    class: "field",
                    id: "administrative_area_level_1",
                    disabled: "true"
                })), _react2.default.createElement("td", {
                    class: "label"
                }, "Zip code"), _react2.default.createElement("td", {
                    class: "wideField"
                }, _react2.default.createElement("input", {
                    class: "field",
                    id: "postal_code",
                    disabled: "true"
                }))), _react2.default.createElement("tr", null, _react2.default.createElement("td", {
                    class: "label"
                }, "Country"), _react2.default.createElement("td", {
                    class: "wideField",
                    colspan: "3"
                }, _react2.default.createElement("input", {
                    class: "field",
                    id: "country",
                    disabled: "true"
                })))));
            }
        } ]);
        return AutoComplete;
    }(_react.Component);
    exports.default = AutoComplete;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = function() {
        if (typeof web3 == "undefined") throw "No web3 detected. Is Metamask/Mist being used?";
        web3 = new Web3(web3.currentProvider);
        console.log("Using web3 version: " + Web3.version);
        var contractDataPromise = $.getJSON("HouseChain.json");
        var networkIdPromise = web3.eth.net.getId();
        return Promise.all([ contractDataPromise, networkIdPromise ]).then(function initApp(results) {
            var contractData = results[0];
            var networkId = results[1];
            if (!(networkId in contractData.networks)) {
                console.log(contractData.networks);
                throw new Error("Contract not found in selected Ethereum network on MetaMask.");
            }
            var contractAddress = contractData.networks[networkId].address;
            var contract = new web3.eth.Contract(contractData.abi, contractAddress);
            return contract;
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _react = __webpack_require__(2);
    var _react2 = _interopRequireDefault(_react);
    var _reactRedux = __webpack_require__(47);
    var _redux = __webpack_require__(24);
    var _actions = __webpack_require__(87);
    var AppActions = _interopRequireWildcard(_actions);
    var _contract = __webpack_require__(182);
    var _contract2 = _interopRequireDefault(_contract);
    var _autocomplete = __webpack_require__(181);
    var _autocomplete2 = _interopRequireDefault(_autocomplete);
    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var House = function(_Component) {
        _inherits(House, _Component);
        function House(props) {
            _classCallCheck(this, House);
            var _this = _possibleConstructorReturn(this, (House.__proto__ || Object.getPrototypeOf(House)).call(this, props));
            console.log(_this.props);
            _this.addAddress = _this.addAddress.bind(_this);
            _this.verifyAddress = _this.verifyAddress.bind(_this);
            _this.setContract = _this.setContract.bind(_this);
            (0, _contract2.default)().then(_this.setContract).catch(console.error);
            return _this;
        }
        _createClass(House, [ {
            key: "addAddress",
            value: function addAddress(addr) {
                console.log("Adding an address of " + addr + " for userAccount " + this.props.userAccount);
                this.contract.methods.add_address(this.props.userAccount, addr).send({
                    from: this.props.userAccount
                }).then(function(name) {
                    console.log("Address is " + name);
                });
            }
        }, {
            key: "verifyAddress",
            value: function verifyAddress(owner) {
                console.log("Reading an address for userAccount " + owner);
                this.contract.methods.verify_address(owner).call().then(function(addr) {
                    console.log("Address is " + addr);
                    $("#display").text("Address: " + addr);
                });
            }
        }, {
            key: "setContract",
            value: function setContract(contract) {
                this.contract = contract;
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;
                return _react2.default.createElement("div", null, _react2.default.createElement("h4", null, "Add your address and verify your home address"), _react2.default.createElement("label", {
                    for: "add-address",
                    class: "col-lg-2 control-label"
                }, "Add Address"), _react2.default.createElement("div", {
                    id: "locationField"
                }, _react2.default.createElement("input", {
                    id: "autocomplete",
                    ref: "enterAddressTextBox",
                    placeholder: "Enter your address",
                    type: "text"
                })), _react2.default.createElement(_autocomplete2.default, null), _react2.default.createElement("button", {
                    onClick: function onClick(e) {
                        return _this2.addAddress(_this2.refs.enterAddressTextBox.value);
                    }
                }, "Add Address"), _react2.default.createElement("label", {
                    for: "verify-address",
                    class: "col-lg-2 control-label"
                }, "Verify Address"), _react2.default.createElement("input", {
                    ref: "verifyAddressTextBox",
                    type: "text"
                }), _react2.default.createElement("button", {
                    onClick: function onClick(e) {
                        return _this2.verifyAddress(_this2.refs.verifyAddressTextBox.value);
                    }
                }, "Verify Address"), _react2.default.createElement("h2", {
                    id: "display"
                }));
            }
        } ]);
        return House;
    }(_react.Component);
    var mapStateToProps = function mapStateToProps(state, props) {
        return {
            userAccount: state.App.userAccount,
            uport: state.App.uport
        };
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            actions: (0, _redux.bindActionCreators)(AppActions, dispatch)
        };
    };
    exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(House);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var logo = '\n  <svg width="26px" height="25px" viewBox="0 0 26 25" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n  \x3c!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --\x3e\n  <title>White Logo</title>\n  <desc>Created with Sketch.</desc>\n  <defs>\n    <polygon id="path-1" points="0 25 0 0 26 0 26 25"></polygon>\n  </defs>\n    <g id="Log-In-Modal" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="Login-Modal-Button" transform="translate(-200.000000, -174.000000)">\n            <g id="White-Logo" transform="translate(200.000000, 174.000000)">\n                <mask id="mask-2" fill="white">\n                    <use xlink:href="#path-1"></use>\n                </mask>\n                <g id="Clip-2"></g>\n                <path d="M18.6353725,19.7892426 C17.496124,20.2865812 15.6009523,20.6241192 13.4275837,20.663487 C13.4256766,20.6637199 13.4237695,20.6637199 13.4218624,20.6637199 C13.2840751,20.6662823 13.1455726,20.66768 13.0056398,20.66768 L12.9999185,20.66768 L12.994674,20.66768 C12.8547412,20.66768 12.7160003,20.6662823 12.578213,20.6637199 C12.5763059,20.6637199 12.5743988,20.6637199 12.5724917,20.663487 C10.3991231,20.6241192 8.50395141,20.2865812 7.36470291,19.7892426 C5.76250807,19.1973281 4.76033174,18.3566279 4.76033174,17.4232153 C4.76033174,16.2920321 6.23212923,15.2973549 8.46056509,14.7168548 C8.56426316,14.93396 8.68107249,15.1438438 8.81480725,15.3425463 C6.68840076,15.8655089 5.47549087,16.7322991 5.47549087,17.4232153 C5.47549087,17.753532 5.75201907,18.1241483 6.2728933,18.4784584 C6.55061343,17.7472425 8.20286941,17.1376242 10.4603884,16.8713675 C11.2062994,17.3023166 12.0725955,17.5543637 12.9999185,17.5543637 C13.9274799,17.5543637 14.7940144,17.3023166 15.539687,16.8713675 C17.797206,17.1376242 19.4494619,17.7472425 19.7274205,18.4784584 C20.2480563,18.1241483 20.5248229,17.753532 20.5248229,17.4232153 C20.5248229,16.7322991 19.311913,15.8655089 17.1852681,15.3425463 C17.3192413,15.1438438 17.4360506,14.93396 17.5392719,14.7168548 C19.7679461,15.2975878 21.239982,16.2920321 21.239982,17.4232153 C21.239982,18.3566279 20.2375673,19.1973281 18.6353725,19.7892426 M12.9999185,8.81168687 C15.174479,8.81168687 16.9371079,10.5340857 16.9371079,12.6587815 C16.9371079,14.7837101 15.174479,16.506109 12.9999185,16.506109 C10.8255963,16.506109 9.06296746,14.7837101 9.06296746,12.6587815 C9.06296746,10.5340857 10.8255963,8.81168687 12.9999185,8.81168687 M25.8139014,18.573966 L13.9906523,0.52954331 C13.5277059,-0.176514437 12.4721311,-0.176514437 12.0096615,0.52954331 L0.185935538,18.573966 C-0.211216167,19.1803231 0.0533927125,19.9902745 0.736846457,20.2593266 L12.560334,24.9168385 C12.8423451,25.0277205 13.1574919,25.0277205 13.4397414,24.9168385 L25.2632289,20.2593266 C25.9466827,19.9902745 26.2112915,19.1803231 25.8139014,18.573966" id="Fill-1" fill="#FFFFFF" mask="url(#mask-2)"></path>\n            </g>\n        </g>\n    </g>\n</svg>\n';
    var logowithBG = '\n  <svg width="48px" height="46px" viewBox="0 0 48 46" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n      \x3c!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --\x3e\n      <title>Blurple Logo</title>\n      <desc>Created with Sketch.</desc>\n      <defs>\n          <polygon id="path-1" points="0 46 0 0 48 0 48 46"></polygon>\n      </defs>\n      <g id="Log-In-Modal" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n          <g id="Login-Modal-QR" transform="translate(-277.000000, -63.000000)">\n              <g id="Blurple-Logo" transform="translate(277.000000, 63.000000)">\n                  <mask id="mask-2" fill="white">\n                      <use xlink:href="#path-1"></use>\n                  </mask>\n                  <g id="Clip-2"></g>\n                  <path d="M34.4037645,36.4122063 C32.3005365,37.3273094 28.801758,37.9483793 24.7893852,38.020816 C24.7858644,38.0212446 24.7823436,38.0212446 24.7788229,38.0212446 C24.5244462,38.0259594 24.2687494,38.0285312 24.0104119,38.0285312 L23.9998495,38.0285312 L23.9901674,38.0285312 C23.7318299,38.0285312 23.4756929,38.0259594 23.2213163,38.0212446 C23.2177955,38.0212446 23.2142747,38.0212446 23.2107539,38.020816 C19.1983811,37.9483793 15.6996026,37.3273094 13.5963746,36.4122063 C10.6384764,35.3230837 8.78830475,33.7761953 8.78830475,32.0587162 C8.78830475,29.9773391 11.5054694,28.147133 15.6195048,27.0790128 C15.8109474,27.4784863 16.0265954,27.8646727 16.2734903,28.2302852 C12.3478168,29.1925364 10.1085985,30.7874303 10.1085985,32.0587162 C10.1085985,32.6664989 10.6191121,33.3484329 11.5807261,34.0003634 C12.0934402,32.6549262 15.1437589,31.5332285 19.3114863,31.0433162 C20.6885527,31.8362626 22.2878686,32.3000291 23.9998495,32.3000291 C25.7122706,32.3000291 27.3120265,31.8362626 28.6886528,31.0433162 C32.8563802,31.5332285 35.906699,32.6549262 36.4198531,34.0003634 C37.381027,33.3484329 37.8919807,32.6664989 37.8919807,32.0587162 C37.8919807,30.7874303 35.6527625,29.1925364 31.7266488,28.2302852 C31.9739839,27.8646727 32.1896319,27.4784863 32.3801943,27.0790128 C36.4946698,28.1475616 39.2122745,29.9773391 39.2122745,32.0587162 C39.2122745,33.7761953 37.3616627,35.3230837 34.4037645,36.4122063 M23.9998495,16.2135038 C28.0144228,16.2135038 31.2685069,19.3827178 31.2685069,23.2921579 C31.2685069,27.2020266 28.0144228,30.3712406 23.9998495,30.3712406 C19.9857163,30.3712406 16.7316322,27.2020266 16.7316322,23.2921579 C16.7316322,19.3827178 19.9857163,16.2135038 23.9998495,16.2135038 M47.6564334,34.1760975 L25.8288965,0.974359691 C24.9742263,-0.324786564 23.0254727,-0.324786564 22.1716827,0.974359691 L0.343265609,34.1760975 C-0.389937538,35.2917945 0.0985711616,36.7821051 1.36033192,37.2771609 L23.1883089,45.8469828 C23.7089448,46.0510057 24.2907542,46.0510057 24.8118302,45.8469828 L46.6398072,37.2771609 C47.901568,36.7821051 48.3900767,35.2917945 47.6564334,34.1760975" id="Fill-1" fill="#5C50CA" mask="url(#mask-2)"></path>\n              </g>\n          </g>\n      </g>\n  </svg>\n';
    var appleApp = '\n  <svg width="129px" height="40px" viewBox="0 0 129 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    \x3c!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --\x3e\n    <title>app-store-badge</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="Log-In-Modal" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n      <g id="Login-Modal-Button" transform="translate(-170.000000, -319.000000)" fill-rule="nonzero">\n        <g id="app-store-badge" transform="translate(170.000000, 319.000000)">\n          <path d="M124.2,40 L4.2,40 C2,40 0.2,38.2 0.2,36 L0.2,4 C0.2,1.8 2,0 4.2,0 L124.2,0 C126.4,0 128.2,1.8 128.2,4 L128.2,36 C128.2,38.2 126.4,40 124.2,40 Z" id="Shape" fill="#000000"></path>\n          <path d="M27.2,19.8 C27.2,16.7 29.8,15.2 29.9,15.1 C28.4,13 26.2,12.7 25.4,12.6 C23.5,12.4 21.6,13.7 20.7,13.7 C19.7,13.7 18.2,12.6 16.6,12.6 C14.5,12.6 12.6,13.8 11.5,15.7 C9.3,19.5 10.9,25.1 13,28.2 C14.1,29.7 15.3,31.4 16.9,31.3 C18.5,31.2 19.1,30.3 21,30.3 C22.9,30.3 23.4,31.3 25.1,31.3 C26.8,31.3 27.9,29.8 28.9,28.3 C30.1,26.6 30.6,24.9 30.6,24.8 C30.5,24.7 27.2,23.5 27.2,19.8 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M24.1,10.6 C24.9,9.5 25.5,8.1 25.4,6.6 C24.2,6.7 22.6,7.4 21.8,8.5 C21,9.4 20.3,10.9 20.5,12.3 C21.8,12.4 23.2,11.6 24.1,10.6 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M50,31.1 L47.8,31.1 L46.6,27.3 L42.4,27.3 L41.3,31.1 L39.2,31.1 L43.4,18.2 L46,18.2 L50,31.1 Z M46.2,25.7 L45.1,22.3 C45,22 44.8,21.1 44.4,19.9 L44.4,19.9 C44.3,20.4 44.1,21.3 43.8,22.3 L42.7,25.7 L46.2,25.7 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M60.7,26.4 C60.7,28 60.3,29.2 59.4,30.2 C58.6,31 57.7,31.4 56.5,31.4 C55.3,31.4 54.4,31 53.9,30.1 L53.9,30.1 L53.9,35 L51.8,35 L51.8,25 C51.8,24 51.8,23 51.7,21.9 L53.5,21.9 L53.6,23.4 L53.6,23.4 C54.3,22.3 55.3,21.7 56.7,21.7 C57.8,21.7 58.7,22.1 59.4,23 C60.3,23.8 60.7,24.9 60.7,26.4 Z M58.6,26.4 C58.6,25.5 58.4,24.7 58,24.2 C57.6,23.6 57,23.3 56.2,23.3 C55.7,23.3 55.2,23.5 54.8,23.8 C54.4,24.1 54.1,24.6 54,25.1 C53.9,25.4 53.9,25.6 53.9,25.7 L53.9,27.3 C53.9,28 54.1,28.5 54.5,29 C54.9,29.5 55.5,29.7 56.1,29.7 C56.9,29.7 57.5,29.4 57.9,28.8 C58.4,28.2 58.6,27.4 58.6,26.4 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M71.4,26.4 C71.4,28 71,29.2 70.1,30.2 C69.3,31 68.4,31.4 67.2,31.4 C66,31.4 65.1,31 64.6,30.1 L64.6,30.1 L64.6,35 L62.5,35 L62.5,25 C62.5,24 62.5,23 62.4,21.9 L64.2,21.9 L64.3,23.4 L64.3,23.4 C65,22.3 66,21.7 67.4,21.7 C68.5,21.7 69.4,22.1 70.1,23 C71,23.8 71.4,24.9 71.4,26.4 Z M69.3,26.4 C69.3,25.5 69.1,24.7 68.7,24.2 C68.3,23.6 67.7,23.3 66.9,23.3 C66.4,23.3 65.9,23.5 65.5,23.8 C65.1,24.1 64.8,24.6 64.7,25.1 C64.6,25.4 64.6,25.6 64.6,25.7 L64.6,27.3 C64.6,28 64.8,28.5 65.2,29 C65.6,29.5 66.2,29.7 66.8,29.7 C67.6,29.7 68.2,29.4 68.6,28.8 C69.1,28.2 69.3,27.4 69.3,26.4 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M83.4,27.5 C83.4,28.6 83,29.5 82.3,30.2 C81.5,31 80.3,31.3 78.8,31.3 C77.4,31.3 76.3,31 75.5,30.5 L76,28.8 C76.9,29.3 77.9,29.6 79,29.6 C79.8,29.6 80.4,29.4 80.8,29.1 C81.2,28.7 81.4,28.3 81.4,27.7 C81.4,27.2 81.2,26.7 80.9,26.4 C80.5,26 79.9,25.7 79.1,25.4 C76.8,24.6 75.7,23.3 75.7,21.7 C75.7,20.6 76.1,19.8 76.9,19.1 C77.7,18.4 78.7,18.1 80.1,18.1 C81.3,18.1 82.2,18.3 83,18.7 L82.5,20.4 C81.8,20 81,19.8 80,19.8 C79.3,19.8 78.7,20 78.3,20.3 C78,20.6 77.8,21 77.8,21.5 C77.8,22 78,22.4 78.4,22.8 C78.7,23.1 79.4,23.4 80.3,23.8 C81.4,24.2 82.2,24.8 82.8,25.4 C83.1,25.9 83.4,26.6 83.4,27.5 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M90.2,23.4 L87.9,23.4 L87.9,27.9 C87.9,29 88.3,29.6 89.1,29.6 C89.5,29.6 89.8,29.6 90,29.5 L90.1,31.1 C89.7,31.3 89.2,31.3 88.5,31.3 C87.7,31.3 87,31.1 86.6,30.6 C86.1,30.1 85.9,29.3 85.9,28.1 L85.9,23.4 L84.5,23.4 L84.5,21.8 L85.9,21.8 L85.9,20.1 L87.9,19.5 L87.9,21.8 L90.2,21.8 L90.2,23.4 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M100.5,26.4 C100.5,27.8 100.1,29 99.3,29.9 C98.4,30.8 97.3,31.3 95.9,31.3 C94.5,31.3 93.4,30.8 92.6,29.9 C91.8,29 91.4,27.9 91.4,26.5 C91.4,25.1 91.8,23.9 92.7,23 C93.5,22.1 94.7,21.6 96.1,21.6 C97.5,21.6 98.6,22.1 99.4,23 C100.1,23.9 100.5,25 100.5,26.4 Z M98.3,26.5 C98.3,25.6 98.1,24.9 97.7,24.3 C97.3,23.6 96.6,23.2 95.8,23.2 C95,23.2 94.3,23.6 93.9,24.3 C93.5,24.9 93.3,25.7 93.3,26.5 C93.3,27.4 93.5,28.1 93.9,28.7 C94.3,29.4 95,29.8 95.8,29.8 C96.6,29.8 97.2,29.4 97.7,28.7 C98.1,28.1 98.3,27.3 98.3,26.5 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M107.2,23.6 C107,23.6 106.8,23.5 106.5,23.5 C105.8,23.5 105.2,23.8 104.8,24.3 C104.5,24.8 104.3,25.4 104.3,26.1 L104.3,31 L102.2,31 L102.2,24.6 C102.2,23.5 102.2,22.6 102.1,21.7 L103.9,21.7 L104,23.5 L104.1,23.5 C104.3,22.9 104.7,22.4 105.1,22 C105.6,21.7 106.1,21.5 106.6,21.5 C106.8,21.5 107,21.5 107.1,21.5 L107.1,23.6 L107.2,23.6 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M116.4,26 C116.4,26.4 116.4,26.7 116.3,26.9 L110.1,26.9 C110.1,27.8 110.4,28.5 111,29 C111.5,29.4 112.2,29.7 113,29.7 C113.9,29.7 114.8,29.6 115.5,29.3 L115.8,30.7 C114.9,31.1 113.9,31.3 112.7,31.3 C111.3,31.3 110.1,30.9 109.3,30 C108.5,29.2 108.1,28 108.1,26.6 C108.1,25.2 108.5,24 109.2,23.1 C110,22.1 111.1,21.6 112.5,21.6 C113.8,21.6 114.9,22.1 115.5,23.1 C116.2,23.9 116.4,24.9 116.4,26 Z M114.5,25.5 C114.5,24.9 114.4,24.4 114.1,23.9 C113.7,23.3 113.2,23 112.5,23 C111.8,23 111.3,23.3 110.9,23.8 C110.6,24.2 110.4,24.8 110.3,25.4 L114.5,25.4 L114.5,25.5 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M45.6,10.3 C45.6,11.4 45.3,12.3 44.6,12.9 C44,13.4 43.1,13.7 41.9,13.7 C41.3,13.7 40.8,13.7 40.4,13.6 L40.4,7.4 C40.9,7.3 41.5,7.3 42.2,7.3 C43.3,7.3 44.1,7.5 44.7,8 C45.2,8.5 45.6,9.3 45.6,10.3 Z M44.5,10.3 C44.5,9.6 44.3,9 43.9,8.6 C43.5,8.2 42.9,8 42.2,8 C41.9,8 41.6,8 41.4,8.1 L41.4,12.8 C41.5,12.8 41.8,12.8 42.1,12.8 C42.9,12.8 43.5,12.6 43.9,12.2 C44.3,11.8 44.5,11.1 44.5,10.3 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M51.2,11.3 C51.2,12 51,12.6 50.6,13 C50.2,13.5 49.6,13.7 48.9,13.7 C48.2,13.7 47.7,13.5 47.3,13 C46.9,12.6 46.7,12 46.7,11.3 C46.7,10.6 46.9,10 47.3,9.6 C47.7,9.1 48.3,8.9 49,8.9 C49.7,8.9 50.2,9.1 50.6,9.6 C51,10 51.2,10.6 51.2,11.3 Z M50.2,11.3 C50.2,10.9 50.1,10.5 49.9,10.2 C49.7,9.8 49.4,9.7 49,9.7 C48.6,9.7 48.3,9.9 48.1,10.2 C47.9,10.5 47.8,10.9 47.8,11.3 C47.8,11.7 47.9,12.1 48.1,12.4 C48.3,12.8 48.6,12.9 49,12.9 C49.4,12.9 49.7,12.7 49.9,12.3 C50.1,12.1 50.2,11.7 50.2,11.3 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M58.9,9 L57.5,13.6 L56.6,13.6 L56,11.6 C55.8,11.1 55.7,10.6 55.6,10.1 L55.6,10.1 C55.5,10.6 55.4,11.1 55.2,11.6 L54.6,13.6 L53.7,13.6 L52.2,9 L53.2,9 L53.7,11.2 C53.8,11.7 53.9,12.2 54,12.7 L54,12.7 C54.1,12.3 54.2,11.8 54.4,11.2 L55,9 L55.8,9 L56.4,11.1 C56.6,11.6 56.7,12.1 56.8,12.6 L56.8,12.6 C56.9,12.1 57,11.6 57.1,11.1 L57.7,9 L58.9,9 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M64.1,13.6 L63.1,13.6 L63.1,11 C63.1,10.2 62.8,9.8 62.2,9.8 C61.9,9.8 61.7,9.9 61.5,10.1 C61.3,10.3 61.2,10.6 61.2,10.9 L61.2,13.6 L60.2,13.6 L60.2,10.3 C60.2,9.9 60.2,9.5 60.2,9 L61.1,9 L61.1,9.7 L61.1,9.7 C61.2,9.5 61.4,9.3 61.6,9.1 C61.9,8.9 62.2,8.8 62.5,8.8 C62.9,8.8 63.3,8.9 63.6,9.2 C64,9.5 64.1,10 64.1,10.7 L64.1,13.6 Z" id="Shape" fill="#FFFFFF"></path>\n          <polygon id="Shape" fill="#FFFFFF" points="66.9 13.6 65.9 13.6 65.9 6.9 66.9 6.9"></polygon>\n          <path d="M72.9,11.3 C72.9,12 72.7,12.6 72.3,13 C71.9,13.5 71.3,13.7 70.6,13.7 C69.9,13.7 69.4,13.5 69,13 C68.6,12.6 68.4,12 68.4,11.3 C68.4,10.6 68.6,10 69,9.6 C69.4,9.2 70,8.9 70.7,8.9 C71.4,8.9 71.9,9.1 72.3,9.6 C72.7,10 72.9,10.6 72.9,11.3 Z M71.9,11.3 C71.9,10.9 71.8,10.5 71.6,10.2 C71.4,9.8 71.1,9.7 70.7,9.7 C70.3,9.7 70,9.9 69.8,10.2 C69.6,10.5 69.5,10.9 69.5,11.3 C69.5,11.7 69.6,12.1 69.8,12.4 C70,12.8 70.3,12.9 70.7,12.9 C71.1,12.9 71.4,12.7 71.6,12.3 C71.8,12.1 71.9,11.7 71.9,11.3 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M77.8,13.6 L76.9,13.6 L76.8,13.1 L76.8,13.1 C76.5,13.5 76,13.7 75.5,13.7 C75.1,13.7 74.7,13.6 74.5,13.3 C74.3,13 74.1,12.7 74.1,12.4 C74.1,11.8 74.3,11.4 74.8,11.1 C75.3,10.8 75.9,10.7 76.8,10.7 L76.8,10.6 C76.8,10 76.5,9.7 75.9,9.7 C75.4,9.7 75.1,9.8 74.7,10 L74.5,9.3 C74.9,9 75.4,8.9 76.1,8.9 C77.3,8.9 77.9,9.5 77.9,10.8 L77.9,12.5 C77.8,13 77.8,13.3 77.8,13.6 Z M76.8,12 L76.8,11.3 C75.7,11.3 75.1,11.6 75.1,12.2 C75.1,12.4 75.2,12.6 75.3,12.7 C75.4,12.8 75.6,12.9 75.8,12.9 C76,12.9 76.2,12.8 76.4,12.7 C76.6,12.6 76.7,12.4 76.8,12.2 C76.8,12.2 76.8,12.1 76.8,12 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M83.6,13.6 L82.7,13.6 L82.7,12.9 L82.7,12.9 C82.4,13.5 81.9,13.7 81.2,13.7 C80.6,13.7 80.2,13.5 79.8,13.1 C79.4,12.7 79.3,12.1 79.3,11.4 C79.3,10.7 79.5,10.1 79.9,9.6 C80.3,9.2 80.8,9 81.3,9 C81.9,9 82.3,9.2 82.6,9.6 L82.6,9.6 L82.6,7 L83.6,7 L83.6,12.4 C83.6,12.8 83.6,13.2 83.6,13.6 Z M82.6,11.7 L82.6,10.9 C82.6,10.8 82.6,10.7 82.6,10.6 C82.5,10.4 82.4,10.2 82.2,10 C82,9.8 81.8,9.8 81.5,9.8 C81.1,9.8 80.8,10 80.6,10.3 C80.4,10.6 80.3,11 80.3,11.5 C80.3,12 80.4,12.3 80.6,12.6 C80.8,12.9 81.1,13.1 81.5,13.1 C81.8,13.1 82.1,13 82.3,12.7 C82.5,12.3 82.6,12 82.6,11.7 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M92.3,11.3 C92.3,12 92.1,12.6 91.7,13 C91.3,13.5 90.7,13.7 90,13.7 C89.3,13.7 88.8,13.5 88.4,13 C88,12.6 87.8,12 87.8,11.3 C87.8,10.6 88,10 88.4,9.6 C88.8,9.1 89.4,8.9 90.1,8.9 C90.8,8.9 91.3,9.1 91.7,9.6 C92.1,10 92.3,10.6 92.3,11.3 Z M91.2,11.3 C91.2,10.9 91.1,10.5 90.9,10.2 C90.7,9.8 90.4,9.7 90,9.7 C89.6,9.7 89.3,9.9 89.1,10.2 C88.9,10.5 88.8,10.9 88.8,11.3 C88.8,11.7 88.9,12.1 89.1,12.4 C89.3,12.8 89.6,12.9 90,12.9 C90.4,12.9 90.7,12.7 90.9,12.3 C91.1,12.1 91.2,11.7 91.2,11.3 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M97.8,13.6 L96.8,13.6 L96.8,11 C96.8,10.2 96.5,9.8 95.9,9.8 C95.6,9.8 95.4,9.9 95.2,10.1 C95,10.3 94.9,10.6 94.9,10.9 L94.9,13.6 L93.9,13.6 L93.9,10.3 C93.9,9.9 93.9,9.5 93.9,9 L94.8,9 L94.8,9.7 L94.8,9.7 C94.9,9.5 95.1,9.3 95.3,9.1 C95.6,8.9 95.9,8.8 96.2,8.8 C96.6,8.8 97,8.9 97.3,9.2 C97.7,9.5 97.8,10 97.8,10.7 L97.8,13.6 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M104.6,9.8 L103.5,9.8 L103.5,12 C103.5,12.6 103.7,12.8 104.1,12.8 C104.3,12.8 104.4,12.8 104.6,12.8 L104.6,13.6 C104.4,13.7 104.1,13.7 103.8,13.7 C103.4,13.7 103.1,13.6 102.9,13.3 C102.7,13.1 102.6,12.6 102.6,12.1 L102.6,9.8 L101.9,9.8 L101.9,9 L102.6,9 L102.6,8.2 L103.6,7.9 L103.6,9 L104.7,9 L104.7,9.8 L104.6,9.8 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M110,13.6 L109,13.6 L109,11 C109,10.2 108.7,9.8 108.1,9.8 C107.6,9.8 107.3,10 107.1,10.5 C107.1,10.6 107.1,10.7 107.1,10.9 L107.1,13.6 L106.1,13.6 L106.1,6.9 L107.1,6.9 L107.1,9.7 L107.1,9.7 C107.4,9.2 107.9,8.9 108.5,8.9 C108.9,8.9 109.3,9 109.5,9.3 C109.8,9.6 110,10.2 110,10.8 L110,13.6 Z" id="Shape" fill="#FFFFFF"></path>\n          <path d="M115.5,11.1 C115.5,11.3 115.5,11.4 115.5,11.6 L112.5,11.6 C112.5,12.1 112.7,12.4 112.9,12.6 C113.2,12.8 113.5,12.9 113.9,12.9 C114.4,12.9 114.8,12.8 115.1,12.7 L115.3,13.4 C114.9,13.6 114.4,13.7 113.8,13.7 C113.1,13.7 112.5,13.5 112.1,13.1 C111.7,12.7 111.5,12.1 111.5,11.4 C111.5,10.7 111.7,10.1 112.1,9.7 C112.5,9.2 113,9 113.7,9 C114.4,9 114.9,9.2 115.2,9.7 C115.4,10 115.5,10.5 115.5,11.1 Z M114.6,10.8 C114.6,10.5 114.5,10.2 114.4,10 C114.2,9.7 114,9.6 113.6,9.6 C113.3,9.6 113,9.7 112.8,10 C112.6,10.2 112.5,10.5 112.5,10.8 L114.6,10.8 Z" id="Shape" fill="#FFFFFF"></path>\n        </g>\n      </g>\n    </g>\n  </svg>\n';
    var androidApp = '\n  <svg width="129px" height="41px" viewBox="0 0 129 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    \x3c!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --\x3e\n    <title>google-play-badge</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <linearGradient x1="29.5315068%" y1="-6.0957265%" x2="55.0940639%" y2="92.1559829%" id="linearGradient-1">\n            <stop stop-color="#006884" offset="0%"></stop>\n            <stop stop-color="#8AD1D0" offset="100%"></stop>\n        </linearGradient>\n        <linearGradient x1="-7.52792208%" y1="15.7589744%" x2="91.537013%" y2="86.2504274%" id="linearGradient-2">\n            <stop stop-color="#24BBB6" offset="0%"></stop>\n            <stop stop-color="#DBE692" offset="100%"></stop>\n        </linearGradient>\n        <linearGradient x1="49.9404255%" y1="105.754795%" x2="49.9404255%" y2="-3.12739726%" id="linearGradient-3">\n            <stop stop-color="#FCC072" offset="0%"></stop>\n            <stop stop-color="#F58A5B" offset="100%"></stop>\n        </linearGradient>\n        <linearGradient x1="11.1493421%" y1="117.837069%" x2="90.4368421%" y2="12.1025862%" id="linearGradient-4">\n            <stop stop-color="#712B8F" offset="0%"></stop>\n            <stop stop-color="#EA1D27" offset="100%"></stop>\n        </linearGradient>\n    </defs>\n    <g id="Log-In-Modal" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n      <g id="Login-Modal-Button" transform="translate(-308.000000, -318.000000)">\n        <g id="google-play-badge" transform="translate(308.000000, 318.000000)">\n            <path d="M124.5,40.5 L4.5,40.5 C2.3,40.5 0.5,38.7 0.5,36.5 L0.5,4.5 C0.5,2.3 2.3,0.5 4.5,0.5 L124.5,0.5 C126.7,0.5 128.5,2.3 128.5,4.5 L128.5,36.5 C128.5,38.7 126.7,40.5 124.5,40.5 Z" id="Shape" fill="#000000" fill-rule="nonzero"></path>\n            <path d="M10.3,20.1 L10.3,9.6 C10.3,9 10.8,8.5 11.3,8.5 C11.8,8.5 12,8.6 12.3,8.8 L31.6,19.4 C32,19.6 32.2,19.9 32.2,20.2 C32.2,20.5 32,20.8 31.6,21 L12.3,31.6 C12.1,31.7 11.8,31.9 11.3,31.9 C10.8,31.9 10.3,31.4 10.3,30.8 L10.3,20.1 Z" id="Shape" fill="url(#linearGradient-1)"></path>\n            <path d="M22.8,20.2 L11.1,8.5 C11.2,8.5 11.2,8.5 11.3,8.5 C11.8,8.5 12,8.6 12.3,8.8 L26.5,16.6 L22.8,20.2 Z" id="Shape" fill="url(#linearGradient-2)"></path>\n            <path d="M26.4,23.7 L22.8,20.1 L26.5,16.4 L31.6,19.2 C32,19.4 32.2,19.7 32.2,20 C32.2,20.3 32,20.6 31.6,20.8 L26.4,23.7 Z" id="Shape" fill="url(#linearGradient-3)"></path>\n            <path d="M11.2,31.7 L11.2,31.7 L22.8,20.1 L26.4,23.7 L12.3,31.4 C12,31.6 11.8,31.7 11.2,31.7 C11.3,31.7 11.3,31.7 11.2,31.7 Z" id="Shape" fill="url(#linearGradient-4)"></path>\n            <path d="M71.6,34.4 C71.1,34 70.7,33.3 70.5,32.9 L72.1,32.2 C72.2,32.4 72.4,32.7 72.6,33 C73,33.4 73.6,33.8 74.2,33.8 C74.8,33.8 75.5,33.5 75.9,33 C76.2,32.5 76.4,32 76.4,31.3 L76.4,30.7 C75.2,32.2 72.7,32 71.3,30.4 C69.8,28.8 69.8,26.1 71.3,24.5 C72.8,23 75,22.8 76.3,24.2 C76.3,24.2 76.3,24.2 76.3,24.2 L76.3,23.5 L78,23.5 L78,31 C78,32.9 77.3,34 76.4,34.7 C75.8,35.2 74.9,35.4 74.1,35.4 C73.2,35.3 72.3,35 71.6,34.4 L71.6,34.4 Z M113.5,34.8 L113.5,34.8 L115.2,30.8 L112.2,23.9 L113.9,23.9 L116,28.8 L118.1,23.9 L119.8,23.9 L115.2,34.8 L113.5,34.8 L113.5,34.8 Z M105.4,31 L105.4,31 C104.9,30.5 104.7,29.8 104.7,29.1 C104.7,28.5 104.9,27.9 105.3,27.5 C106,26.8 107,26.5 108.1,26.5 C108.8,26.5 109.4,26.6 109.9,26.9 C109.9,25.7 108.9,25.2 108.1,25.2 C107.4,25.2 106.7,25.6 106.4,26.3 L104.9,25.7 C105.2,25 106,23.7 108,23.7 C109,23.7 110,24 110.6,24.7 C111.2,25.4 111.4,26.2 111.4,27.3 L111.4,31.5 L109.7,31.5 L109.7,30.8 C109.5,31.1 109.1,31.3 108.8,31.5 C108.4,31.7 107.9,31.8 107.4,31.8 C106.8,31.7 105.9,31.5 105.4,31 L105.4,31 Z M52.1,27.4 L52.1,27.4 C52.1,25.4 53.6,23.2 56.3,23.2 C58.9,23.2 60.5,25.4 60.5,27.4 C60.5,29.4 59,31.6 56.3,31.6 C53.6,31.6 52.1,29.4 52.1,27.4 L52.1,27.4 Z M61.1,27.4 L61.1,27.4 C61.1,25.4 62.6,23.2 65.3,23.2 C67.9,23.2 69.5,25.4 69.5,27.4 C69.5,29.4 68,31.6 65.3,31.6 C62.7,31.6 61.1,29.4 61.1,27.4 L61.1,27.4 Z M40.8,29.6 L40.8,29.6 C38.3,27.1 38.4,23 40.9,20.4 C42.2,19.1 43.8,18.5 45.5,18.5 C47.1,18.5 48.7,19.1 49.9,20.3 L48.7,21.6 C46.9,19.8 44,19.9 42.3,21.7 C40.5,23.6 40.5,26.5 42.3,28.4 C44.1,30.3 47.1,30.4 48.9,28.5 C49.5,27.9 49.7,27.1 49.8,26.3 L45.6,26.3 L45.6,24.5 L51.5,24.5 C51.6,24.9 51.6,25.4 51.6,25.9 C51.6,27.4 51,28.9 50,29.9 C48.9,31 47.3,31.6 45.7,31.6 C43.9,31.5 42.1,30.9 40.8,29.6 L40.8,29.6 Z M83.1,30.3 L83.1,30.3 C81.6,28.7 81.6,26 83.1,24.3 C84.6,22.7 87.1,22.7 88.5,24.3 C89,24.8 89.3,25.5 89.6,26.2 L84.1,28.5 C84.4,29.2 85.1,29.8 86.1,29.8 C87,29.8 87.6,29.5 88.2,28.6 L89.7,29.6 L89.7,29.6 C89.5,29.8 89.3,30 89.2,30.2 C87.5,31.9 84.6,31.9 83.1,30.3 L83.1,30.3 Z M93.5,31.5 L93.5,31.5 L93.5,20.4 L97.1,20.4 C99.2,20.4 100.9,21.9 100.9,23.7 C100.9,25.5 99.4,27 97.5,27 L95.3,27 L95.3,31.4 L93.5,31.4 L93.5,31.5 Z M101.9,31.5 L101.9,31.5 L101.9,20.4 L103.6,20.4 L103.6,31.5 L101.9,31.5 L101.9,31.5 Z M79.3,31.3 L79.3,31.3 L79.3,18.9 L81.1,18.9 L81.1,31.3 L79.3,31.3 L79.3,31.3 Z M109.8,28.2 L109.8,28.2 C109.4,27.9 108.8,27.8 108.2,27.8 C107,27.8 106.3,28.4 106.3,29.1 C106.3,29.8 107,30.2 107.7,30.2 C108.7,30.2 109.8,29.4 109.8,28.2 L109.8,28.2 Z M58.6,27.4 L58.6,27.4 C58.6,26.2 57.8,24.9 56.3,24.9 C54.8,24.9 54,26.2 54,27.4 C54,28.6 54.8,29.9 56.3,29.9 C57.7,29.9 58.6,28.6 58.6,27.4 L58.6,27.4 Z M67.6,27.4 L67.6,27.4 C67.6,26.2 66.8,24.9 65.3,24.9 C63.8,24.9 63,26.2 63,27.4 C63,28.6 63.8,29.9 65.3,29.9 C66.8,29.9 67.6,28.6 67.6,27.4 L67.6,27.4 Z M76.5,28.1 L76.5,28.1 C76.5,28 76.5,27.9 76.6,27.8 C76.6,27.8 76.6,27.8 76.6,27.8 C76.6,27.7 76.6,27.5 76.6,27.4 C76.6,27.3 76.6,27.1 76.6,27 C76.6,27 76.6,26.9 76.6,26.9 C76.6,26.8 76.5,26.6 76.5,26.5 C76.2,25.5 75.3,24.8 74.4,24.8 C73.2,24.8 72.2,26 72.2,27.3 C72.2,28.7 73.2,29.8 74.5,29.8 C75.3,29.9 76.1,29.2 76.5,28.1 L76.5,28.1 Z M83.8,27.2 L83.8,27.2 L87.5,25.6 C87.1,24.9 86.5,24.7 86,24.7 C84.5,24.8 83.6,26.4 83.8,27.2 L83.8,27.2 Z M99.1,23.8 L99.1,23.8 C99.1,22.8 98.3,22.1 97.2,22.1 L95.2,22.1 L95.2,25.6 L97.3,25.6 C98.3,25.6 99.1,24.8 99.1,23.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <polygon id="Shape" fill="#FFFFFF" points="114.8 32.8 114.8 32.8 114.7 32.8 114.7 32.8 114.7 32.7 114.7 32.7 114.8 32.7 114.8 32.7 114.7 32.7 114.7 32.7 114.7 32.8 114.7 32.8"></polygon>\n            <path d="M114.8,32.8 L114.8,32.8 C114.8,32.7 114.8,32.7 114.8,32.8 L114.8,32.8 C114.8,32.7 114.8,32.7 114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <polygon id="Shape" fill="#FFFFFF" points="114.8 32.8 114.8 32.8 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.8"></polygon>\n            <polygon id="Shape" fill="#FFFFFF" points="114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.8 114.8 32.8 114.8 32.7"></polygon>\n            <polygon id="Shape" fill="#FFFFFF" points="114.8 32.8 114.8 32.8 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.7 114.8 32.8"></polygon>\n            <path d="M114.8,32.8 L114.8,32.8 C114.8,32.7 114.8,32.7 114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 C114.8,32.8 114.8,32.8 114.8,32.8 L114.8,32.8 Z M114.8,32.8 L114.8,32.8 C114.8,32.8 114.8,32.8 114.8,32.8 L114.8,32.8 L114.8,32.8 L114.8,32.8 C114.8,32.7 114.8,32.7 114.8,32.8 L114.8,32.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <path d="M114.9,32.8 L114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 L114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 L114.9,32.8 L114.9,32.8 L114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 L114.9,32.8 Z M114.9,32.8 L114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 L114.9,32.8 L114.9,32.8 L114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 L114.9,32.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <polygon id="Shape" fill="#FFFFFF" points="114.9 32.7 114.9 32.7 114.9 32.7 114.9 32.7 114.9 32.7 114.9 32.7 114.9 32.7 114.9 32.7 114.9 32.8 114.9 32.8"></polygon>\n            <polygon id="Shape" fill="#FFFFFF" points="114.9 32.8 114.9 32.8 114.9 32.7 114.9 32.7 114.9 32.8"></polygon>\n            <path d="M114.9,32.8 L114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 L114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 L114.9,32.8 Z M114.9,32.7 L114.9,32.7 C114.9,32.8 114.9,32.8 114.9,32.7 C114.9,32.8 114.9,32.8 114.9,32.7 L114.9,32.7 C114.9,32.7 114.9,32.7 114.9,32.7 C114.9,32.7 114.9,32.7 114.9,32.7 L114.9,32.7 Z" id="Shape" fill="#FFFFFF"></path>\n            <path d="M114.9,32.8 L114.9,32.8 L114.9,32.8 L114.9,32.8 L114.9,32.8 L114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 L114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 L114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 C114.9,32.7 114.9,32.7 114.9,32.8 L114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 C114.9,32.8 114.9,32.8 114.9,32.8 L114.9,32.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <path d="M115,32.8 L115,32.8 C115,32.7 115,32.7 115,32.8 C114.9,32.7 114.9,32.7 115,32.8 L115,32.8 C114.9,32.8 114.9,32.8 115,32.8 C115,32.8 115,32.8 115,32.8 L115,32.8 Z M115,32.7 L115,32.7 C115,32.8 115,32.8 115,32.7 C115,32.8 114.9,32.8 115,32.7 L115,32.7 C114.9,32.7 115,32.7 115,32.7 C115,32.7 115,32.7 115,32.7 L115,32.7 Z" id="Shape" fill="#FFFFFF"></path>\n            <polygon id="Shape" fill="#FFFFFF" points="115 32.8 115 32.7 115 32.7 115 32.7 115 32.7 115 32.7 115 32.8 115 32.8 115 32.7 115 32.7 115 32.8 115 32.8 115 32.7 115 32.7"></polygon>\n            <path d="M115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.7 115,32.7 115,32.8 L115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.7 115,32.7 115,32.8 C115,32.8 115,32.8 115,32.8 C115,32.8 115,32.8 115,32.8 L115,32.8 C115,32.8 115,32.8 115,32.8 C115,32.8 115,32.8 115,32.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <polygon id="Shape" fill="#FFFFFF" points="115.1 32.7 115 32.7 115 32.7 115.1 32.7 115.1 32.8 115.1 32.8 115.1 32.7"></polygon>\n            <polygon id="Shape" fill="#FFFFFF" points="115.1 32.8 115.1 32.8 115.1 32.7 115.1 32.7 115.1 32.7 115.1 32.7 115.1 32.7 115.1 32.7 115.1 32.7 115.1 32.7 115.1 32.8"></polygon>\n            <path d="M115.1,32.8 L115.1,32.8 C115.1,32.7 115.1,32.7 115.1,32.8 L115.1,32.8 C115.1,32.7 115.1,32.7 115.1,32.8 L115.1,32.8 L115.1,32.8 L115.1,32.8 L115.1,32.8 L115.1,32.8 L115.1,32.8 L115.1,32.8 L115.1,32.8 Z" id="Shape" fill="#FFFFFF"></path>\n            <path d="M39.4,10.6 C39.4,8.8 40.7,7.7 42.3,7.7 C43.4,7.7 44.1,8.2 44.6,8.9 L43.8,9.4 C43.5,9 43,8.7 42.3,8.7 C41.2,8.7 40.4,9.5 40.4,10.7 C40.4,11.9 41.2,12.7 42.3,12.7 C42.9,12.7 43.4,12.4 43.6,12.2 L43.6,11.3 L42,11.3 L42,10.4 L44.7,10.4 L44.7,12.5 C44.2,13.1 43.4,13.5 42.4,13.5 C40.7,13.5 39.4,12.3 39.4,10.6 Z" id="Shape" fill="#FFFFFF" fill-rule="nonzero"></path>\n            <polygon id="Shape" fill="#FFFFFF" fill-rule="nonzero" points="45.9 13.4 45.9 7.8 49.7 7.8 49.7 8.7 46.8 8.7 46.8 10.1 49.6 10.1 49.6 11 46.8 11 46.8 12.6 49.7 12.6 49.7 13.5"></polygon>\n            <polygon id="Shape" fill="#FFFFFF" fill-rule="nonzero" points="52.5 13.4 52.5 8.7 50.8 8.7 50.8 7.8 55.2 7.8 55.2 8.7 53.5 8.7 53.5 13.4"></polygon>\n            <path d="M58.6,13.4 L58.6,7.8 L59.6,7.8 L59.6,13.4 C59.6,13.4 58.6,13.4 58.6,13.4 Z" id="Shape" fill="#FFFFFF" fill-rule="nonzero"></path>\n            <polygon id="Shape" fill="#FFFFFF" fill-rule="nonzero" points="62.3 13.4 62.3 8.7 60.6 8.7 60.6 7.8 65 7.8 65 8.7 63.3 8.7 63.3 13.4"></polygon>\n            <path d="M68.2,10.6 C68.2,8.9 69.4,7.7 71.1,7.7 C72.8,7.7 74,8.9 74,10.6 C74,12.3 72.8,13.5 71.1,13.5 C69.4,13.5 68.2,12.2 68.2,10.6 Z M72.9,10.6 C72.9,9.4 72.2,8.6 71,8.6 C69.9,8.6 69.1,9.5 69.1,10.6 C69.1,11.8 69.8,12.6 71,12.6 C72.2,12.6 72.9,11.7 72.9,10.6 Z" id="Shape" fill="#FFFFFF" fill-rule="nonzero"></path>\n            <polygon id="Shape" fill="#FFFFFF" fill-rule="nonzero" points="79 13.4 76.1 9.4 76.1 13.4 75.1 13.4 75.1 7.8 76.1 7.8 79 11.7 79 7.8 80 7.8 80 13.4"></polygon>\n        </g>\n      </g>\n    </g>\n  </svg>\n';
    var close = '\n  <svg width="18px" height="18px" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    \x3c!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --\x3e\n    <title>close x</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="Log-In-Modal" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="Login-Modal-Button" transform="translate(-518.000000, -45.000000)" fill="#DFE1E3">\n            <g id="close-x" transform="translate(510.000000, 37.000000)">\n                <g transform="translate(17.207107, 16.792893) rotate(-45.000000) translate(-17.207107, -16.792893) translate(5.707107, 5.292893)" id="Rectangle-14">\n                    <rect transform="translate(11.500000, 11.500000) rotate(-90.000000) translate(-11.500000, -11.500000) " x="10" y="0" width="3" height="23" rx="1.5"></rect>\n                    <rect x="10" y="0" width="3" height="23" rx="1.5"></rect>\n                </g>\n            </g>\n        </g>\n    </g>\n  </svg>\n';
    var SVG = {
        logo,
        logowithBG,
        appleApp,
        androidApp,
        close
    };
    exports.default = SVG;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function matrix2path(matrix) {
        var N = matrix.length;
        var filled = [];
        for (var row = -1; row <= N; row++) {
            filled[row] = [];
        }
        var path = [];
        for (var row = 0; row < N; row++) {
            for (var col = 0; col < N; col++) {
                if (filled[row][col]) continue;
                filled[row][col] = 1;
                if (isDark(row, col)) {
                    if (!isDark(row - 1, col)) {
                        path.push(plot(row, col, "right"));
                    }
                } else {
                    if (isDark(row, col - 1)) {
                        path.push(plot(row, col, "down"));
                    }
                }
            }
        }
        return path;
        function isDark(row, col) {
            if (row < 0 || col < 0 || row >= N || col >= N) return false;
            return !!matrix[row][col];
        }
        function plot(row0, col0, dir) {
            filled[row0][col0] = 1;
            var res = [];
            res.push([ "M", col0, row0 ]);
            var row = row0;
            var col = col0;
            var len = 0;
            do {
                switch (dir) {
                  case "right":
                    filled[row][col] = 1;
                    if (isDark(row, col)) {
                        filled[row - 1][col] = 1;
                        if (isDark(row - 1, col)) {
                            res.push([ "h", len ]);
                            len = 0;
                            dir = "up";
                        } else {
                            len++;
                            col++;
                        }
                    } else {
                        res.push([ "h", len ]);
                        len = 0;
                        dir = "down";
                    }
                    break;

                  case "left":
                    filled[row - 1][col - 1] = 1;
                    if (isDark(row - 1, col - 1)) {
                        filled[row][col - 1] = 1;
                        if (isDark(row, col - 1)) {
                            res.push([ "h", -len ]);
                            len = 0;
                            dir = "down";
                        } else {
                            len++;
                            col--;
                        }
                    } else {
                        res.push([ "h", -len ]);
                        len = 0;
                        dir = "up";
                    }
                    break;

                  case "down":
                    filled[row][col - 1] = 1;
                    if (isDark(row, col - 1)) {
                        filled[row][col] = 1;
                        if (isDark(row, col)) {
                            res.push([ "v", len ]);
                            len = 0;
                            dir = "right";
                        } else {
                            len++;
                            row++;
                        }
                    } else {
                        res.push([ "v", len ]);
                        len = 0;
                        dir = "left";
                    }
                    break;

                  case "up":
                    filled[row - 1][col] = 1;
                    if (isDark(row - 1, col)) {
                        filled[row - 1][col - 1] = 1;
                        if (isDark(row - 1, col - 1)) {
                            res.push([ "v", -len ]);
                            len = 0;
                            dir = "left";
                        } else {
                            len++;
                            row--;
                        }
                    } else {
                        res.push([ "v", -len ]);
                        len = 0;
                        dir = "right";
                    }
                    break;
                }
            } while (row != row0 || col != col0);
            return res;
        }
    }
    function pushSVGPath(matrix, stream, margin) {
        matrix2path(matrix).forEach(function(subpath) {
            var res = "";
            for (var k = 0; k < subpath.length; k++) {
                var item = subpath[k];
                switch (item[0]) {
                  case "M":
                    res += "M" + (item[1] + margin) + " " + (item[2] + margin);
                    break;

                  default:
                    res += item.join("");
                }
            }
            res += "z";
            stream.push(res);
        });
    }
    function SVG_object(matrix, margin) {
        var stream = [];
        pushSVGPath(matrix, stream, margin);
        var result = {
            size: matrix.length + 2 * margin,
            path: stream.filter(Boolean).join("")
        };
        return result;
    }
    function SVG(matrix, stream, margin, size) {
        var X = matrix.length + 2 * margin;
        stream.push('<svg xmlns="http://www.w3.org/2000/svg" ');
        if (size > 0) {
            var XY = X * size;
            stream.push('width="' + XY + '" height="' + XY + '" ');
        }
        stream.push('viewBox="0 0 ' + X + " " + X + '">');
        stream.push('<path d="');
        pushSVGPath(matrix, stream, margin);
        stream.push('"/></svg>');
        stream.push(null);
    }
    function EPS(matrix, stream, margin) {
        var N = matrix.length;
        var scale = 9;
        var X = (N + 2 * margin) * scale;
        stream.push([ "%!PS-Adobe-3.0 EPSF-3.0", "%%BoundingBox: 0 0 " + X + " " + X, "/h { 0 rlineto } bind def", "/v { 0 exch neg rlineto } bind def", "/M { neg " + (N + margin) + " add moveto } bind def", "/z { closepath } bind def", scale + " " + scale + " scale", "" ].join("\n"));
        matrix2path(matrix).forEach(function(subpath) {
            var res = "";
            for (var k = 0; k < subpath.length; k++) {
                var item = subpath[k];
                switch (item[0]) {
                  case "M":
                    res += item[1] + margin + " " + item[2] + " M ";
                    break;

                  default:
                    res += item[1] + " " + item[0] + " ";
                }
            }
            res += "z\n";
            stream.push(res);
        });
        stream.push("fill\n%%EOF\n");
        stream.push(null);
    }
    function PDF(matrix, stream, margin) {
        var N = matrix.length;
        var scale = 9;
        var X = (N + 2 * margin) * scale;
        var data = [ "%PDF-1.0\n\n", "1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj\n", "2 0 obj << /Type /Pages /Count 1 /Kids [ 3 0 R ] >> endobj\n" ];
        data.push("3 0 obj << /Type /Page /Parent 2 0 R /Resources <<>> " + "/Contents 4 0 R /MediaBox [ 0 0 " + X + " " + X + " ] >> endobj\n");
        var path = scale + " 0 0 " + scale + " 0 0 cm\n";
        path += matrix2path(matrix).map(function(subpath) {
            var res = "";
            var x, y;
            for (var k = 0; k < subpath.length; k++) {
                var item = subpath[k];
                switch (item[0]) {
                  case "M":
                    x = item[1] + margin;
                    y = N - item[2] + margin;
                    res += x + " " + y + " m ";
                    break;

                  case "h":
                    x += item[1];
                    res += x + " " + y + " l ";
                    break;

                  case "v":
                    y -= item[1];
                    res += x + " " + y + " l ";
                    break;
                }
            }
            res += "h";
            return res;
        }).join("\n");
        path += "\nf\n";
        data.push("4 0 obj << /Length " + path.length + " >> stream\n" + path + "endstream\nendobj\n");
        var xref = "xref\n0 5\n0000000000 65535 f \n";
        for (var i = 1, l = data[0].length; i < 5; i++) {
            xref += ("0000000000" + l).substr(-10) + " 00000 n \n";
            l += data[i].length;
        }
        data.push(xref, "trailer << /Root 1 0 R /Size 5 >>\n", "startxref\n" + l + "\n%%EOF\n");
        stream.push(data.join(""));
        stream.push(null);
    }
    module.exports = {
        svg: SVG,
        eps: EPS,
        pdf: PDF,
        svg_object: SVG_object
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var crc_table = [];
        for (var n = 0; n < 256; n++) {
            var c = crc_table[n] = new Buffer(4);
            c.writeUInt32BE(n, 0);
            for (var k = 0; k < 8; k++) {
                var b0 = c[0] & 1;
                var b1 = c[1] & 1;
                var b2 = c[2] & 1;
                var b3 = c[3] & 1;
                c[0] = c[0] >> 1 ^ (b3 ? 237 : 0);
                c[1] = c[1] >> 1 ^ (b3 ? 184 : 0) ^ (b0 ? 128 : 0);
                c[2] = c[2] >> 1 ^ (b3 ? 131 : 0) ^ (b1 ? 128 : 0);
                c[3] = c[3] >> 1 ^ (b3 ? 32 : 0) ^ (b2 ? 128 : 0);
            }
        }
        function update(c, buf) {
            var l = buf.length;
            for (var n = 0; n < l; n++) {
                var e = crc_table[c[3] ^ buf[n]];
                c[3] = e[3] ^ c[2];
                c[2] = e[2] ^ c[1];
                c[1] = e[1] ^ c[0];
                c[0] = e[0];
            }
        }
        function crc32() {
            var l = arguments.length;
            var c = new Buffer(4);
            c.fill(255);
            for (var i = 0; i < l; i++) {
                update(c, new Buffer(arguments[i]));
            }
            c[0] = c[0] ^ 255;
            c[1] = c[1] ^ 255;
            c[2] = c[2] ^ 255;
            c[3] = c[3] ^ 255;
            return c.readUInt32BE(0);
        }
        module.exports = crc32;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(process, Buffer) {
        (function() {
            if (process.arch === "arm") {
                module.exports = __webpack_require__(186);
                return;
            }
            var crc_table = [];
            (function() {
                for (var n = 0; n < 256; n++) {
                    var c = n;
                    for (var k = 0; k < 8; k++) {
                        if (c & 1) {
                            c = 3988292384 ^ c >>> 1;
                        } else {
                            c = c >>> 1;
                        }
                    }
                    crc_table[n] = c >>> 0;
                }
            })();
            function update(c, buf) {
                var l = buf.length;
                for (var n = 0; n < l; n++) {
                    c = crc_table[(c ^ buf[n]) & 255] ^ c >>> 8;
                }
                return c;
            }
            function crc32() {
                var l = arguments.length;
                var c = -1;
                for (var i = 0; i < l; i++) {
                    c = update(c, new Buffer(arguments[i]));
                }
                c = (c ^ -1) >>> 0;
                return c;
            }
            module.exports = crc32;
        })();
    }).call(this, __webpack_require__(13), __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(48);
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
    var lext = [ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ];
    var dbase = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ];
    var dext = [ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0, max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
                break;
            }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
        }
        for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
                break;
            }
        }
        if (root < min) {
            root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
            return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }
        if (type === CODES) {
            base = extra = work;
            end = 19;
        } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
        } else {
            base = dbase;
            extra = dext;
            end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
        }
        for (;;) {
            here_bits = len - drop;
            if (work[sym] < end) {
                here_op = 0;
                here_val = work[sym];
            } else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]];
                here_val = base[base_index + work[sym]];
            } else {
                here_op = 32 + 64;
                here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
                if (len === max) {
                    break;
                }
                len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
                if (drop === 0) {
                    drop = root;
                }
                next += min;
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                    left -= count[curr + drop];
                    if (left <= 0) {
                        break;
                    }
                    curr++;
                    left <<= 1;
                }
                used += 1 << curr;
                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                    return 1;
                }
                low = huff & mask;
                table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
        }
        if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
            if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
            }
            here = lcode[hold & lmask];
            dolen: for (;;) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                    output[_out++] = here & 65535;
                } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        len += hold & (1 << op) - 1;
                        hold >>>= op;
                        bits -= op;
                    }
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist: for (;;) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                            dist = here & 65535;
                            op &= 15;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                            }
                            dist += hold & (1 << op) - 1;
                            if (dist > dmax) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break top;
                            }
                            hold >>>= op;
                            bits -= op;
                            op = _out - beg;
                            if (dist > op) {
                                op = dist - op;
                                if (op > whave) {
                                    if (state.sane) {
                                        strm.msg = "invalid distance too far back";
                                        state.mode = BAD;
                                        break top;
                                    }
                                }
                                from = 0;
                                from_source = s_window;
                                if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = 0;
                                        if (wnext < len) {
                                            op = wnext;
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist;
                                            from_source = output;
                                        }
                                    }
                                } else {
                                    from += wnext - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                                while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                }
                                if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                        output[_out++] = from_source[from++];
                                    }
                                }
                            } else {
                                from = _out - dist;
                                do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                } while (len > 2);
                                if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                        output[_out++] = output[from++];
                                    }
                                }
                            }
                        } else if ((op & 64) === 0) {
                            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dodist;
                        } else {
                            strm.msg = "invalid distance code";
                            state.mode = BAD;
                            break top;
                        }
                        break;
                    }
                } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                } else if (op & 32) {
                    state.mode = TYPE;
                    break top;
                } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break top;
                }
                break;
            }
        } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(48);
    var adler32 = __webpack_require__(98);
    var crc32 = __webpack_require__(97);
    var inflate_fast = __webpack_require__(190);
    var inflate_table = __webpack_require__(189);
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
    }
    function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
    }
    function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
            return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
            strm.state = null;
        }
        return ret;
    }
    function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix, distfix;
    function fixedtables(state) {
        if (virgin) {
            var sym;
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            sym = 0;
            while (sym < 144) {
                state.lens[sym++] = 8;
            }
            while (sym < 256) {
                state.lens[sym++] = 9;
            }
            while (sym < 280) {
                state.lens[sym++] = 7;
            }
            while (sym < 288) {
                state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                bits: 9
            });
            sym = 0;
            while (sym < 32) {
                state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5
            });
            virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new utils.Buf8(state.wsize);
        }
        if (copy >= state.wsize) {
            utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
        } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            utils.arraySet(state.window, src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
                utils.arraySet(state.window, src, end - copy, copy, 0);
                state.wnext = copy;
                state.whave = state.wsize;
            } else {
                state.wnext += dist;
                if (state.wnext === state.wsize) {
                    state.wnext = 0;
                }
                if (state.whave < state.wsize) {
                    state.whave += dist;
                }
            }
        }
        return 0;
    }
    function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
            state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave: for (;;) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                }
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                }
                state.flags = 0;
                if (state.head) {
                    state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                    state.wbits = len;
                } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;

              case FLAGS:
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                }
                if (state.head) {
                    state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;

              case TIME:
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.time = hold;
                }
                if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;

              case OS:
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;

              case EXLEN:
                if (state.flags & 1024) {
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                        state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state.head) {
                    state.head.extra = null;
                }
                state.mode = EXTRA;

              case EXTRA:
                if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy) {
                        if (state.head) {
                            len = state.head.extra_len - state.length;
                            if (!state.head.extra) {
                                state.head.extra = new Array(state.head.extra_len);
                            }
                            utils.arraySet(state.head.extra, input, next, copy, len);
                        }
                        if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        state.length -= copy;
                    }
                    if (state.length) {
                        break inf_leave;
                    }
                }
                state.length = 0;
                state.mode = NAME;

              case NAME:
                if (state.flags & 2048) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.name += String.fromCharCode(len);
                        }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;

              case COMMENT:
                if (state.flags & 4096) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.comment += String.fromCharCode(len);
                        }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.comment = null;
                }
                state.mode = HCRC;

              case HCRC:
                if (state.flags & 512) {
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                        strm.msg = "header crc mismatch";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;

              case DICTID:
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;

              case DICT:
                if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;

              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                }

              case TYPEDO:
                if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                }
                while (bits < 3) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;

                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                    }
                    break;

                  case 2:
                    state.mode = TABLE;
                    break;

                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;

              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }

              case COPY_:
                state.mode = COPY;

              case COPY:
                copy = state.length;
                if (copy) {
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy > left) {
                        copy = left;
                    }
                    if (copy === 0) {
                        break inf_leave;
                    }
                    utils.arraySet(output, input, next, copy, put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                }
                state.mode = TYPE;
                break;

              case TABLE:
                while (bits < 14) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = LENLENS;

              case LENLENS:
                while (state.have < state.ncode) {
                    while (bits < 3) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                }
                while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                    bits: state.lenbits
                };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = CODELENS;

              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                    for (;;) {
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n = here_bits + 2;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                            }
                            len = state.lens[state.have - 1];
                            copy = 3 + (hold & 3);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n = here_bits + 3;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 3 + (hold & 7);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n = here_bits + 7;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 11 + (hold & 127);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                            strm.msg = "invalid bit length repeat";
                            state.mode = BAD;
                            break;
                        }
                        while (copy--) {
                            state.lens[state.have++] = len;
                        }
                    }
                }
                if (state.mode === BAD) {
                    break;
                }
                if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                }
                state.lenbits = 9;
                opts = {
                    bits: state.lenbits
                };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                    bits: state.distbits
                };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }

              case LEN_:
                state.mode = LEN;

              case LEN:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                        state.back = -1;
                    }
                    break;
                }
                state.back = 0;
                for (;;) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (;;) {
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                    state.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;

              case LENEXT:
                if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;

              case DIST:
                for (;;) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (;;) {
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;

              case DISTEXT:
                if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                }
                state.mode = MATCH;

              case MATCH:
                if (left === 0) {
                    break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                        if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break;
                        }
                    }
                    if (copy > state.wnext) {
                        copy -= state.wnext;
                        from = state.wsize - copy;
                    } else {
                        from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                        copy = state.length;
                    }
                    from_source = state.window;
                } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                }
                if (copy > left) {
                    copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                    output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                    state.mode = LEN;
                }
                break;

              case LIT:
                if (left === 0) {
                    break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;

              case CHECK:
                if (state.wrap) {
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = LENGTH;

              case LENGTH:
                if (state.wrap && state.flags) {
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                        strm.msg = "incorrect length check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = DONE;

              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;

              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;

              case MEM:
                return Z_MEM_ERROR;

              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                state.mode = MEM;
                return Z_MEM_ERROR;
            }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    }
    function inflateEnd(strm) {
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK;
    }
    function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
                return Z_DATA_ERROR;
            }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(48);
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
            buf[len] = 0;
        }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];
    var extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
    var extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];
    var bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
    }
    function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
        }
    }
    function send_code(s, c, tree) {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
        var res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        } while (--len > 0);
        return res >>> 1;
    }
    function bi_flush(s) {
        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    }
    function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
                continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
        }
        if (overflow === 0) {
            return;
        }
        do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
                bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) {
                    continue;
                }
                if (tree[m * 2 + 1] !== bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    }
    function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
            var len = tree[n * 2 + 1];
            if (len === 0) {
                continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    }
    function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code;
            }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code;
            }
        }
        dist >>= 7;
        for (;code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                _dist_code[256 + dist++] = code;
            }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
        }
        while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
        }
        while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
            s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
            s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
            s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
            put_short(s, len);
            put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
    }
    function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
        }
        s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
            do {
                dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                lc = s.pending_buf[s.l_buf + lx];
                lx++;
                if (dist === 0) {
                    send_code(s, lc, ltree);
                } else {
                    code = _length_code[lc];
                    send_code(s, code + LITERALS + 1, ltree);
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                    }
                    dist--;
                    code = d_code(dist);
                    send_code(s, code, dtree);
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                    }
                }
            } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
                s.static_len -= stree[node * 2 + 1];
            }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
        }
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    s.bl_tree[curlen * 2]++;
                }
                s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]++;
            } else {
                s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(s, curlen, s.bl_tree);
                } while (--count !== 0);
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                break;
            }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                return Z_BINARY;
            }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
                return Z_TEXT;
            }
        }
        return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
            }
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
        } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
            bi_windup(s);
        }
    }
    function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
        } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(48);
    var trees = __webpack_require__(193);
    var adler32 = __webpack_require__(98);
    var crc32 = __webpack_require__(97);
    var msg = __webpack_require__(192);
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
    }
    function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
            buf[len] = 0;
        }
    }
    function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) {
            return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    }
    function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    }
    function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
            len = size;
        }
        if (len === 0) {
            return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
    }
    function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
        }
        do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
            }
            scan += 2;
            match++;
            do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
            }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    }
    function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                s.block_start -= _w_size;
                n = s.hash_size;
                p = n;
                do {
                    m = s.head[--p];
                    s.head[p] = m >= _w_size ? m - _w_size : 0;
                } while (--n);
                n = _w_size;
                p = n;
                do {
                    m = s.prev[--p];
                    s.prev[p] = m >= _w_size ? m - _w_size : 0;
                } while (--n);
                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                while (s.insert) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
        }
        for (;;) {
            if (s.lookahead <= 1) {
                fill_window(s);
                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            s.strstart += s.lookahead;
            s.lookahead = 0;
            var max_start = s.block_start + max_block_size;
            if (s.strstart === 0 || s.strstart >= max_start) {
                s.lookahead = s.strstart - max_start;
                s.strstart = max_start;
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                    s.match_length--;
                    do {
                        s.strstart++;
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    } while (--s.match_length !== 0);
                    s.strstart++;
                } else {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                }
            } else {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                    s.match_length = MIN_MATCH - 1;
                }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            } else if (s.match_available) {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                if (bflush) {
                    flush_block_only(s, false);
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (;;) {
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
        var bflush;
        for (;;) {
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    break;
                }
            }
            s.match_length = 0;
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    }
    var configuration_table;
    configuration_table = [ new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ];
    function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    }
    function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
            s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
    }
    function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
            lm_init(strm.state);
        }
        return ret;
    }
    function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
            return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
        }
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
            windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
    }
    function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
            if (s.wrap === 2) {
                strm.adler = 0;
                put_byte(s, 31);
                put_byte(s, 139);
                put_byte(s, 8);
                if (!s.gzhead) {
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                    put_byte(s, OS_CODE);
                    s.status = BUSY_STATE;
                } else {
                    put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                    put_byte(s, s.gzhead.time & 255);
                    put_byte(s, s.gzhead.time >> 8 & 255);
                    put_byte(s, s.gzhead.time >> 16 & 255);
                    put_byte(s, s.gzhead.time >> 24 & 255);
                    put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                    put_byte(s, s.gzhead.os & 255);
                    if (s.gzhead.extra && s.gzhead.extra.length) {
                        put_byte(s, s.gzhead.extra.length & 255);
                        put_byte(s, s.gzhead.extra.length >> 8 & 255);
                    }
                    if (s.gzhead.hcrc) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                    }
                    s.gzindex = 0;
                    s.status = EXTRA_STATE;
                }
            } else {
                var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                var level_flags = -1;
                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                    level_flags = 0;
                } else if (s.level < 6) {
                    level_flags = 1;
                } else if (s.level === 6) {
                    level_flags = 2;
                } else {
                    level_flags = 3;
                }
                header |= level_flags << 6;
                if (s.strstart !== 0) {
                    header |= PRESET_DICT;
                }
                header += 31 - header % 31;
                s.status = BUSY_STATE;
                putShortMSB(s, header);
                if (s.strstart !== 0) {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 65535);
                }
                strm.adler = 1;
            }
        }
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
                beg = s.pending;
                while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            break;
                        }
                    }
                    put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                    s.gzindex++;
                }
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (s.gzindex === s.gzhead.extra.length) {
                    s.gzindex = 0;
                    s.status = NAME_STATE;
                }
            } else {
                s.status = NAME_STATE;
            }
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
                beg = s.pending;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                        }
                    }
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                    s.gzindex = 0;
                    s.status = COMMENT_STATE;
                }
            } else {
                s.status = COMMENT_STATE;
            }
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
                beg = s.pending;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                        }
                    }
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                    s.status = HCRC_STATE;
                }
            } else {
                s.status = HCRC_STATE;
            }
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                }
                if (s.pending + 2 <= s.pending_buf_size) {
                    put_byte(s, strm.adler & 255);
                    put_byte(s, strm.adler >> 8 & 255);
                    strm.adler = 0;
                    s.status = BUSY_STATE;
                }
            } else {
                s.status = BUSY_STATE;
            }
        }
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
            }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
            var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                }
                return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    trees._tr_align(s);
                } else if (flush !== Z_BLOCK) {
                    trees._tr_stored_block(s, 0, 0, false);
                    if (flush === Z_FULL_FLUSH) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK;
                }
            }
        }
        if (flush !== Z_FINISH) {
            return Z_OK;
        }
        if (s.wrap <= 0) {
            return Z_STREAM_END;
        }
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
        } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
            s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
            if (wrap === 0) {
                zero(s.head);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
            }
            tmpDict = new utils.Buf8(s.w_size);
            utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
            str = s.strstart;
            n = s.lookahead - (MIN_MATCH - 1);
            do {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
}, function(module, exports, __webpack_require__) {
    "use strict";
    function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
    }
    module.exports = ZStream;
}, function(module, exports) {
    if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        };
    }
}, function(module, exports) {
    module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer, process) {
        var assert = __webpack_require__(100);
        var Zstream = __webpack_require__(195);
        var zlib_deflate = __webpack_require__(194);
        var zlib_inflate = __webpack_require__(191);
        var constants = __webpack_require__(188);
        for (var key in constants) {
            exports[key] = constants[key];
        }
        exports.NONE = 0;
        exports.DEFLATE = 1;
        exports.INFLATE = 2;
        exports.GZIP = 3;
        exports.GUNZIP = 4;
        exports.DEFLATERAW = 5;
        exports.INFLATERAW = 6;
        exports.UNZIP = 7;
        var GZIP_HEADER_ID1 = 31;
        var GZIP_HEADER_ID2 = 139;
        function Zlib(mode) {
            if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
                throw new TypeError("Bad argument");
            }
            this.dictionary = null;
            this.err = 0;
            this.flush = 0;
            this.init_done = false;
            this.level = 0;
            this.memLevel = 0;
            this.mode = mode;
            this.strategy = 0;
            this.windowBits = 0;
            this.write_in_progress = false;
            this.pending_close = false;
            this.gzip_id_bytes_read = 0;
        }
        Zlib.prototype.close = function() {
            if (this.write_in_progress) {
                this.pending_close = true;
                return;
            }
            this.pending_close = false;
            assert(this.init_done, "close before init");
            assert(this.mode <= exports.UNZIP);
            if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
                zlib_deflate.deflateEnd(this.strm);
            } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
                zlib_inflate.inflateEnd(this.strm);
            }
            this.mode = exports.NONE;
            this.dictionary = null;
        };
        Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
            return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
        };
        Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
            return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
        };
        Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
            assert.equal(arguments.length, 8);
            assert(this.init_done, "write before init");
            assert(this.mode !== exports.NONE, "already finalized");
            assert.equal(false, this.write_in_progress, "write already in progress");
            assert.equal(false, this.pending_close, "close is pending");
            this.write_in_progress = true;
            assert.equal(false, flush === undefined, "must provide flush value");
            this.write_in_progress = true;
            if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
                throw new Error("Invalid flush value");
            }
            if (input == null) {
                input = Buffer.alloc(0);
                in_len = 0;
                in_off = 0;
            }
            this.strm.avail_in = in_len;
            this.strm.input = input;
            this.strm.next_in = in_off;
            this.strm.avail_out = out_len;
            this.strm.output = out;
            this.strm.next_out = out_off;
            this.flush = flush;
            if (!async) {
                this._process();
                if (this._checkError()) {
                    return this._afterSync();
                }
                return;
            }
            var self = this;
            process.nextTick(function() {
                self._process();
                self._after();
            });
            return this;
        };
        Zlib.prototype._afterSync = function() {
            var avail_out = this.strm.avail_out;
            var avail_in = this.strm.avail_in;
            this.write_in_progress = false;
            return [ avail_in, avail_out ];
        };
        Zlib.prototype._process = function() {
            var next_expected_header_byte = null;
            switch (this.mode) {
              case exports.DEFLATE:
              case exports.GZIP:
              case exports.DEFLATERAW:
                this.err = zlib_deflate.deflate(this.strm, this.flush);
                break;

              case exports.UNZIP:
                if (this.strm.avail_in > 0) {
                    next_expected_header_byte = this.strm.next_in;
                }
                switch (this.gzip_id_bytes_read) {
                  case 0:
                    if (next_expected_header_byte === null) {
                        break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                        this.gzip_id_bytes_read = 1;
                        next_expected_header_byte++;
                        if (this.strm.avail_in === 1) {
                            break;
                        }
                    } else {
                        this.mode = exports.INFLATE;
                        break;
                    }

                  case 1:
                    if (next_expected_header_byte === null) {
                        break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                        this.gzip_id_bytes_read = 2;
                        this.mode = exports.GUNZIP;
                    } else {
                        this.mode = exports.INFLATE;
                    }
                    break;

                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }

              case exports.INFLATE:
              case exports.GUNZIP:
              case exports.INFLATERAW:
                this.err = zlib_inflate.inflate(this.strm, this.flush);
                if (this.err === exports.Z_NEED_DICT && this.dictionary) {
                    this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
                    if (this.err === exports.Z_OK) {
                        this.err = zlib_inflate.inflate(this.strm, this.flush);
                    } else if (this.err === exports.Z_DATA_ERROR) {
                        this.err = exports.Z_NEED_DICT;
                    }
                }
                while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
                    this.reset();
                    this.err = zlib_inflate.inflate(this.strm, this.flush);
                }
                break;

              default:
                throw new Error("Unknown mode " + this.mode);
            }
        };
        Zlib.prototype._checkError = function() {
            switch (this.err) {
              case exports.Z_OK:
              case exports.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
                    this._error("unexpected end of file");
                    return false;
                }
                break;

              case exports.Z_STREAM_END:
                break;

              case exports.Z_NEED_DICT:
                if (this.dictionary == null) {
                    this._error("Missing dictionary");
                } else {
                    this._error("Bad dictionary");
                }
                return false;

              default:
                this._error("Zlib error");
                return false;
            }
            return true;
        };
        Zlib.prototype._after = function() {
            if (!this._checkError()) {
                return;
            }
            var avail_out = this.strm.avail_out;
            var avail_in = this.strm.avail_in;
            this.write_in_progress = false;
            this.callback(avail_in, avail_out);
            if (this.pending_close) {
                this.close();
            }
        };
        Zlib.prototype._error = function(message) {
            if (this.strm.msg) {
                message = this.strm.msg;
            }
            this.onerror(message, this.err);
            this.write_in_progress = false;
            if (this.pending_close) {
                this.close();
            }
        };
        Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
            assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
            assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
            assert(level >= -1 && level <= 9, "invalid compression level");
            assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
            assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
            this._init(level, windowBits, memLevel, strategy, dictionary);
            this._setDictionary();
        };
        Zlib.prototype.params = function() {
            throw new Error("deflateParams Not supported");
        };
        Zlib.prototype.reset = function() {
            this._reset();
            this._setDictionary();
        };
        Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
            this.level = level;
            this.windowBits = windowBits;
            this.memLevel = memLevel;
            this.strategy = strategy;
            this.flush = exports.Z_NO_FLUSH;
            this.err = exports.Z_OK;
            if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
                this.windowBits += 16;
            }
            if (this.mode === exports.UNZIP) {
                this.windowBits += 32;
            }
            if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
                this.windowBits = -1 * this.windowBits;
            }
            this.strm = new Zstream();
            switch (this.mode) {
              case exports.DEFLATE:
              case exports.GZIP:
              case exports.DEFLATERAW:
                this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;

              case exports.INFLATE:
              case exports.GUNZIP:
              case exports.INFLATERAW:
              case exports.UNZIP:
                this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                break;

              default:
                throw new Error("Unknown mode " + this.mode);
            }
            if (this.err !== exports.Z_OK) {
                this._error("Init error");
            }
            this.dictionary = dictionary;
            this.write_in_progress = false;
            this.init_done = true;
        };
        Zlib.prototype._setDictionary = function() {
            if (this.dictionary == null) {
                return;
            }
            this.err = exports.Z_OK;
            switch (this.mode) {
              case exports.DEFLATE:
              case exports.DEFLATERAW:
                this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
                break;

              default:
                break;
            }
            if (this.err !== exports.Z_OK) {
                this._error("Failed to set dictionary");
            }
        };
        Zlib.prototype._reset = function() {
            this.err = exports.Z_OK;
            switch (this.mode) {
              case exports.DEFLATE:
              case exports.DEFLATERAW:
              case exports.GZIP:
                this.err = zlib_deflate.deflateReset(this.strm);
                break;

              case exports.INFLATE:
              case exports.INFLATERAW:
              case exports.GUNZIP:
                this.err = zlib_inflate.inflateReset(this.strm);
                break;

              default:
                break;
            }
            if (this.err !== exports.Z_OK) {
                this._error("Failed to reset stream");
            }
        };
        exports.Zlib = Zlib;
    }).call(this, __webpack_require__(4).Buffer, __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(process) {
        var Buffer = __webpack_require__(4).Buffer;
        var Transform = __webpack_require__(43).Transform;
        var binding = __webpack_require__(198);
        var util = __webpack_require__(99);
        var assert = __webpack_require__(100).ok;
        var kMaxLength = __webpack_require__(4).kMaxLength;
        var kRangeErrorMessage = "Cannot create final Buffer. It would be larger " + "than 0x" + kMaxLength.toString(16) + " bytes";
        binding.Z_MIN_WINDOWBITS = 8;
        binding.Z_MAX_WINDOWBITS = 15;
        binding.Z_DEFAULT_WINDOWBITS = 15;
        binding.Z_MIN_CHUNK = 64;
        binding.Z_MAX_CHUNK = Infinity;
        binding.Z_DEFAULT_CHUNK = 16 * 1024;
        binding.Z_MIN_MEMLEVEL = 1;
        binding.Z_MAX_MEMLEVEL = 9;
        binding.Z_DEFAULT_MEMLEVEL = 8;
        binding.Z_MIN_LEVEL = -1;
        binding.Z_MAX_LEVEL = 9;
        binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
        var bkeys = Object.keys(binding);
        for (var bk = 0; bk < bkeys.length; bk++) {
            var bkey = bkeys[bk];
            if (bkey.match(/^Z/)) {
                Object.defineProperty(exports, bkey, {
                    enumerable: true,
                    value: binding[bkey],
                    writable: false
                });
            }
        }
        var codes = {
            Z_OK: binding.Z_OK,
            Z_STREAM_END: binding.Z_STREAM_END,
            Z_NEED_DICT: binding.Z_NEED_DICT,
            Z_ERRNO: binding.Z_ERRNO,
            Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
            Z_DATA_ERROR: binding.Z_DATA_ERROR,
            Z_MEM_ERROR: binding.Z_MEM_ERROR,
            Z_BUF_ERROR: binding.Z_BUF_ERROR,
            Z_VERSION_ERROR: binding.Z_VERSION_ERROR
        };
        var ckeys = Object.keys(codes);
        for (var ck = 0; ck < ckeys.length; ck++) {
            var ckey = ckeys[ck];
            codes[codes[ckey]] = ckey;
        }
        Object.defineProperty(exports, "codes", {
            enumerable: true,
            value: Object.freeze(codes),
            writable: false
        });
        exports.Deflate = Deflate;
        exports.Inflate = Inflate;
        exports.Gzip = Gzip;
        exports.Gunzip = Gunzip;
        exports.DeflateRaw = DeflateRaw;
        exports.InflateRaw = InflateRaw;
        exports.Unzip = Unzip;
        exports.createDeflate = function(o) {
            return new Deflate(o);
        };
        exports.createInflate = function(o) {
            return new Inflate(o);
        };
        exports.createDeflateRaw = function(o) {
            return new DeflateRaw(o);
        };
        exports.createInflateRaw = function(o) {
            return new InflateRaw(o);
        };
        exports.createGzip = function(o) {
            return new Gzip(o);
        };
        exports.createGunzip = function(o) {
            return new Gunzip(o);
        };
        exports.createUnzip = function(o) {
            return new Unzip(o);
        };
        exports.deflate = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new Deflate(opts), buffer, callback);
        };
        exports.deflateSync = function(buffer, opts) {
            return zlibBufferSync(new Deflate(opts), buffer);
        };
        exports.gzip = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new Gzip(opts), buffer, callback);
        };
        exports.gzipSync = function(buffer, opts) {
            return zlibBufferSync(new Gzip(opts), buffer);
        };
        exports.deflateRaw = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new DeflateRaw(opts), buffer, callback);
        };
        exports.deflateRawSync = function(buffer, opts) {
            return zlibBufferSync(new DeflateRaw(opts), buffer);
        };
        exports.unzip = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new Unzip(opts), buffer, callback);
        };
        exports.unzipSync = function(buffer, opts) {
            return zlibBufferSync(new Unzip(opts), buffer);
        };
        exports.inflate = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new Inflate(opts), buffer, callback);
        };
        exports.inflateSync = function(buffer, opts) {
            return zlibBufferSync(new Inflate(opts), buffer);
        };
        exports.gunzip = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new Gunzip(opts), buffer, callback);
        };
        exports.gunzipSync = function(buffer, opts) {
            return zlibBufferSync(new Gunzip(opts), buffer);
        };
        exports.inflateRaw = function(buffer, opts, callback) {
            if (typeof opts === "function") {
                callback = opts;
                opts = {};
            }
            return zlibBuffer(new InflateRaw(opts), buffer, callback);
        };
        exports.inflateRawSync = function(buffer, opts) {
            return zlibBufferSync(new InflateRaw(opts), buffer);
        };
        function zlibBuffer(engine, buffer, callback) {
            var buffers = [];
            var nread = 0;
            engine.on("error", onError);
            engine.on("end", onEnd);
            engine.end(buffer);
            flow();
            function flow() {
                var chunk;
                while (null !== (chunk = engine.read())) {
                    buffers.push(chunk);
                    nread += chunk.length;
                }
                engine.once("readable", flow);
            }
            function onError(err) {
                engine.removeListener("end", onEnd);
                engine.removeListener("readable", flow);
                callback(err);
            }
            function onEnd() {
                var buf;
                var err = null;
                if (nread >= kMaxLength) {
                    err = new RangeError(kRangeErrorMessage);
                } else {
                    buf = Buffer.concat(buffers, nread);
                }
                buffers = [];
                engine.close();
                callback(err, buf);
            }
        }
        function zlibBufferSync(engine, buffer) {
            if (typeof buffer === "string") buffer = Buffer.from(buffer);
            if (!Buffer.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
            var flushFlag = engine._finishFlushFlag;
            return engine._processChunk(buffer, flushFlag);
        }
        function Deflate(opts) {
            if (!(this instanceof Deflate)) return new Deflate(opts);
            Zlib.call(this, opts, binding.DEFLATE);
        }
        function Inflate(opts) {
            if (!(this instanceof Inflate)) return new Inflate(opts);
            Zlib.call(this, opts, binding.INFLATE);
        }
        function Gzip(opts) {
            if (!(this instanceof Gzip)) return new Gzip(opts);
            Zlib.call(this, opts, binding.GZIP);
        }
        function Gunzip(opts) {
            if (!(this instanceof Gunzip)) return new Gunzip(opts);
            Zlib.call(this, opts, binding.GUNZIP);
        }
        function DeflateRaw(opts) {
            if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
            Zlib.call(this, opts, binding.DEFLATERAW);
        }
        function InflateRaw(opts) {
            if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
            Zlib.call(this, opts, binding.INFLATERAW);
        }
        function Unzip(opts) {
            if (!(this instanceof Unzip)) return new Unzip(opts);
            Zlib.call(this, opts, binding.UNZIP);
        }
        function isValidFlushFlag(flag) {
            return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
        }
        function Zlib(opts, mode) {
            var _this = this;
            this._opts = opts = opts || {};
            this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
            Transform.call(this, opts);
            if (opts.flush && !isValidFlushFlag(opts.flush)) {
                throw new Error("Invalid flush flag: " + opts.flush);
            }
            if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
                throw new Error("Invalid flush flag: " + opts.finishFlush);
            }
            this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
            this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
            if (opts.chunkSize) {
                if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
                    throw new Error("Invalid chunk size: " + opts.chunkSize);
                }
            }
            if (opts.windowBits) {
                if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
                    throw new Error("Invalid windowBits: " + opts.windowBits);
                }
            }
            if (opts.level) {
                if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
                    throw new Error("Invalid compression level: " + opts.level);
                }
            }
            if (opts.memLevel) {
                if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
                    throw new Error("Invalid memLevel: " + opts.memLevel);
                }
            }
            if (opts.strategy) {
                if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
                    throw new Error("Invalid strategy: " + opts.strategy);
                }
            }
            if (opts.dictionary) {
                if (!Buffer.isBuffer(opts.dictionary)) {
                    throw new Error("Invalid dictionary: it should be a Buffer instance");
                }
            }
            this._handle = new binding.Zlib(mode);
            var self = this;
            this._hadError = false;
            this._handle.onerror = function(message, errno) {
                _close(self);
                self._hadError = true;
                var error = new Error(message);
                error.errno = errno;
                error.code = exports.codes[errno];
                self.emit("error", error);
            };
            var level = exports.Z_DEFAULT_COMPRESSION;
            if (typeof opts.level === "number") level = opts.level;
            var strategy = exports.Z_DEFAULT_STRATEGY;
            if (typeof opts.strategy === "number") strategy = opts.strategy;
            this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
            this._buffer = Buffer.allocUnsafe(this._chunkSize);
            this._offset = 0;
            this._level = level;
            this._strategy = strategy;
            this.once("end", this.close);
            Object.defineProperty(this, "_closed", {
                get: function() {
                    return !_this._handle;
                },
                configurable: true,
                enumerable: true
            });
        }
        util.inherits(Zlib, Transform);
        Zlib.prototype.params = function(level, strategy, callback) {
            if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
                throw new RangeError("Invalid compression level: " + level);
            }
            if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
                throw new TypeError("Invalid strategy: " + strategy);
            }
            if (this._level !== level || this._strategy !== strategy) {
                var self = this;
                this.flush(binding.Z_SYNC_FLUSH, function() {
                    assert(self._handle, "zlib binding closed");
                    self._handle.params(level, strategy);
                    if (!self._hadError) {
                        self._level = level;
                        self._strategy = strategy;
                        if (callback) callback();
                    }
                });
            } else {
                process.nextTick(callback);
            }
        };
        Zlib.prototype.reset = function() {
            assert(this._handle, "zlib binding closed");
            return this._handle.reset();
        };
        Zlib.prototype._flush = function(callback) {
            this._transform(Buffer.alloc(0), "", callback);
        };
        Zlib.prototype.flush = function(kind, callback) {
            var _this2 = this;
            var ws = this._writableState;
            if (typeof kind === "function" || kind === undefined && !callback) {
                callback = kind;
                kind = binding.Z_FULL_FLUSH;
            }
            if (ws.ended) {
                if (callback) process.nextTick(callback);
            } else if (ws.ending) {
                if (callback) this.once("end", callback);
            } else if (ws.needDrain) {
                if (callback) {
                    this.once("drain", function() {
                        return _this2.flush(kind, callback);
                    });
                }
            } else {
                this._flushFlag = kind;
                this.write(Buffer.alloc(0), "", callback);
            }
        };
        Zlib.prototype.close = function(callback) {
            _close(this, callback);
            process.nextTick(emitCloseNT, this);
        };
        function _close(engine, callback) {
            if (callback) process.nextTick(callback);
            if (!engine._handle) return;
            engine._handle.close();
            engine._handle = null;
        }
        function emitCloseNT(self) {
            self.emit("close");
        }
        Zlib.prototype._transform = function(chunk, encoding, cb) {
            var flushFlag;
            var ws = this._writableState;
            var ending = ws.ending || ws.ended;
            var last = ending && (!chunk || ws.length === chunk.length);
            if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error("invalid input"));
            if (!this._handle) return cb(new Error("zlib binding closed"));
            if (last) flushFlag = this._finishFlushFlag; else {
                flushFlag = this._flushFlag;
                if (chunk.length >= ws.length) {
                    this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
                }
            }
            this._processChunk(chunk, flushFlag, cb);
        };
        Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
            var availInBefore = chunk && chunk.length;
            var availOutBefore = this._chunkSize - this._offset;
            var inOff = 0;
            var self = this;
            var async = typeof cb === "function";
            if (!async) {
                var buffers = [];
                var nread = 0;
                var error;
                this.on("error", function(er) {
                    error = er;
                });
                assert(this._handle, "zlib binding closed");
                do {
                    var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                } while (!this._hadError && callback(res[0], res[1]));
                if (this._hadError) {
                    throw error;
                }
                if (nread >= kMaxLength) {
                    _close(this);
                    throw new RangeError(kRangeErrorMessage);
                }
                var buf = Buffer.concat(buffers, nread);
                _close(this);
                return buf;
            }
            assert(this._handle, "zlib binding closed");
            var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
            req.buffer = chunk;
            req.callback = callback;
            function callback(availInAfter, availOutAfter) {
                if (this) {
                    this.buffer = null;
                    this.callback = null;
                }
                if (self._hadError) return;
                var have = availOutBefore - availOutAfter;
                assert(have >= 0, "have should not go down");
                if (have > 0) {
                    var out = self._buffer.slice(self._offset, self._offset + have);
                    self._offset += have;
                    if (async) {
                        self.push(out);
                    } else {
                        buffers.push(out);
                        nread += out.length;
                    }
                }
                if (availOutAfter === 0 || self._offset >= self._chunkSize) {
                    availOutBefore = self._chunkSize;
                    self._offset = 0;
                    self._buffer = Buffer.allocUnsafe(self._chunkSize);
                }
                if (availOutAfter === 0) {
                    inOff += availInBefore - availInAfter;
                    availInBefore = availInAfter;
                    if (!async) return true;
                    var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
                    newReq.callback = callback;
                    newReq.buffer = chunk;
                    return;
                }
                if (!async) return false;
                cb();
            }
        };
        util.inherits(Deflate, Zlib);
        util.inherits(Inflate, Zlib);
        util.inherits(Gzip, Zlib);
        util.inherits(Gunzip, Zlib);
        util.inherits(DeflateRaw, Zlib);
        util.inherits(InflateRaw, Zlib);
        util.inherits(Unzip, Zlib);
    }).call(this, __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var zlib = __webpack_require__(199);
        var crc32 = __webpack_require__(187);
        var PNG_HEAD = new Buffer([ 137, 80, 78, 71, 13, 10, 26, 10 ]);
        var PNG_IHDR = new Buffer([ 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0 ]);
        var PNG_IDAT = new Buffer([ 0, 0, 0, 0, 73, 68, 65, 84 ]);
        var PNG_IEND = new Buffer([ 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130 ]);
        function png(bitmap, stream) {
            stream.push(PNG_HEAD);
            var IHDR = Buffer.concat([ PNG_IHDR ]);
            IHDR.writeUInt32BE(bitmap.size, 8);
            IHDR.writeUInt32BE(bitmap.size, 12);
            IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);
            stream.push(IHDR);
            var IDAT = Buffer.concat([ PNG_IDAT, zlib.deflateSync(bitmap.data, {
                level: 9
            }), new Buffer(4) ]);
            IDAT.writeUInt32BE(IDAT.length - 12, 0);
            IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);
            stream.push(IDAT);
            stream.push(PNG_IEND);
            stream.push(null);
        }
        function bitmap(matrix, size, margin) {
            var N = matrix.length;
            var X = (N + 2 * margin) * size;
            var data = new Buffer((X + 1) * X);
            data.fill(255);
            for (var i = 0; i < X; i++) {
                data[i * (X + 1)] = 0;
            }
            for (var i = 0; i < N; i++) {
                for (var j = 0; j < N; j++) {
                    if (matrix[i][j]) {
                        var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;
                        data.fill(0, offset, offset + size);
                        for (var c = 1; c < size; c++) {
                            data.copy(data, offset + c * (X + 1), offset, offset + size);
                        }
                    }
                }
            }
            return {
                data,
                size: X
            };
        }
        module.exports = {
            bitmap,
            png
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        function init(version) {
            var N = version * 4 + 17;
            var matrix = [];
            var zeros = new Buffer(N);
            zeros.fill(0);
            zeros = [].slice.call(zeros);
            for (var i = 0; i < N; i++) {
                matrix[i] = zeros.slice();
            }
            return matrix;
        }
        function fillFinders(matrix) {
            var N = matrix.length;
            for (var i = -3; i <= 3; i++) {
                for (var j = -3; j <= 3; j++) {
                    var max = Math.max(i, j);
                    var min = Math.min(i, j);
                    var pixel = max == 2 && min >= -2 || min == -2 && max <= 2 ? 128 : 129;
                    matrix[3 + i][3 + j] = pixel;
                    matrix[3 + i][N - 4 + j] = pixel;
                    matrix[N - 4 + i][3 + j] = pixel;
                }
            }
            for (var i = 0; i < 8; i++) {
                matrix[7][i] = matrix[i][7] = matrix[7][N - i - 1] = matrix[i][N - 8] = matrix[N - 8][i] = matrix[N - 1 - i][7] = 128;
            }
        }
        function fillAlignAndTiming(matrix) {
            var N = matrix.length;
            if (N > 21) {
                var len = N - 13;
                var delta = Math.round(len / Math.ceil(len / 28));
                if (delta % 2) delta++;
                var res = [];
                for (var p = len + 6; p > 10; p -= delta) {
                    res.unshift(p);
                }
                res.unshift(6);
                for (var i = 0; i < res.length; i++) {
                    for (var j = 0; j < res.length; j++) {
                        var x = res[i], y = res[j];
                        if (matrix[x][y]) continue;
                        for (var r = -2; r <= 2; r++) {
                            for (var c = -2; c <= 2; c++) {
                                var max = Math.max(r, c);
                                var min = Math.min(r, c);
                                var pixel = max == 1 && min >= -1 || min == -1 && max <= 1 ? 128 : 129;
                                matrix[x + r][y + c] = pixel;
                            }
                        }
                    }
                }
            }
            for (var i = 8; i < N - 8; i++) {
                matrix[6][i] = matrix[i][6] = i % 2 ? 128 : 129;
            }
        }
        function fillStub(matrix) {
            var N = matrix.length;
            for (var i = 0; i < 8; i++) {
                if (i != 6) {
                    matrix[8][i] = matrix[i][8] = 128;
                }
                matrix[8][N - 1 - i] = 128;
                matrix[N - 1 - i][8] = 128;
            }
            matrix[8][8] = 128;
            matrix[N - 8][8] = 129;
            if (N < 45) return;
            for (var i = N - 11; i < N - 8; i++) {
                for (var j = 0; j < 6; j++) {
                    matrix[i][j] = matrix[j][i] = 128;
                }
            }
        }
        var fillReserved = function() {
            var FORMATS = Array(32);
            var VERSIONS = Array(40);
            var gf15 = 1335;
            var gf18 = 7973;
            var formats_mask = 21522;
            for (var format = 0; format < 32; format++) {
                var res = format << 10;
                for (var i = 5; i > 0; i--) {
                    if (res >>> 9 + i) {
                        res = res ^ gf15 << i - 1;
                    }
                }
                FORMATS[format] = (res | format << 10) ^ formats_mask;
            }
            for (var version = 7; version <= 40; version++) {
                var res = version << 12;
                for (var i = 6; i > 0; i--) {
                    if (res >>> 11 + i) {
                        res = res ^ gf18 << i - 1;
                    }
                }
                VERSIONS[version] = res | version << 12;
            }
            var EC_LEVELS = {
                L: 1,
                M: 0,
                Q: 3,
                H: 2
            };
            return function fillReserved(matrix, ec_level, mask) {
                var N = matrix.length;
                var format = FORMATS[EC_LEVELS[ec_level] << 3 | mask];
                function F(k) {
                    return format >> k & 1 ? 129 : 128;
                }
                for (var i = 0; i < 8; i++) {
                    matrix[8][N - 1 - i] = F(i);
                    if (i < 6) matrix[i][8] = F(i);
                }
                for (var i = 8; i < 15; i++) {
                    matrix[N - 15 + i][8] = F(i);
                    if (i > 8) matrix[8][14 - i] = F(i);
                }
                matrix[7][8] = F(6);
                matrix[8][8] = F(7);
                matrix[8][7] = F(8);
                var version = VERSIONS[(N - 17) / 4];
                if (!version) return;
                function V(k) {
                    return version >> k & 1 ? 129 : 128;
                }
                for (var i = 0; i < 6; i++) {
                    for (var j = 0; j < 3; j++) {
                        matrix[N - 11 + j][i] = matrix[i][N - 11 + j] = V(i * 3 + j);
                    }
                }
            };
        }();
        var fillData = function() {
            var MASK_FUNCTIONS = [ function(i, j) {
                return (i + j) % 2 == 0;
            }, function(i, j) {
                return i % 2 == 0;
            }, function(i, j) {
                return j % 3 == 0;
            }, function(i, j) {
                return (i + j) % 3 == 0;
            }, function(i, j) {
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
            }, function(i, j) {
                return i * j % 2 + i * j % 3 == 0;
            }, function(i, j) {
                return (i * j % 2 + i * j % 3) % 2 == 0;
            }, function(i, j) {
                return (i * j % 3 + (i + j) % 2) % 2 == 0;
            } ];
            return function fillData(matrix, data, mask) {
                var N = matrix.length;
                var row, col, dir = -1;
                row = col = N - 1;
                var mask_fn = MASK_FUNCTIONS[mask];
                var len = data.blocks[data.blocks.length - 1].length;
                for (var i = 0; i < len; i++) {
                    for (var b = 0; b < data.blocks.length; b++) {
                        if (data.blocks[b].length <= i) continue;
                        put(data.blocks[b][i]);
                    }
                }
                len = data.ec_len;
                for (var i = 0; i < len; i++) {
                    for (var b = 0; b < data.ec.length; b++) {
                        put(data.ec[b][i]);
                    }
                }
                if (col > -1) {
                    do {
                        matrix[row][col] = mask_fn(row, col) ? 1 : 0;
                    } while (next());
                }
                function put(byte) {
                    for (var mask = 128; mask; mask = mask >> 1) {
                        var pixel = !!(mask & byte);
                        if (mask_fn(row, col)) pixel = !pixel;
                        matrix[row][col] = pixel ? 1 : 0;
                        next();
                    }
                }
                function next() {
                    do {
                        if (col % 2 ^ col < 6) {
                            if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
                                col--;
                                dir = -dir;
                            } else {
                                col++;
                                row += dir;
                            }
                        } else {
                            col--;
                        }
                        if (col == 6) {
                            col--;
                        }
                        if (col < 0) {
                            return false;
                        }
                    } while (matrix[row][col] & 240);
                    return true;
                }
            };
        }();
        function calculatePenalty(matrix) {
            var N = matrix.length;
            var penalty = 0;
            for (var i = 0; i < N; i++) {
                var pixel = matrix[i][0] & 1;
                var len = 1;
                for (var j = 1; j < N; j++) {
                    var p = matrix[i][j] & 1;
                    if (p == pixel) {
                        len++;
                        continue;
                    }
                    if (len >= 5) {
                        penalty += len - 2;
                    }
                    pixel = p;
                    len = 1;
                }
                if (len >= 5) {
                    penalty += len - 2;
                }
            }
            for (var j = 0; j < N; j++) {
                var pixel = matrix[0][j] & 1;
                var len = 1;
                for (var i = 1; i < N; i++) {
                    var p = matrix[i][j] & 1;
                    if (p == pixel) {
                        len++;
                        continue;
                    }
                    if (len >= 5) {
                        penalty += len - 2;
                    }
                    pixel = p;
                    len = 1;
                }
                if (len >= 5) {
                    penalty += len - 2;
                }
            }
            for (var i = 0; i < N - 1; i++) {
                for (var j = 0; j < N - 1; j++) {
                    var s = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] & 7;
                    if (s == 0 || s == 4) {
                        penalty += 3;
                    }
                }
            }
            function I(k) {
                return matrix[i][j + k] & 1;
            }
            function J(k) {
                return matrix[i + k][j] & 1;
            }
            for (var i = 0; i < N; i++) {
                for (var j = 0; j < N; j++) {
                    if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
                        if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
                            penalty += 40;
                        }
                        if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
                            penalty += 40;
                        }
                    }
                    if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
                        if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
                            penalty += 40;
                        }
                        if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
                            penalty += 40;
                        }
                    }
                }
            }
            var numDark = 0;
            for (var i = 0; i < N; i++) {
                for (var j = 0; j < N; j++) {
                    if (matrix[i][j] & 1) numDark++;
                }
            }
            penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
            return penalty;
        }
        function getMatrix(data) {
            var matrix = init(data.version);
            fillFinders(matrix);
            fillAlignAndTiming(matrix);
            fillStub(matrix);
            var penalty = Infinity;
            var bestMask = 0;
            for (var mask = 0; mask < 8; mask++) {
                fillData(matrix, data, mask);
                fillReserved(matrix, data.ec_level, mask);
                var p = calculatePenalty(matrix);
                if (p < penalty) {
                    penalty = p;
                    bestMask = mask;
                }
            }
            fillData(matrix, data, bestMask);
            fillReserved(matrix, data.ec_level, bestMask);
            return matrix.map(function(row) {
                return row.map(function(cell) {
                    return cell & 1;
                });
            });
        }
        module.exports = {
            getMatrix,
            init,
            fillFinders,
            fillAlignAndTiming,
            fillStub,
            fillReserved,
            fillData,
            calculatePenalty
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var GF256_BASE = 285;
        var EXP_TABLE = [ 1 ];
        var LOG_TABLE = [];
        for (var i = 1; i < 256; i++) {
            var n = EXP_TABLE[i - 1] << 1;
            if (n > 255) n = n ^ GF256_BASE;
            EXP_TABLE[i] = n;
        }
        for (var i = 0; i < 255; i++) {
            LOG_TABLE[EXP_TABLE[i]] = i;
        }
        function exp(k) {
            while (k < 0) k += 255;
            while (k > 255) k -= 255;
            return EXP_TABLE[k];
        }
        function log(k) {
            if (k < 1 || k > 255) {
                throw Error("Bad log(" + k + ")");
            }
            return LOG_TABLE[k];
        }
        var POLYNOMIALS = [ [ 0 ], [ 0, 0 ], [ 0, 25, 1 ] ];
        function generatorPolynomial(num) {
            if (POLYNOMIALS[num]) {
                return POLYNOMIALS[num];
            }
            var prev = generatorPolynomial(num - 1);
            var res = [];
            res[0] = prev[0];
            for (var i = 1; i <= num; i++) {
                res[i] = log(exp(prev[i]) ^ exp(prev[i - 1] + num - 1));
            }
            POLYNOMIALS[num] = res;
            return res;
        }
        module.exports = function calculate_ec(msg, ec_len) {
            msg = [].slice.call(msg);
            var poly = generatorPolynomial(ec_len);
            for (var i = 0; i < ec_len; i++) msg.push(0);
            while (msg.length > ec_len) {
                if (!msg[0]) {
                    msg.shift();
                    continue;
                }
                var log_k = log(msg[0]);
                for (var i = 0; i <= ec_len; i++) {
                    msg[i] = msg[i] ^ exp(poly[i] + log_k);
                }
                msg.shift();
            }
            return new Buffer(msg);
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        function pushBits(arr, n, value) {
            for (var bit = 1 << n - 1; bit; bit = bit >>> 1) {
                arr.push(bit & value ? 1 : 0);
            }
        }
        function encode_8bit(data) {
            var len = data.length;
            var bits = [];
            for (var i = 0; i < len; i++) {
                pushBits(bits, 8, data[i]);
            }
            var res = {};
            var d = [ 0, 1, 0, 0 ];
            pushBits(d, 16, len);
            res.data10 = res.data27 = d.concat(bits);
            if (len < 256) {
                var d = [ 0, 1, 0, 0 ];
                pushBits(d, 8, len);
                res.data1 = d.concat(bits);
            }
            return res;
        }
        var ALPHANUM = function(s) {
            var res = {};
            for (var i = 0; i < s.length; i++) {
                res[s[i]] = i;
            }
            return res;
        }("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
        function encode_alphanum(str) {
            var len = str.length;
            var bits = [];
            for (var i = 0; i < len; i += 2) {
                var b = 6;
                var n = ALPHANUM[str[i]];
                if (str[i + 1]) {
                    b = 11;
                    n = n * 45 + ALPHANUM[str[i + 1]];
                }
                pushBits(bits, b, n);
            }
            var res = {};
            var d = [ 0, 0, 1, 0 ];
            pushBits(d, 13, len);
            res.data27 = d.concat(bits);
            if (len < 2048) {
                var d = [ 0, 0, 1, 0 ];
                pushBits(d, 11, len);
                res.data10 = d.concat(bits);
            }
            if (len < 512) {
                var d = [ 0, 0, 1, 0 ];
                pushBits(d, 9, len);
                res.data1 = d.concat(bits);
            }
            return res;
        }
        function encode_numeric(str) {
            var len = str.length;
            var bits = [];
            for (var i = 0; i < len; i += 3) {
                var s = str.substr(i, 3);
                var b = Math.ceil(s.length * 10 / 3);
                pushBits(bits, b, parseInt(s, 10));
            }
            var res = {};
            var d = [ 0, 0, 0, 1 ];
            pushBits(d, 14, len);
            res.data27 = d.concat(bits);
            if (len < 4096) {
                var d = [ 0, 0, 0, 1 ];
                pushBits(d, 12, len);
                res.data10 = d.concat(bits);
            }
            if (len < 1024) {
                var d = [ 0, 0, 0, 1 ];
                pushBits(d, 10, len);
                res.data1 = d.concat(bits);
            }
            return res;
        }
        function encode_url(str) {
            var slash = str.indexOf("/", 8) + 1 || str.length;
            var res = encode(str.slice(0, slash).toUpperCase(), false);
            if (slash >= str.length) {
                return res;
            }
            var path_res = encode(str.slice(slash), false);
            res.data27 = res.data27.concat(path_res.data27);
            if (res.data10 && path_res.data10) {
                res.data10 = res.data10.concat(path_res.data10);
            }
            if (res.data1 && path_res.data1) {
                res.data1 = res.data1.concat(path_res.data1);
            }
            return res;
        }
        function encode(data, parse_url) {
            var str;
            var t = typeof data;
            if (t == "string" || t == "number") {
                str = "" + data;
                data = new Buffer(str);
            } else if (Buffer.isBuffer(data)) {
                str = data.toString();
            } else if (Array.isArray(data)) {
                data = new Buffer(data);
                str = data.toString();
            } else {
                throw new Error("Bad data");
            }
            if (/^[0-9]+$/.test(str)) {
                if (data.length > 7089) {
                    throw new Error("Too much data");
                }
                return encode_numeric(str);
            }
            if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
                if (data.length > 4296) {
                    throw new Error("Too much data");
                }
                return encode_alphanum(str);
            }
            if (parse_url && /^https?:/i.test(str)) {
                return encode_url(str);
            }
            if (data.length > 2953) {
                throw new Error("Too much data");
            }
            return encode_8bit(data);
        }
        module.exports = encode;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var encode = __webpack_require__(203);
        var calculateEC = __webpack_require__(202);
        var matrix = __webpack_require__(201);
        function _deepCopy(obj) {
            return JSON.parse(JSON.stringify(obj));
        }
        var EC_LEVELS = [ "L", "M", "Q", "H" ];
        var versions = [ [], [ 26, 7, 1, 10, 1, 13, 1, 17, 1 ], [ 44, 10, 1, 16, 1, 22, 1, 28, 1 ], [ 70, 15, 1, 26, 1, 36, 2, 44, 2 ], [ 100, 20, 1, 36, 2, 52, 2, 64, 4 ], [ 134, 26, 1, 48, 2, 72, 4, 88, 4 ], [ 172, 36, 2, 64, 4, 96, 4, 112, 4 ], [ 196, 40, 2, 72, 4, 108, 6, 130, 5 ], [ 242, 48, 2, 88, 4, 132, 6, 156, 6 ], [ 292, 60, 2, 110, 5, 160, 8, 192, 8 ], [ 346, 72, 4, 130, 5, 192, 8, 224, 8 ], [ 404, 80, 4, 150, 5, 224, 8, 264, 11 ], [ 466, 96, 4, 176, 8, 260, 10, 308, 11 ], [ 532, 104, 4, 198, 9, 288, 12, 352, 16 ], [ 581, 120, 4, 216, 9, 320, 16, 384, 16 ], [ 655, 132, 6, 240, 10, 360, 12, 432, 18 ], [ 733, 144, 6, 280, 10, 408, 17, 480, 16 ], [ 815, 168, 6, 308, 11, 448, 16, 532, 19 ], [ 901, 180, 6, 338, 13, 504, 18, 588, 21 ], [ 991, 196, 7, 364, 14, 546, 21, 650, 25 ], [ 1085, 224, 8, 416, 16, 600, 20, 700, 25 ], [ 1156, 224, 8, 442, 17, 644, 23, 750, 25 ], [ 1258, 252, 9, 476, 17, 690, 23, 816, 34 ], [ 1364, 270, 9, 504, 18, 750, 25, 900, 30 ], [ 1474, 300, 10, 560, 20, 810, 27, 960, 32 ], [ 1588, 312, 12, 588, 21, 870, 29, 1050, 35 ], [ 1706, 336, 12, 644, 23, 952, 34, 1110, 37 ], [ 1828, 360, 12, 700, 25, 1020, 34, 1200, 40 ], [ 1921, 390, 13, 728, 26, 1050, 35, 1260, 42 ], [ 2051, 420, 14, 784, 28, 1140, 38, 1350, 45 ], [ 2185, 450, 15, 812, 29, 1200, 40, 1440, 48 ], [ 2323, 480, 16, 868, 31, 1290, 43, 1530, 51 ], [ 2465, 510, 17, 924, 33, 1350, 45, 1620, 54 ], [ 2611, 540, 18, 980, 35, 1440, 48, 1710, 57 ], [ 2761, 570, 19, 1036, 37, 1530, 51, 1800, 60 ], [ 2876, 570, 19, 1064, 38, 1590, 53, 1890, 63 ], [ 3034, 600, 20, 1120, 40, 1680, 56, 1980, 66 ], [ 3196, 630, 21, 1204, 43, 1770, 59, 2100, 70 ], [ 3362, 660, 22, 1260, 45, 1860, 62, 2220, 74 ], [ 3532, 720, 24, 1316, 47, 1950, 65, 2310, 77 ], [ 3706, 750, 25, 1372, 49, 2040, 68, 2430, 81 ] ];
        versions = versions.map(function(v, index) {
            if (!index) return {};
            var res = {};
            for (var i = 1; i < 8; i += 2) {
                var length = v[0] - v[i];
                var num_template = v[i + 1];
                var ec_level = EC_LEVELS[i / 2 | 0];
                var level = {
                    version: index,
                    ec_level,
                    data_len: length,
                    ec_len: v[i] / num_template,
                    blocks: [],
                    ec: []
                };
                for (var k = num_template, n = length; k > 0; k--) {
                    var block = n / k | 0;
                    level.blocks.push(block);
                    n -= block;
                }
                res[ec_level] = level;
            }
            return res;
        });
        function getTemplate(message, ec_level) {
            var i = 1;
            var len;
            if (message.data1) {
                len = Math.ceil(message.data1.length / 8);
            } else {
                i = 10;
            }
            for (;i < 10; i++) {
                var version = versions[i][ec_level];
                if (version.data_len >= len) {
                    return _deepCopy(version);
                }
            }
            if (message.data10) {
                len = Math.ceil(message.data10.length / 8);
            } else {
                i = 27;
            }
            for (;i < 27; i++) {
                var version = versions[i][ec_level];
                if (version.data_len >= len) {
                    return _deepCopy(version);
                }
            }
            len = Math.ceil(message.data27.length / 8);
            for (;i < 41; i++) {
                var version = versions[i][ec_level];
                if (version.data_len >= len) {
                    return _deepCopy(version);
                }
            }
            throw new Error("Too much data");
        }
        function fillTemplate(message, template) {
            var blocks = new Buffer(template.data_len);
            blocks.fill(0);
            if (template.version < 10) {
                message = message.data1;
            } else if (template.version < 27) {
                message = message.data10;
            } else {
                message = message.data27;
            }
            var len = message.length;
            for (var i = 0; i < len; i += 8) {
                var b = 0;
                for (var j = 0; j < 8; j++) {
                    b = b << 1 | (message[i + j] ? 1 : 0);
                }
                blocks[i / 8] = b;
            }
            var pad = 236;
            for (var i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
                blocks[i] = pad;
                pad = pad == 236 ? 17 : 236;
            }
            var offset = 0;
            template.blocks = template.blocks.map(function(n) {
                var b = blocks.slice(offset, offset + n);
                offset += n;
                template.ec.push(calculateEC(b, template.ec_len));
                return b;
            });
            return template;
        }
        function QR(text, ec_level, parse_url) {
            ec_level = EC_LEVELS.indexOf(ec_level) > -1 ? ec_level : "M";
            var message = encode(text, parse_url);
            var data = fillTemplate(message, getTemplate(message, ec_level));
            return matrix.getMatrix(data);
        }
        module.exports = {
            QR,
            getTemplate,
            fillTemplate
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(process, Buffer) {
        var Readable = __webpack_require__(43).Readable;
        var QR = __webpack_require__(204).QR;
        var png = __webpack_require__(200);
        var vector = __webpack_require__(185);
        var fn_noop = function() {};
        var BITMAP_OPTIONS = {
            parse_url: false,
            ec_level: "M",
            size: 5,
            margin: 4,
            customize: null
        };
        var VECTOR_OPTIONS = {
            parse_url: false,
            ec_level: "M",
            margin: 1,
            size: 0
        };
        function get_options(options, force_type) {
            if (typeof options === "string") {
                options = {
                    ec_level: options
                };
            } else {
                options = options || {};
            }
            var _options = {
                type: String(force_type || options.type || "png").toLowerCase()
            };
            var defaults = _options.type == "png" ? BITMAP_OPTIONS : VECTOR_OPTIONS;
            for (var k in defaults) {
                _options[k] = k in options ? options[k] : defaults[k];
            }
            return _options;
        }
        function qr_image(text, options) {
            options = get_options(options);
            var matrix = QR(text, options.ec_level, options.parse_url);
            var stream = new Readable();
            stream._read = fn_noop;
            switch (options.type) {
              case "svg":
              case "pdf":
              case "eps":
                process.nextTick(function() {
                    vector[options.type](matrix, stream, options.margin, options.size);
                });
                break;

              case "svgpath":
                process.nextTick(function() {
                    var obj = vector.svg_object(matrix, options.margin, options.size);
                    stream.push(obj.path);
                    stream.push(null);
                });
                break;

              case "png":
              default:
                process.nextTick(function() {
                    var bitmap = png.bitmap(matrix, options.size, options.margin);
                    if (options.customize) {
                        options.customize(bitmap);
                    }
                    png.png(bitmap, stream);
                });
            }
            return stream;
        }
        function qr_image_sync(text, options) {
            options = get_options(options);
            var matrix = QR(text, options.ec_level, options.parse_url);
            var stream = [];
            var result;
            switch (options.type) {
              case "svg":
              case "pdf":
              case "eps":
                vector[options.type](matrix, stream, options.margin, options.size);
                result = stream.filter(Boolean).join("");
                break;

              case "png":
              default:
                var bitmap = png.bitmap(matrix, options.size, options.margin);
                if (options.customize) {
                    options.customize(bitmap);
                }
                png.png(bitmap, stream);
                result = Buffer.concat(stream.filter(Boolean));
            }
            return result;
        }
        function svg_object(text, options) {
            options = get_options(options, "svg");
            var matrix = QR(text, options.ec_level);
            return vector.svg_object(matrix, options.margin);
        }
        module.exports = {
            matrix: QR,
            image: qr_image,
            imageSync: qr_image_sync,
            svgObject: svg_object
        };
    }).call(this, __webpack_require__(13), __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(11);
    var errors = __webpack_require__(31);
    var IpcProvider = function(path, net) {
        var _this = this;
        this.responseCallbacks = {};
        this.path = path;
        this.connection = net.connect({
            path: this.path
        });
        this.connection.on("error", function(e) {
            console.error("IPC Connection Error", e);
            _this._timeout();
        });
        this.connection.on("end", function() {
            _this._timeout();
        });
        this.connection.on("data", function(data) {
            _this._parseResponse(data.toString()).forEach(function(result) {
                var id = null;
                if (utils.isArray(result)) {
                    result.forEach(function(load) {
                        if (_this.responseCallbacks[load.id]) id = load.id;
                    });
                } else {
                    id = result.id;
                }
                if (_this.responseCallbacks[id]) {
                    _this.responseCallbacks[id](null, result);
                    delete _this.responseCallbacks[id];
                }
            });
        });
    };
    IpcProvider.prototype._parseResponse = function(data) {
        var _this = this, returnValues = [];
        var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
        dechunkedData.forEach(function(data) {
            if (_this.lastChunk) data = _this.lastChunk + data;
            var result = null;
            try {
                result = JSON.parse(data);
            } catch (e) {
                _this.lastChunk = data;
                clearTimeout(_this.lastChunkTimeout);
                _this.lastChunkTimeout = setTimeout(function() {
                    _this._timeout();
                    throw errors.InvalidResponse(data);
                }, 1e3 * 15);
                return;
            }
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunk = null;
            if (result) returnValues.push(result);
        });
        return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
        var id = payload.id || payload[0].id;
        var method = payload.method || payload[0].method;
        this.responseCallbacks[id] = callback;
        this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
        for (var key in this.responseCallbacks) {
            if (this.responseCallbacks.hasOwnProperty(key)) {
                this.responseCallbacks[key](errors.InvalidConnection("on IPC"));
                delete this.responseCallbacks[key];
            }
        }
    };
    IpcProvider.prototype.isConnected = function() {
        var _this = this;
        if (!_this.connection.writable) _this.connection.connect({
            path: _this.path
        });
        return !!this.connection.writable;
    };
    IpcProvider.prototype.send = function(payload) {
        if (this.connection.writeSync) {
            var result;
            if (!this.connection.writable) this.connection.connect({
                path: this.path
            });
            var data = this.connection.writeSync(JSON.stringify(payload));
            try {
                result = JSON.parse(data);
            } catch (e) {
                throw errors.InvalidResponse(data);
            }
            return result;
        } else {
            throw new Error('You tried to send "' + payload.method + '" synchronously. Synchronous requests are not supported by the IPC provider.');
        }
    };
    IpcProvider.prototype.sendAsync = function(payload, callback) {
        if (!this.connection.writable) this.connection.connect({
            path: this.path
        });
        this.connection.write(JSON.stringify(payload));
        this._addResponseCallback(payload, callback);
    };
    module.exports = IpcProvider;
}, function(module, exports, __webpack_require__) {
    var Jsonrpc = __webpack_require__(107);
    var errors = __webpack_require__(31);
    var Batch = function(web3) {
        this.requestManager = web3._requestManager;
        this.requests = [];
    };
    Batch.prototype.add = function(request) {
        this.requests.push(request);
    };
    Batch.prototype.execute = function() {
        var requests = this.requests;
        this.requestManager.sendBatch(requests, function(err, results) {
            results = results || [];
            requests.map(function(request, index) {
                return results[index] || {};
            }).forEach(function(result, index) {
                if (requests[index].callback) {
                    if (!Jsonrpc.isValidResponse(result)) {
                        return requests[index].callback(errors.InvalidResponse(result));
                    }
                    requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
                }
            });
        });
    };
    module.exports = Batch;
}, function(module, exports, __webpack_require__) {
    var formatters = __webpack_require__(22);
    var utils = __webpack_require__(11);
    var Method = __webpack_require__(25);
    var Property = __webpack_require__(27);
    var extend = function(web3) {
        var ex = function(extension) {
            var extendedObject;
            if (extension.property) {
                if (!web3[extension.property]) {
                    web3[extension.property] = {};
                }
                extendedObject = web3[extension.property];
            } else {
                extendedObject = web3;
            }
            if (extension.methods) {
                extension.methods.forEach(function(method) {
                    method.attachToObject(extendedObject);
                    method.setRequestManager(web3._requestManager);
                });
            }
            if (extension.properties) {
                extension.properties.forEach(function(property) {
                    property.attachToObject(extendedObject);
                    property.setRequestManager(web3._requestManager);
                });
            }
        };
        ex.formatters = formatters;
        ex.utils = utils;
        ex.Method = Method;
        ex.Property = Property;
        return ex;
    };
    module.exports = extend;
}, function(module) {
    module.exports = {
        version: "0.19.0"
    };
}, function(module, exports) {
    var Settings = function() {
        this.defaultBlock = "latest";
        this.defaultAccount = undefined;
    };
    module.exports = Settings;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Method = __webpack_require__(25);
    var Property = __webpack_require__(27);
    function Swarm(web3) {
        this._requestManager = web3._requestManager;
        var self = this;
        methods().forEach(function(method) {
            method.attachToObject(self);
            method.setRequestManager(self._requestManager);
        });
        properties().forEach(function(p) {
            p.attachToObject(self);
            p.setRequestManager(self._requestManager);
        });
    }
    var methods = function() {
        var blockNetworkRead = new Method({
            name: "blockNetworkRead",
            call: "bzz_blockNetworkRead",
            params: 1,
            inputFormatter: [ null ]
        });
        var syncEnabled = new Method({
            name: "syncEnabled",
            call: "bzz_syncEnabled",
            params: 1,
            inputFormatter: [ null ]
        });
        var swapEnabled = new Method({
            name: "swapEnabled",
            call: "bzz_swapEnabled",
            params: 1,
            inputFormatter: [ null ]
        });
        var download = new Method({
            name: "download",
            call: "bzz_download",
            params: 2,
            inputFormatter: [ null, null ]
        });
        var upload = new Method({
            name: "upload",
            call: "bzz_upload",
            params: 2,
            inputFormatter: [ null, null ]
        });
        var retrieve = new Method({
            name: "retrieve",
            call: "bzz_retrieve",
            params: 1,
            inputFormatter: [ null ]
        });
        var store = new Method({
            name: "store",
            call: "bzz_store",
            params: 2,
            inputFormatter: [ null, null ]
        });
        var get = new Method({
            name: "get",
            call: "bzz_get",
            params: 1,
            inputFormatter: [ null ]
        });
        var put = new Method({
            name: "put",
            call: "bzz_put",
            params: 2,
            inputFormatter: [ null, null ]
        });
        var modify = new Method({
            name: "modify",
            call: "bzz_modify",
            params: 4,
            inputFormatter: [ null, null, null, null ]
        });
        return [ blockNetworkRead, syncEnabled, swapEnabled, download, upload, retrieve, store, get, put, modify ];
    };
    var properties = function() {
        return [ new Property({
            name: "hive",
            getter: "bzz_hive"
        }), new Property({
            name: "info",
            getter: "bzz_info"
        }) ];
    };
    module.exports = Swarm;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Method = __webpack_require__(25);
    var Property = __webpack_require__(27);
    var formatters = __webpack_require__(22);
    function Personal(web3) {
        this._requestManager = web3._requestManager;
        var self = this;
        methods().forEach(function(method) {
            method.attachToObject(self);
            method.setRequestManager(self._requestManager);
        });
        properties().forEach(function(p) {
            p.attachToObject(self);
            p.setRequestManager(self._requestManager);
        });
    }
    var methods = function() {
        var newAccount = new Method({
            name: "newAccount",
            call: "personal_newAccount",
            params: 1,
            inputFormatter: [ null ]
        });
        var importRawKey = new Method({
            name: "importRawKey",
            call: "personal_importRawKey",
            params: 2
        });
        var sign = new Method({
            name: "sign",
            call: "personal_sign",
            params: 3,
            inputFormatter: [ null, formatters.inputAddressFormatter, null ]
        });
        var ecRecover = new Method({
            name: "ecRecover",
            call: "personal_ecRecover",
            params: 2
        });
        var unlockAccount = new Method({
            name: "unlockAccount",
            call: "personal_unlockAccount",
            params: 3,
            inputFormatter: [ formatters.inputAddressFormatter, null, null ]
        });
        var sendTransaction = new Method({
            name: "sendTransaction",
            call: "personal_sendTransaction",
            params: 2,
            inputFormatter: [ formatters.inputTransactionFormatter, null ]
        });
        var lockAccount = new Method({
            name: "lockAccount",
            call: "personal_lockAccount",
            params: 1,
            inputFormatter: [ formatters.inputAddressFormatter ]
        });
        return [ newAccount, importRawKey, unlockAccount, ecRecover, sign, sendTransaction, lockAccount ];
    };
    var properties = function() {
        return [ new Property({
            name: "listAccounts",
            getter: "personal_listAccounts"
        }) ];
    };
    module.exports = Personal;
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var Property = __webpack_require__(27);
    var Net = function(web3) {
        this._requestManager = web3._requestManager;
        var self = this;
        properties().forEach(function(p) {
            p.attachToObject(self);
            p.setRequestManager(web3._requestManager);
        });
    };
    var properties = function() {
        return [ new Property({
            name: "listening",
            getter: "net_listening"
        }), new Property({
            name: "peerCount",
            getter: "net_peerCount",
            outputFormatter: utils.toDecimal
        }) ];
    };
    module.exports = Net;
}, function(module, exports, __webpack_require__) {
    var Method = __webpack_require__(25);
    var formatters = __webpack_require__(22);
    var Filter = __webpack_require__(50);
    var watches = __webpack_require__(49);
    var Shh = function(web3) {
        this._requestManager = web3._requestManager;
        var self = this;
        methods().forEach(function(method) {
            method.attachToObject(self);
            method.setRequestManager(self._requestManager);
        });
    };
    Shh.prototype.filter = function(fil, callback) {
        return new Filter(this._requestManager, fil, watches.shh(), formatters.outputPostFormatter, callback);
    };
    var methods = function() {
        var post = new Method({
            name: "post",
            call: "shh_post",
            params: 1,
            inputFormatter: [ formatters.inputPostFormatter ]
        });
        var newIdentity = new Method({
            name: "newIdentity",
            call: "shh_newIdentity",
            params: 0
        });
        var hasIdentity = new Method({
            name: "hasIdentity",
            call: "shh_hasIdentity",
            params: 1
        });
        var newGroup = new Method({
            name: "newGroup",
            call: "shh_newGroup",
            params: 0
        });
        var addToGroup = new Method({
            name: "addToGroup",
            call: "shh_addToGroup",
            params: 0
        });
        return [ post, newIdentity, hasIdentity, newGroup, addToGroup ];
    };
    module.exports = Shh;
}, function(module, exports, __webpack_require__) {
    var Method = __webpack_require__(25);
    var DB = function(web3) {
        this._requestManager = web3._requestManager;
        var self = this;
        methods().forEach(function(method) {
            method.attachToObject(self);
            method.setRequestManager(web3._requestManager);
        });
    };
    var methods = function() {
        var putString = new Method({
            name: "putString",
            call: "db_putString",
            params: 3
        });
        var getString = new Method({
            name: "getString",
            call: "db_getString",
            params: 2
        });
        var putHex = new Method({
            name: "putHex",
            call: "db_putHex",
            params: 3
        });
        var getHex = new Method({
            name: "getHex",
            call: "db_getHex",
            params: 2
        });
        return [ putString, getString, putHex, getHex ];
    };
    module.exports = DB;
}, function(module) {
    module.exports = [ {
        constant: false,
        inputs: [ {
            name: "from",
            type: "bytes32"
        }, {
            name: "to",
            type: "address"
        }, {
            name: "value",
            type: "uint256"
        } ],
        name: "transfer",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "from",
            type: "bytes32"
        }, {
            name: "to",
            type: "address"
        }, {
            name: "indirectId",
            type: "bytes32"
        }, {
            name: "value",
            type: "uint256"
        } ],
        name: "icapTransfer",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "to",
            type: "bytes32"
        } ],
        name: "deposit",
        outputs: [],
        payable: true,
        type: "function"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "from",
            type: "address"
        }, {
            indexed: false,
            name: "value",
            type: "uint256"
        } ],
        name: "AnonymousDeposit",
        type: "event"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "from",
            type: "address"
        }, {
            indexed: true,
            name: "to",
            type: "bytes32"
        }, {
            indexed: false,
            name: "value",
            type: "uint256"
        } ],
        name: "Deposit",
        type: "event"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "from",
            type: "bytes32"
        }, {
            indexed: true,
            name: "to",
            type: "address"
        }, {
            indexed: false,
            name: "value",
            type: "uint256"
        } ],
        name: "Transfer",
        type: "event"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "from",
            type: "bytes32"
        }, {
            indexed: true,
            name: "to",
            type: "address"
        }, {
            indexed: false,
            name: "indirectId",
            type: "bytes32"
        }, {
            indexed: false,
            name: "value",
            type: "uint256"
        } ],
        name: "IcapTransfer",
        type: "event"
    } ];
}, function(module, exports, __webpack_require__) {
    var Iban = __webpack_require__(51);
    var exchangeAbi = __webpack_require__(216);
    var transfer = function(eth, from, to, value, callback) {
        var iban = new Iban(to);
        if (!iban.isValid()) {
            throw new Error("invalid iban address");
        }
        if (iban.isDirect()) {
            return transferToAddress(eth, from, iban.address(), value, callback);
        }
        if (!callback) {
            var address = eth.icapNamereg().addr(iban.institution());
            return deposit(eth, from, address, value, iban.client());
        }
        eth.icapNamereg().addr(iban.institution(), function(err, address) {
            return deposit(eth, from, address, value, iban.client(), callback);
        });
    };
    var transferToAddress = function(eth, from, to, value, callback) {
        return eth.sendTransaction({
            address: to,
            from,
            value
        }, callback);
    };
    var deposit = function(eth, from, to, value, client, callback) {
        var abi = exchangeAbi;
        return eth.contract(abi).at(to).deposit(client, {
            from,
            value
        }, callback);
    };
    module.exports = transfer;
}, function(module) {
    module.exports = [ {
        constant: true,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "owner",
        outputs: [ {
            name: "",
            type: "address"
        } ],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_refund",
            type: "address"
        } ],
        name: "disown",
        outputs: [],
        type: "function"
    }, {
        constant: true,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "addr",
        outputs: [ {
            name: "",
            type: "address"
        } ],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "reserve",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_newOwner",
            type: "address"
        } ],
        name: "transfer",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_a",
            type: "address"
        } ],
        name: "setAddr",
        outputs: [],
        type: "function"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "name",
            type: "bytes32"
        } ],
        name: "Changed",
        type: "event"
    } ];
}, function(module) {
    module.exports = [ {
        constant: true,
        inputs: [ {
            name: "_owner",
            type: "address"
        } ],
        name: "name",
        outputs: [ {
            name: "o_name",
            type: "bytes32"
        } ],
        type: "function"
    }, {
        constant: true,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "owner",
        outputs: [ {
            name: "",
            type: "address"
        } ],
        type: "function"
    }, {
        constant: true,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "content",
        outputs: [ {
            name: "",
            type: "bytes32"
        } ],
        type: "function"
    }, {
        constant: true,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "addr",
        outputs: [ {
            name: "",
            type: "address"
        } ],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "reserve",
        outputs: [],
        type: "function"
    }, {
        constant: true,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "subRegistrar",
        outputs: [ {
            name: "",
            type: "address"
        } ],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_newOwner",
            type: "address"
        } ],
        name: "transfer",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_registrar",
            type: "address"
        } ],
        name: "setSubRegistrar",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [],
        name: "Registrar",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_a",
            type: "address"
        }, {
            name: "_primary",
            type: "bool"
        } ],
        name: "setAddress",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        }, {
            name: "_content",
            type: "bytes32"
        } ],
        name: "setContent",
        outputs: [],
        type: "function"
    }, {
        constant: false,
        inputs: [ {
            name: "_name",
            type: "bytes32"
        } ],
        name: "disown",
        outputs: [],
        type: "function"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "_name",
            type: "bytes32"
        }, {
            indexed: false,
            name: "_winner",
            type: "address"
        } ],
        name: "AuctionEnded",
        type: "event"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "_name",
            type: "bytes32"
        }, {
            indexed: false,
            name: "_bidder",
            type: "address"
        }, {
            indexed: false,
            name: "_value",
            type: "uint256"
        } ],
        name: "NewBid",
        type: "event"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "name",
            type: "bytes32"
        } ],
        name: "Changed",
        type: "event"
    }, {
        anonymous: false,
        inputs: [ {
            indexed: true,
            name: "name",
            type: "bytes32"
        }, {
            indexed: true,
            name: "addr",
            type: "address"
        } ],
        name: "PrimaryChanged",
        type: "event"
    } ];
}, function(module, exports, __webpack_require__) {
    var globalRegistrarAbi = __webpack_require__(219);
    var icapRegistrarAbi = __webpack_require__(218);
    var globalNameregAddress = "0xc6d9d2cd449a754c494264e1809c50e34d64562b";
    var icapNameregAddress = "0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00";
    module.exports = {
        global: {
            abi: globalRegistrarAbi,
            address: globalNameregAddress
        },
        icap: {
            abi: icapRegistrarAbi,
            address: icapNameregAddress
        }
    };
}, function(module, exports, __webpack_require__) {
    var formatters = __webpack_require__(22);
    var utils = __webpack_require__(11);
    var count = 1;
    var pollSyncing = function(self) {
        var onMessage = function(error, sync) {
            if (error) {
                return self.callbacks.forEach(function(callback) {
                    callback(error);
                });
            }
            if (utils.isObject(sync) && sync.startingBlock) sync = formatters.outputSyncingFormatter(sync);
            self.callbacks.forEach(function(callback) {
                if (self.lastSyncState !== sync) {
                    if (!self.lastSyncState && utils.isObject(sync)) callback(null, true);
                    setTimeout(function() {
                        callback(null, sync);
                    }, 0);
                    self.lastSyncState = sync;
                }
            });
        };
        self.requestManager.startPolling({
            method: "eth_syncing",
            params: []
        }, self.pollId, onMessage, self.stopWatching.bind(self));
    };
    var IsSyncing = function(requestManager, callback) {
        this.requestManager = requestManager;
        this.pollId = "syncPoll_" + count++;
        this.callbacks = [];
        this.addCallback(callback);
        this.lastSyncState = false;
        pollSyncing(this);
        return this;
    };
    IsSyncing.prototype.addCallback = function(callback) {
        if (callback) this.callbacks.push(callback);
        return this;
    };
    IsSyncing.prototype.stopWatching = function() {
        this.requestManager.stopPolling(this.pollId);
        this.callbacks = [];
    };
    module.exports = IsSyncing;
}, function(module, exports, __webpack_require__) {
    var sha3 = __webpack_require__(37);
    var SolidityEvent = __webpack_require__(102);
    var formatters = __webpack_require__(22);
    var utils = __webpack_require__(11);
    var Filter = __webpack_require__(50);
    var watches = __webpack_require__(49);
    var AllSolidityEvents = function(requestManager, json, address) {
        this._requestManager = requestManager;
        this._json = json;
        this._address = address;
    };
    AllSolidityEvents.prototype.encode = function(options) {
        options = options || {};
        var result = {};
        [ "fromBlock", "toBlock" ].filter(function(f) {
            return options[f] !== undefined;
        }).forEach(function(f) {
            result[f] = formatters.inputBlockNumberFormatter(options[f]);
        });
        result.address = this._address;
        return result;
    };
    AllSolidityEvents.prototype.decode = function(data) {
        data.data = data.data || "";
        data.topics = data.topics || [];
        var eventTopic = data.topics[0].slice(2);
        var match = this._json.filter(function(j) {
            return eventTopic === sha3(utils.transformToFullName(j));
        })[0];
        if (!match) {
            console.warn("cannot find event for log");
            return data;
        }
        var event = new SolidityEvent(this._requestManager, match, this._address);
        return event.decode(data);
    };
    AllSolidityEvents.prototype.execute = function(options, callback) {
        if (utils.isFunction(arguments[arguments.length - 1])) {
            callback = arguments[arguments.length - 1];
            if (arguments.length === 1) options = null;
        }
        var o = this.encode(options);
        var formatter = this.decode.bind(this);
        return new Filter(this._requestManager, o, watches.eth(), formatter, callback);
    };
    AllSolidityEvents.prototype.attachToContract = function(contract) {
        var execute = this.execute.bind(this);
        contract.allEvents = execute;
    };
    module.exports = AllSolidityEvents;
}, function(module, exports, __webpack_require__) {
    var coder = __webpack_require__(66);
    var utils = __webpack_require__(11);
    var errors = __webpack_require__(31);
    var formatters = __webpack_require__(22);
    var sha3 = __webpack_require__(37);
    var SolidityFunction = function(eth, json, address) {
        this._eth = eth;
        this._inputTypes = json.inputs.map(function(i) {
            return i.type;
        });
        this._outputTypes = json.outputs.map(function(i) {
            return i.type;
        });
        this._constant = json.constant;
        this._payable = json.payable;
        this._name = utils.transformToFullName(json);
        this._address = address;
    };
    SolidityFunction.prototype.extractCallback = function(args) {
        if (utils.isFunction(args[args.length - 1])) {
            return args.pop();
        }
    };
    SolidityFunction.prototype.extractDefaultBlock = function(args) {
        if (args.length > this._inputTypes.length && !utils.isObject(args[args.length - 1])) {
            return formatters.inputDefaultBlockNumberFormatter(args.pop());
        }
    };
    SolidityFunction.prototype.validateArgs = function(args) {
        var inputArgs = args.filter(function(a) {
            return !(utils.isObject(a) === true && utils.isArray(a) === false);
        });
        if (inputArgs.length !== this._inputTypes.length) {
            throw errors.InvalidNumberOfSolidityArgs();
        }
    };
    SolidityFunction.prototype.toPayload = function(args) {
        var options = {};
        if (args.length > this._inputTypes.length && utils.isObject(args[args.length - 1])) {
            options = args[args.length - 1];
        }
        this.validateArgs(args);
        options.to = this._address;
        options.data = "0x" + this.signature() + coder.encodeParams(this._inputTypes, args);
        return options;
    };
    SolidityFunction.prototype.signature = function() {
        return sha3(this._name).slice(0, 8);
    };
    SolidityFunction.prototype.unpackOutput = function(output) {
        if (!output) {
            return;
        }
        output = output.length >= 2 ? output.slice(2) : output;
        var result = coder.decodeParams(this._outputTypes, output);
        return result.length === 1 ? result[0] : result;
    };
    SolidityFunction.prototype.call = function() {
        var args = Array.prototype.slice.call(arguments).filter(function(a) {
            return a !== undefined;
        });
        var callback = this.extractCallback(args);
        var defaultBlock = this.extractDefaultBlock(args);
        var payload = this.toPayload(args);
        if (!callback) {
            var output = this._eth.call(payload, defaultBlock);
            return this.unpackOutput(output);
        }
        var self = this;
        this._eth.call(payload, defaultBlock, function(error, output) {
            if (error) return callback(error, null);
            var unpacked = null;
            try {
                unpacked = self.unpackOutput(output);
            } catch (e) {
                error = e;
            }
            callback(error, unpacked);
        });
    };
    SolidityFunction.prototype.sendTransaction = function() {
        var args = Array.prototype.slice.call(arguments).filter(function(a) {
            return a !== undefined;
        });
        var callback = this.extractCallback(args);
        var payload = this.toPayload(args);
        if (payload.value > 0 && !this._payable) {
            throw new Error("Cannot send value to non-payable function");
        }
        if (!callback) {
            return this._eth.sendTransaction(payload);
        }
        this._eth.sendTransaction(payload, callback);
    };
    SolidityFunction.prototype.estimateGas = function() {
        var args = Array.prototype.slice.call(arguments);
        var callback = this.extractCallback(args);
        var payload = this.toPayload(args);
        if (!callback) {
            return this._eth.estimateGas(payload);
        }
        this._eth.estimateGas(payload, callback);
    };
    SolidityFunction.prototype.getData = function() {
        var args = Array.prototype.slice.call(arguments);
        var payload = this.toPayload(args);
        return payload.data;
    };
    SolidityFunction.prototype.displayName = function() {
        return utils.extractDisplayName(this._name);
    };
    SolidityFunction.prototype.typeName = function() {
        return utils.extractTypeName(this._name);
    };
    SolidityFunction.prototype.request = function() {
        var args = Array.prototype.slice.call(arguments);
        var callback = this.extractCallback(args);
        var payload = this.toPayload(args);
        var format = this.unpackOutput.bind(this);
        return {
            method: this._constant ? "eth_call" : "eth_sendTransaction",
            callback,
            params: [ payload ],
            format
        };
    };
    SolidityFunction.prototype.execute = function() {
        var transaction = !this._constant;
        if (transaction) {
            return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
        }
        return this.call.apply(this, Array.prototype.slice.call(arguments));
    };
    SolidityFunction.prototype.attachToContract = function(contract) {
        var execute = this.execute.bind(this);
        execute.request = this.request.bind(this);
        execute.call = this.call.bind(this);
        execute.sendTransaction = this.sendTransaction.bind(this);
        execute.estimateGas = this.estimateGas.bind(this);
        execute.getData = this.getData.bind(this);
        var displayName = this.displayName();
        if (!contract[displayName]) {
            contract[displayName] = execute;
        }
        contract[displayName][this.typeName()] = execute;
    };
    module.exports = SolidityFunction;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeBytes = function() {
        this._inputFormatter = f.formatInputBytes;
        this._outputFormatter = f.formatOutputBytes;
    };
    SolidityTypeBytes.prototype = new SolidityType({});
    SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;
    SolidityTypeBytes.prototype.isType = function(name) {
        return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeBytes;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeUReal = function() {
        this._inputFormatter = f.formatInputReal;
        this._outputFormatter = f.formatOutputUReal;
    };
    SolidityTypeUReal.prototype = new SolidityType({});
    SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;
    SolidityTypeUReal.prototype.isType = function(name) {
        return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeUReal;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeReal = function() {
        this._inputFormatter = f.formatInputReal;
        this._outputFormatter = f.formatOutputReal;
    };
    SolidityTypeReal.prototype = new SolidityType({});
    SolidityTypeReal.prototype.constructor = SolidityTypeReal;
    SolidityTypeReal.prototype.isType = function(name) {
        return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
    };
    module.exports = SolidityTypeReal;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeString = function() {
        this._inputFormatter = f.formatInputString;
        this._outputFormatter = f.formatOutputString;
    };
    SolidityTypeString.prototype = new SolidityType({});
    SolidityTypeString.prototype.constructor = SolidityTypeString;
    SolidityTypeString.prototype.isType = function(name) {
        return !!name.match(/^string(\[([0-9]*)\])*$/);
    };
    SolidityTypeString.prototype.isDynamicType = function() {
        return true;
    };
    module.exports = SolidityTypeString;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeDynamicBytes = function() {
        this._inputFormatter = f.formatInputDynamicBytes;
        this._outputFormatter = f.formatOutputDynamicBytes;
    };
    SolidityTypeDynamicBytes.prototype = new SolidityType({});
    SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;
    SolidityTypeDynamicBytes.prototype.isType = function(name) {
        return !!name.match(/^bytes(\[([0-9]*)\])*$/);
    };
    SolidityTypeDynamicBytes.prototype.isDynamicType = function() {
        return true;
    };
    module.exports = SolidityTypeDynamicBytes;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeUInt = function() {
        this._inputFormatter = f.formatInputInt;
        this._outputFormatter = f.formatOutputUInt;
    };
    SolidityTypeUInt.prototype = new SolidityType({});
    SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;
    SolidityTypeUInt.prototype.isType = function(name) {
        return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeUInt;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeInt = function() {
        this._inputFormatter = f.formatInputInt;
        this._outputFormatter = f.formatOutputInt;
    };
    SolidityTypeInt.prototype = new SolidityType({});
    SolidityTypeInt.prototype.constructor = SolidityTypeInt;
    SolidityTypeInt.prototype.isType = function(name) {
        return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeInt;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeBool = function() {
        this._inputFormatter = f.formatInputBool;
        this._outputFormatter = f.formatOutputBool;
    };
    SolidityTypeBool.prototype = new SolidityType({});
    SolidityTypeBool.prototype.constructor = SolidityTypeBool;
    SolidityTypeBool.prototype.isType = function(name) {
        return !!name.match(/^bool(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeBool;
}, function(module, exports, __webpack_require__) {
    var f = __webpack_require__(17);
    var SolidityType = __webpack_require__(21);
    var SolidityTypeAddress = function() {
        this._inputFormatter = f.formatInputInt;
        this._outputFormatter = f.formatOutputAddress;
    };
    SolidityTypeAddress.prototype = new SolidityType({});
    SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;
    SolidityTypeAddress.prototype.isType = function(name) {
        return !!name.match(/address(\[([0-9]*)\])?/);
    };
    module.exports = SolidityTypeAddress;
}, function(module, exports, __webpack_require__) {
    var utils = __webpack_require__(11);
    var coder = __webpack_require__(66);
    var SolidityEvent = __webpack_require__(102);
    var SolidityFunction = __webpack_require__(223);
    var AllEvents = __webpack_require__(222);
    var encodeConstructorParams = function(abi, params) {
        return abi.filter(function(json) {
            return json.type === "constructor" && json.inputs.length === params.length;
        }).map(function(json) {
            return json.inputs.map(function(input) {
                return input.type;
            });
        }).map(function(types) {
            return coder.encodeParams(types, params);
        })[0] || "";
    };
    var addFunctionsToContract = function(contract) {
        contract.abi.filter(function(json) {
            return json.type === "function";
        }).map(function(json) {
            return new SolidityFunction(contract._eth, json, contract.address);
        }).forEach(function(f) {
            f.attachToContract(contract);
        });
    };
    var addEventsToContract = function(contract) {
        var events = contract.abi.filter(function(json) {
            return json.type === "event";
        });
        var All = new AllEvents(contract._eth._requestManager, events, contract.address);
        All.attachToContract(contract);
        events.map(function(json) {
            return new SolidityEvent(contract._eth._requestManager, json, contract.address);
        }).forEach(function(e) {
            e.attachToContract(contract);
        });
    };
    var checkForContractAddress = function(contract, callback) {
        var count = 0, callbackFired = false;
        var filter = contract._eth.filter("latest", function(e) {
            if (!e && !callbackFired) {
                count++;
                if (count > 50) {
                    filter.stopWatching(function() {});
                    callbackFired = true;
                    if (callback) callback(new Error("Contract transaction couldn't be found after 50 blocks")); else throw new Error("Contract transaction couldn't be found after 50 blocks");
                } else {
                    contract._eth.getTransactionReceipt(contract.transactionHash, function(e, receipt) {
                        if (receipt && !callbackFired) {
                            contract._eth.getCode(receipt.contractAddress, function(e, code) {
                                if (callbackFired || !code) return;
                                filter.stopWatching(function() {});
                                callbackFired = true;
                                if (code.length > 3) {
                                    contract.address = receipt.contractAddress;
                                    addFunctionsToContract(contract);
                                    addEventsToContract(contract);
                                    if (callback) callback(null, contract);
                                } else {
                                    if (callback) callback(new Error("The contract code couldn't be stored, please check your gas amount.")); else throw new Error("The contract code couldn't be stored, please check your gas amount.");
                                }
                            });
                        }
                    });
                }
            }
        });
    };
    var ContractFactory = function(eth, abi) {
        this.eth = eth;
        this.abi = abi;
        this.new = function() {
            var contract = new Contract(this.eth, this.abi);
            var options = {};
            var callback;
            var args = Array.prototype.slice.call(arguments);
            if (utils.isFunction(args[args.length - 1])) {
                callback = args.pop();
            }
            var last = args[args.length - 1];
            if (utils.isObject(last) && !utils.isArray(last)) {
                options = args.pop();
            }
            if (options.value > 0) {
                var constructorAbi = abi.filter(function(json) {
                    return json.type === "constructor" && json.inputs.length === args.length;
                })[0] || {};
                if (!constructorAbi.payable) {
                    throw new Error("Cannot send value to non-payable constructor");
                }
            }
            var bytes = encodeConstructorParams(this.abi, args);
            options.data += bytes;
            if (callback) {
                this.eth.sendTransaction(options, function(err, hash) {
                    if (err) {
                        callback(err);
                    } else {
                        contract.transactionHash = hash;
                        callback(null, contract);
                        checkForContractAddress(contract, callback);
                    }
                });
            } else {
                var hash = this.eth.sendTransaction(options);
                contract.transactionHash = hash;
                checkForContractAddress(contract);
            }
            return contract;
        };
        this.new.getData = this.getData.bind(this);
    };
    ContractFactory.prototype.at = function(address, callback) {
        var contract = new Contract(this.eth, this.abi, address);
        addFunctionsToContract(contract);
        addEventsToContract(contract);
        if (callback) {
            callback(null, contract);
        }
        return contract;
    };
    ContractFactory.prototype.getData = function() {
        var options = {};
        var args = Array.prototype.slice.call(arguments);
        var last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }
        var bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;
        return options.data;
    };
    var Contract = function(eth, abi, address) {
        this._eth = eth;
        this.transactionHash = null;
        this.address = address;
        this.abi = abi;
    };
    module.exports = ContractFactory;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var formatters = __webpack_require__(22);
    var utils = __webpack_require__(11);
    var Method = __webpack_require__(25);
    var Property = __webpack_require__(27);
    var c = __webpack_require__(52);
    var Contract = __webpack_require__(233);
    var watches = __webpack_require__(49);
    var Filter = __webpack_require__(50);
    var IsSyncing = __webpack_require__(221);
    var namereg = __webpack_require__(220);
    var Iban = __webpack_require__(51);
    var transfer = __webpack_require__(217);
    var blockCall = function(args) {
        return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getBlockByHash" : "eth_getBlockByNumber";
    };
    var transactionFromBlockCall = function(args) {
        return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getTransactionByBlockHashAndIndex" : "eth_getTransactionByBlockNumberAndIndex";
    };
    var uncleCall = function(args) {
        return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getUncleByBlockHashAndIndex" : "eth_getUncleByBlockNumberAndIndex";
    };
    var getBlockTransactionCountCall = function(args) {
        return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getBlockTransactionCountByHash" : "eth_getBlockTransactionCountByNumber";
    };
    var uncleCountCall = function(args) {
        return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getUncleCountByBlockHash" : "eth_getUncleCountByBlockNumber";
    };
    function Eth(web3) {
        this._requestManager = web3._requestManager;
        var self = this;
        methods().forEach(function(method) {
            method.attachToObject(self);
            method.setRequestManager(self._requestManager);
        });
        properties().forEach(function(p) {
            p.attachToObject(self);
            p.setRequestManager(self._requestManager);
        });
        this.iban = Iban;
        this.sendIBANTransaction = transfer.bind(null, this);
    }
    Object.defineProperty(Eth.prototype, "defaultBlock", {
        get: function() {
            return c.defaultBlock;
        },
        set: function(val) {
            c.defaultBlock = val;
            return val;
        }
    });
    Object.defineProperty(Eth.prototype, "defaultAccount", {
        get: function() {
            return c.defaultAccount;
        },
        set: function(val) {
            c.defaultAccount = val;
            return val;
        }
    });
    var methods = function() {
        var getBalance = new Method({
            name: "getBalance",
            call: "eth_getBalance",
            params: 2,
            inputFormatter: [ formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter ],
            outputFormatter: formatters.outputBigNumberFormatter
        });
        var getStorageAt = new Method({
            name: "getStorageAt",
            call: "eth_getStorageAt",
            params: 3,
            inputFormatter: [ null, utils.toHex, formatters.inputDefaultBlockNumberFormatter ]
        });
        var getCode = new Method({
            name: "getCode",
            call: "eth_getCode",
            params: 2,
            inputFormatter: [ formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter ]
        });
        var getBlock = new Method({
            name: "getBlock",
            call: blockCall,
            params: 2,
            inputFormatter: [ formatters.inputBlockNumberFormatter, function(val) {
                return !!val;
            } ],
            outputFormatter: formatters.outputBlockFormatter
        });
        var getUncle = new Method({
            name: "getUncle",
            call: uncleCall,
            params: 2,
            inputFormatter: [ formatters.inputBlockNumberFormatter, utils.toHex ],
            outputFormatter: formatters.outputBlockFormatter
        });
        var getCompilers = new Method({
            name: "getCompilers",
            call: "eth_getCompilers",
            params: 0
        });
        var getBlockTransactionCount = new Method({
            name: "getBlockTransactionCount",
            call: getBlockTransactionCountCall,
            params: 1,
            inputFormatter: [ formatters.inputBlockNumberFormatter ],
            outputFormatter: utils.toDecimal
        });
        var getBlockUncleCount = new Method({
            name: "getBlockUncleCount",
            call: uncleCountCall,
            params: 1,
            inputFormatter: [ formatters.inputBlockNumberFormatter ],
            outputFormatter: utils.toDecimal
        });
        var getTransaction = new Method({
            name: "getTransaction",
            call: "eth_getTransactionByHash",
            params: 1,
            outputFormatter: formatters.outputTransactionFormatter
        });
        var getTransactionFromBlock = new Method({
            name: "getTransactionFromBlock",
            call: transactionFromBlockCall,
            params: 2,
            inputFormatter: [ formatters.inputBlockNumberFormatter, utils.toHex ],
            outputFormatter: formatters.outputTransactionFormatter
        });
        var getTransactionReceipt = new Method({
            name: "getTransactionReceipt",
            call: "eth_getTransactionReceipt",
            params: 1,
            outputFormatter: formatters.outputTransactionReceiptFormatter
        });
        var getTransactionCount = new Method({
            name: "getTransactionCount",
            call: "eth_getTransactionCount",
            params: 2,
            inputFormatter: [ null, formatters.inputDefaultBlockNumberFormatter ],
            outputFormatter: utils.toDecimal
        });
        var sendRawTransaction = new Method({
            name: "sendRawTransaction",
            call: "eth_sendRawTransaction",
            params: 1,
            inputFormatter: [ null ]
        });
        var sendTransaction = new Method({
            name: "sendTransaction",
            call: "eth_sendTransaction",
            params: 1,
            inputFormatter: [ formatters.inputTransactionFormatter ]
        });
        var signTransaction = new Method({
            name: "signTransaction",
            call: "eth_signTransaction",
            params: 1,
            inputFormatter: [ formatters.inputTransactionFormatter ]
        });
        var sign = new Method({
            name: "sign",
            call: "eth_sign",
            params: 2,
            inputFormatter: [ formatters.inputAddressFormatter, null ]
        });
        var call = new Method({
            name: "call",
            call: "eth_call",
            params: 2,
            inputFormatter: [ formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter ]
        });
        var estimateGas = new Method({
            name: "estimateGas",
            call: "eth_estimateGas",
            params: 1,
            inputFormatter: [ formatters.inputCallFormatter ],
            outputFormatter: utils.toDecimal
        });
        var compileSolidity = new Method({
            name: "compile.solidity",
            call: "eth_compileSolidity",
            params: 1
        });
        var compileLLL = new Method({
            name: "compile.lll",
            call: "eth_compileLLL",
            params: 1
        });
        var compileSerpent = new Method({
            name: "compile.serpent",
            call: "eth_compileSerpent",
            params: 1
        });
        var submitWork = new Method({
            name: "submitWork",
            call: "eth_submitWork",
            params: 3
        });
        var getWork = new Method({
            name: "getWork",
            call: "eth_getWork",
            params: 0
        });
        return [ getBalance, getStorageAt, getCode, getBlock, getUncle, getCompilers, getBlockTransactionCount, getBlockUncleCount, getTransaction, getTransactionFromBlock, getTransactionReceipt, getTransactionCount, call, estimateGas, sendRawTransaction, signTransaction, sendTransaction, sign, compileSolidity, compileLLL, compileSerpent, submitWork, getWork ];
    };
    var properties = function() {
        return [ new Property({
            name: "coinbase",
            getter: "eth_coinbase"
        }), new Property({
            name: "mining",
            getter: "eth_mining"
        }), new Property({
            name: "hashrate",
            getter: "eth_hashrate",
            outputFormatter: utils.toDecimal
        }), new Property({
            name: "syncing",
            getter: "eth_syncing",
            outputFormatter: formatters.outputSyncingFormatter
        }), new Property({
            name: "gasPrice",
            getter: "eth_gasPrice",
            outputFormatter: formatters.outputBigNumberFormatter
        }), new Property({
            name: "accounts",
            getter: "eth_accounts"
        }), new Property({
            name: "blockNumber",
            getter: "eth_blockNumber",
            outputFormatter: utils.toDecimal
        }), new Property({
            name: "protocolVersion",
            getter: "eth_protocolVersion"
        }) ];
    };
    Eth.prototype.contract = function(abi) {
        var factory = new Contract(this, abi);
        return factory;
    };
    Eth.prototype.filter = function(fil, callback, filterCreationErrorCallback) {
        return new Filter(this._requestManager, fil, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
    };
    Eth.prototype.namereg = function() {
        return this.contract(namereg.global.abi).at(namereg.global.address);
    };
    Eth.prototype.icapNamereg = function() {
        return this.contract(namereg.icap.abi).at(namereg.icap.address);
    };
    Eth.prototype.isSyncing = function(callback) {
        return new IsSyncing(this._requestManager, callback);
    };
    module.exports = Eth;
}, function(module, exports, __webpack_require__) {
    (function(module, global) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        (function(root) {
            var freeExports = typeof exports == "object" && exports;
            var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
            var freeGlobal = typeof global == "object" && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                root = freeGlobal;
            }
            var stringFromCharCode = String.fromCharCode;
            function ucs2decode(string) {
                var output = [];
                var counter = 0;
                var length = string.length;
                var value;
                var extra;
                while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                        extra = string.charCodeAt(counter++);
                        if ((extra & 64512) == 56320) {
                            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                        } else {
                            output.push(value);
                            counter--;
                        }
                    } else {
                        output.push(value);
                    }
                }
                return output;
            }
            function ucs2encode(array) {
                var length = array.length;
                var index = -1;
                var value;
                var output = "";
                while (++index < length) {
                    value = array[index];
                    if (value > 65535) {
                        value -= 65536;
                        output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                        value = 56320 | value & 1023;
                    }
                    output += stringFromCharCode(value);
                }
                return output;
            }
            function checkScalarValue(codePoint) {
                if (codePoint >= 55296 && codePoint <= 57343) {
                    throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
                }
            }
            function createByte(codePoint, shift) {
                return stringFromCharCode(codePoint >> shift & 63 | 128);
            }
            function encodeCodePoint(codePoint) {
                if ((codePoint & 4294967168) == 0) {
                    return stringFromCharCode(codePoint);
                }
                var symbol = "";
                if ((codePoint & 4294965248) == 0) {
                    symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
                } else if ((codePoint & 4294901760) == 0) {
                    checkScalarValue(codePoint);
                    symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
                    symbol += createByte(codePoint, 6);
                } else if ((codePoint & 4292870144) == 0) {
                    symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
                    symbol += createByte(codePoint, 12);
                    symbol += createByte(codePoint, 6);
                }
                symbol += stringFromCharCode(codePoint & 63 | 128);
                return symbol;
            }
            function utf8encode(string) {
                var codePoints = ucs2decode(string);
                var length = codePoints.length;
                var index = -1;
                var codePoint;
                var byteString = "";
                while (++index < length) {
                    codePoint = codePoints[index];
                    byteString += encodeCodePoint(codePoint);
                }
                return byteString;
            }
            function readContinuationByte() {
                if (byteIndex >= byteCount) {
                    throw Error("Invalid byte index");
                }
                var continuationByte = byteArray[byteIndex] & 255;
                byteIndex++;
                if ((continuationByte & 192) == 128) {
                    return continuationByte & 63;
                }
                throw Error("Invalid continuation byte");
            }
            function decodeSymbol() {
                var byte1;
                var byte2;
                var byte3;
                var byte4;
                var codePoint;
                if (byteIndex > byteCount) {
                    throw Error("Invalid byte index");
                }
                if (byteIndex == byteCount) {
                    return false;
                }
                byte1 = byteArray[byteIndex] & 255;
                byteIndex++;
                if ((byte1 & 128) == 0) {
                    return byte1;
                }
                if ((byte1 & 224) == 192) {
                    byte2 = readContinuationByte();
                    codePoint = (byte1 & 31) << 6 | byte2;
                    if (codePoint >= 128) {
                        return codePoint;
                    } else {
                        throw Error("Invalid continuation byte");
                    }
                }
                if ((byte1 & 240) == 224) {
                    byte2 = readContinuationByte();
                    byte3 = readContinuationByte();
                    codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
                    if (codePoint >= 2048) {
                        checkScalarValue(codePoint);
                        return codePoint;
                    } else {
                        throw Error("Invalid continuation byte");
                    }
                }
                if ((byte1 & 248) == 240) {
                    byte2 = readContinuationByte();
                    byte3 = readContinuationByte();
                    byte4 = readContinuationByte();
                    codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
                    if (codePoint >= 65536 && codePoint <= 1114111) {
                        return codePoint;
                    }
                }
                throw Error("Invalid UTF-8 detected");
            }
            var byteArray;
            var byteCount;
            var byteIndex;
            function utf8decode(byteString) {
                byteArray = ucs2decode(byteString);
                byteCount = byteArray.length;
                byteIndex = 0;
                var codePoints = [];
                var tmp;
                while ((tmp = decodeSymbol()) !== false) {
                    codePoints.push(tmp);
                }
                return ucs2encode(codePoints);
            }
            var utf8 = {
                version: "2.1.2",
                encode: utf8encode,
                decode: utf8decode
            };
            if (true) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return utf8;
                }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
                var key, hasOwnProperty, object;
            }
        })(this);
    }).call(this, __webpack_require__(46)(module), __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(30), __webpack_require__(29), __webpack_require__(28), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;
            var S = [];
            var C_ = [];
            var G = [];
            var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                _doReset: function() {
                    var K = this._key.words;
                    var iv = this.cfg.iv;
                    var X = this._X = [ K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16 ];
                    var C = this._C = [ K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535 ];
                    this._b = 0;
                    for (var i = 0; i < 4; i++) {
                        nextState.call(this);
                    }
                    for (var i = 0; i < 8; i++) {
                        C[i] ^= X[i + 4 & 7];
                    }
                    if (iv) {
                        var IV = iv.words;
                        var IV_0 = IV[0];
                        var IV_1 = IV[1];
                        var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                        var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                        var i1 = i0 >>> 16 | i2 & 4294901760;
                        var i3 = i2 << 16 | i0 & 65535;
                        C[0] ^= i0;
                        C[1] ^= i1;
                        C[2] ^= i2;
                        C[3] ^= i3;
                        C[4] ^= i0;
                        C[5] ^= i1;
                        C[6] ^= i2;
                        C[7] ^= i3;
                        for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                        }
                    }
                },
                _doProcessBlock: function(M, offset) {
                    var X = this._X;
                    nextState.call(this);
                    S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                    S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                    S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                    S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                    for (var i = 0; i < 4; i++) {
                        S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                        M[offset + i] ^= S[i];
                    }
                },
                blockSize: 128 / 32,
                ivSize: 64 / 32
            });
            function nextState() {
                var X = this._X;
                var C = this._C;
                for (var i = 0; i < 8; i++) {
                    C_[i] = C[i];
                }
                C[0] = C[0] + 1295307597 + this._b | 0;
                C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                for (var i = 0; i < 8; i++) {
                    var gx = X[i] + C[i];
                    var ga = gx & 65535;
                    var gb = gx >>> 16;
                    var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                    var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                    G[i] = gh ^ gl;
                }
                X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
            }
            C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        })();
        return CryptoJS.RabbitLegacy;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(30), __webpack_require__(29), __webpack_require__(28), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;
            var S = [];
            var C_ = [];
            var G = [];
            var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                _doReset: function() {
                    var K = this._key.words;
                    var iv = this.cfg.iv;
                    for (var i = 0; i < 4; i++) {
                        K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
                    }
                    var X = this._X = [ K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16 ];
                    var C = this._C = [ K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535 ];
                    this._b = 0;
                    for (var i = 0; i < 4; i++) {
                        nextState.call(this);
                    }
                    for (var i = 0; i < 8; i++) {
                        C[i] ^= X[i + 4 & 7];
                    }
                    if (iv) {
                        var IV = iv.words;
                        var IV_0 = IV[0];
                        var IV_1 = IV[1];
                        var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                        var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                        var i1 = i0 >>> 16 | i2 & 4294901760;
                        var i3 = i2 << 16 | i0 & 65535;
                        C[0] ^= i0;
                        C[1] ^= i1;
                        C[2] ^= i2;
                        C[3] ^= i3;
                        C[4] ^= i0;
                        C[5] ^= i1;
                        C[6] ^= i2;
                        C[7] ^= i3;
                        for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                        }
                    }
                },
                _doProcessBlock: function(M, offset) {
                    var X = this._X;
                    nextState.call(this);
                    S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                    S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                    S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                    S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                    for (var i = 0; i < 4; i++) {
                        S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                        M[offset + i] ^= S[i];
                    }
                },
                blockSize: 128 / 32,
                ivSize: 64 / 32
            });
            function nextState() {
                var X = this._X;
                var C = this._C;
                for (var i = 0; i < 8; i++) {
                    C_[i] = C[i];
                }
                C[0] = C[0] + 1295307597 + this._b | 0;
                C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                for (var i = 0; i < 8; i++) {
                    var gx = X[i] + C[i];
                    var ga = gx & 65535;
                    var gb = gx >>> 16;
                    var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                    var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                    G[i] = gh ^ gl;
                }
                X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
            }
            C.Rabbit = StreamCipher._createHelper(Rabbit);
        })();
        return CryptoJS.Rabbit;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(30), __webpack_require__(29), __webpack_require__(28), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;
            var RC4 = C_algo.RC4 = StreamCipher.extend({
                _doReset: function() {
                    var key = this._key;
                    var keyWords = key.words;
                    var keySigBytes = key.sigBytes;
                    var S = this._S = [];
                    for (var i = 0; i < 256; i++) {
                        S[i] = i;
                    }
                    for (var i = 0, j = 0; i < 256; i++) {
                        var keyByteIndex = i % keySigBytes;
                        var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                        j = (j + S[i] + keyByte) % 256;
                        var t = S[i];
                        S[i] = S[j];
                        S[j] = t;
                    }
                    this._i = this._j = 0;
                },
                _doProcessBlock: function(M, offset) {
                    M[offset] ^= generateKeystreamWord.call(this);
                },
                keySize: 256 / 32,
                ivSize: 0
            });
            function generateKeystreamWord() {
                var S = this._S;
                var i = this._i;
                var j = this._j;
                var keystreamWord = 0;
                for (var n = 0; n < 4; n++) {
                    i = (i + 1) % 256;
                    j = (j + S[i]) % 256;
                    var t = S[i];
                    S[i] = S[j];
                    S[j] = t;
                    keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
                }
                this._i = i;
                this._j = j;
                return keystreamWord;
            }
            C.RC4 = StreamCipher._createHelper(RC4);
            var RC4Drop = C_algo.RC4Drop = RC4.extend({
                cfg: RC4.cfg.extend({
                    drop: 192
                }),
                _doReset: function() {
                    RC4._doReset.call(this);
                    for (var i = this.cfg.drop; i > 0; i--) {
                        generateKeystreamWord.call(this);
                    }
                }
            });
            C.RC4Drop = StreamCipher._createHelper(RC4Drop);
        })();
        return CryptoJS.RC4;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(30), __webpack_require__(29), __webpack_require__(28), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;
            var PC1 = [ 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 ];
            var PC2 = [ 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 ];
            var BIT_SHIFTS = [ 1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28 ];
            var SBOX_P = [ {
                0: 8421888,
                268435456: 32768,
                536870912: 8421378,
                805306368: 2,
                1073741824: 512,
                1342177280: 8421890,
                1610612736: 8389122,
                1879048192: 8388608,
                2147483648: 514,
                2415919104: 8389120,
                2684354560: 33280,
                2952790016: 8421376,
                3221225472: 32770,
                3489660928: 8388610,
                3758096384: 0,
                4026531840: 33282,
                134217728: 0,
                402653184: 8421890,
                671088640: 33282,
                939524096: 32768,
                1207959552: 8421888,
                1476395008: 512,
                1744830464: 8421378,
                2013265920: 2,
                2281701376: 8389120,
                2550136832: 33280,
                2818572288: 8421376,
                3087007744: 8389122,
                3355443200: 8388610,
                3623878656: 32770,
                3892314112: 514,
                4160749568: 8388608,
                1: 32768,
                268435457: 2,
                536870913: 8421888,
                805306369: 8388608,
                1073741825: 8421378,
                1342177281: 33280,
                1610612737: 512,
                1879048193: 8389122,
                2147483649: 8421890,
                2415919105: 8421376,
                2684354561: 8388610,
                2952790017: 33282,
                3221225473: 514,
                3489660929: 8389120,
                3758096385: 32770,
                4026531841: 0,
                134217729: 8421890,
                402653185: 8421376,
                671088641: 8388608,
                939524097: 512,
                1207959553: 32768,
                1476395009: 8388610,
                1744830465: 2,
                2013265921: 33282,
                2281701377: 32770,
                2550136833: 8389122,
                2818572289: 514,
                3087007745: 8421888,
                3355443201: 8389120,
                3623878657: 0,
                3892314113: 33280,
                4160749569: 8421378
            }, {
                0: 1074282512,
                16777216: 16384,
                33554432: 524288,
                50331648: 1074266128,
                67108864: 1073741840,
                83886080: 1074282496,
                100663296: 1073758208,
                117440512: 16,
                134217728: 540672,
                150994944: 1073758224,
                167772160: 1073741824,
                184549376: 540688,
                201326592: 524304,
                218103808: 0,
                234881024: 16400,
                251658240: 1074266112,
                8388608: 1073758208,
                25165824: 540688,
                41943040: 16,
                58720256: 1073758224,
                75497472: 1074282512,
                92274688: 1073741824,
                109051904: 524288,
                125829120: 1074266128,
                142606336: 524304,
                159383552: 0,
                176160768: 16384,
                192937984: 1074266112,
                209715200: 1073741840,
                226492416: 540672,
                243269632: 1074282496,
                260046848: 16400,
                268435456: 0,
                285212672: 1074266128,
                301989888: 1073758224,
                318767104: 1074282496,
                335544320: 1074266112,
                352321536: 16,
                369098752: 540688,
                385875968: 16384,
                402653184: 16400,
                419430400: 524288,
                436207616: 524304,
                452984832: 1073741840,
                469762048: 540672,
                486539264: 1073758208,
                503316480: 1073741824,
                520093696: 1074282512,
                276824064: 540688,
                293601280: 524288,
                310378496: 1074266112,
                327155712: 16384,
                343932928: 1073758208,
                360710144: 1074282512,
                377487360: 16,
                394264576: 1073741824,
                411041792: 1074282496,
                427819008: 1073741840,
                444596224: 1073758224,
                461373440: 524304,
                478150656: 0,
                494927872: 16400,
                511705088: 1074266128,
                528482304: 540672
            }, {
                0: 260,
                1048576: 0,
                2097152: 67109120,
                3145728: 65796,
                4194304: 65540,
                5242880: 67108868,
                6291456: 67174660,
                7340032: 67174400,
                8388608: 67108864,
                9437184: 67174656,
                10485760: 65792,
                11534336: 67174404,
                12582912: 67109124,
                13631488: 65536,
                14680064: 4,
                15728640: 256,
                524288: 67174656,
                1572864: 67174404,
                2621440: 0,
                3670016: 67109120,
                4718592: 67108868,
                5767168: 65536,
                6815744: 65540,
                7864320: 260,
                8912896: 4,
                9961472: 256,
                11010048: 67174400,
                12058624: 65796,
                13107200: 65792,
                14155776: 67109124,
                15204352: 67174660,
                16252928: 67108864,
                16777216: 67174656,
                17825792: 65540,
                18874368: 65536,
                19922944: 67109120,
                20971520: 256,
                22020096: 67174660,
                23068672: 67108868,
                24117248: 0,
                25165824: 67109124,
                26214400: 67108864,
                27262976: 4,
                28311552: 65792,
                29360128: 67174400,
                30408704: 260,
                31457280: 65796,
                32505856: 67174404,
                17301504: 67108864,
                18350080: 260,
                19398656: 67174656,
                20447232: 0,
                21495808: 65540,
                22544384: 67109120,
                23592960: 256,
                24641536: 67174404,
                25690112: 65536,
                26738688: 67174660,
                27787264: 65796,
                28835840: 67108868,
                29884416: 67109124,
                30932992: 67174400,
                31981568: 4,
                33030144: 65792
            }, {
                0: 2151682048,
                65536: 2147487808,
                131072: 4198464,
                196608: 2151677952,
                262144: 0,
                327680: 4198400,
                393216: 2147483712,
                458752: 4194368,
                524288: 2147483648,
                589824: 4194304,
                655360: 64,
                720896: 2147487744,
                786432: 2151678016,
                851968: 4160,
                917504: 4096,
                983040: 2151682112,
                32768: 2147487808,
                98304: 64,
                163840: 2151678016,
                229376: 2147487744,
                294912: 4198400,
                360448: 2151682112,
                425984: 0,
                491520: 2151677952,
                557056: 4096,
                622592: 2151682048,
                688128: 4194304,
                753664: 4160,
                819200: 2147483648,
                884736: 4194368,
                950272: 4198464,
                1015808: 2147483712,
                1048576: 4194368,
                1114112: 4198400,
                1179648: 2147483712,
                1245184: 0,
                1310720: 4160,
                1376256: 2151678016,
                1441792: 2151682048,
                1507328: 2147487808,
                1572864: 2151682112,
                1638400: 2147483648,
                1703936: 2151677952,
                1769472: 4198464,
                1835008: 2147487744,
                1900544: 4194304,
                1966080: 64,
                2031616: 4096,
                1081344: 2151677952,
                1146880: 2151682112,
                1212416: 0,
                1277952: 4198400,
                1343488: 4194368,
                1409024: 2147483648,
                1474560: 2147487808,
                1540096: 64,
                1605632: 2147483712,
                1671168: 4096,
                1736704: 2147487744,
                1802240: 2151678016,
                1867776: 4160,
                1933312: 2151682048,
                1998848: 4194304,
                2064384: 4198464
            }, {
                0: 128,
                4096: 17039360,
                8192: 262144,
                12288: 536870912,
                16384: 537133184,
                20480: 16777344,
                24576: 553648256,
                28672: 262272,
                32768: 16777216,
                36864: 537133056,
                40960: 536871040,
                45056: 553910400,
                49152: 553910272,
                53248: 0,
                57344: 17039488,
                61440: 553648128,
                2048: 17039488,
                6144: 553648256,
                10240: 128,
                14336: 17039360,
                18432: 262144,
                22528: 537133184,
                26624: 553910272,
                30720: 536870912,
                34816: 537133056,
                38912: 0,
                43008: 553910400,
                47104: 16777344,
                51200: 536871040,
                55296: 553648128,
                59392: 16777216,
                63488: 262272,
                65536: 262144,
                69632: 128,
                73728: 536870912,
                77824: 553648256,
                81920: 16777344,
                86016: 553910272,
                90112: 537133184,
                94208: 16777216,
                98304: 553910400,
                102400: 553648128,
                106496: 17039360,
                110592: 537133056,
                114688: 262272,
                118784: 536871040,
                122880: 0,
                126976: 17039488,
                67584: 553648256,
                71680: 16777216,
                75776: 17039360,
                79872: 537133184,
                83968: 536870912,
                88064: 17039488,
                92160: 128,
                96256: 553910272,
                100352: 262272,
                104448: 553910400,
                108544: 0,
                112640: 553648128,
                116736: 16777344,
                120832: 262144,
                124928: 537133056,
                129024: 536871040
            }, {
                0: 268435464,
                256: 8192,
                512: 270532608,
                768: 270540808,
                1024: 268443648,
                1280: 2097152,
                1536: 2097160,
                1792: 268435456,
                2048: 0,
                2304: 268443656,
                2560: 2105344,
                2816: 8,
                3072: 270532616,
                3328: 2105352,
                3584: 8200,
                3840: 270540800,
                128: 270532608,
                384: 270540808,
                640: 8,
                896: 2097152,
                1152: 2105352,
                1408: 268435464,
                1664: 268443648,
                1920: 8200,
                2176: 2097160,
                2432: 8192,
                2688: 268443656,
                2944: 270532616,
                3200: 0,
                3456: 270540800,
                3712: 2105344,
                3968: 268435456,
                4096: 268443648,
                4352: 270532616,
                4608: 270540808,
                4864: 8200,
                5120: 2097152,
                5376: 268435456,
                5632: 268435464,
                5888: 2105344,
                6144: 2105352,
                6400: 0,
                6656: 8,
                6912: 270532608,
                7168: 8192,
                7424: 268443656,
                7680: 270540800,
                7936: 2097160,
                4224: 8,
                4480: 2105344,
                4736: 2097152,
                4992: 268435464,
                5248: 268443648,
                5504: 8200,
                5760: 270540808,
                6016: 270532608,
                6272: 270540800,
                6528: 270532616,
                6784: 8192,
                7040: 2105352,
                7296: 2097160,
                7552: 0,
                7808: 268435456,
                8064: 268443656
            }, {
                0: 1048576,
                16: 33555457,
                32: 1024,
                48: 1049601,
                64: 34604033,
                80: 0,
                96: 1,
                112: 34603009,
                128: 33555456,
                144: 1048577,
                160: 33554433,
                176: 34604032,
                192: 34603008,
                208: 1025,
                224: 1049600,
                240: 33554432,
                8: 34603009,
                24: 0,
                40: 33555457,
                56: 34604032,
                72: 1048576,
                88: 33554433,
                104: 33554432,
                120: 1025,
                136: 1049601,
                152: 33555456,
                168: 34603008,
                184: 1048577,
                200: 1024,
                216: 34604033,
                232: 1,
                248: 1049600,
                256: 33554432,
                272: 1048576,
                288: 33555457,
                304: 34603009,
                320: 1048577,
                336: 33555456,
                352: 34604032,
                368: 1049601,
                384: 1025,
                400: 34604033,
                416: 1049600,
                432: 1,
                448: 0,
                464: 34603008,
                480: 33554433,
                496: 1024,
                264: 1049600,
                280: 33555457,
                296: 34603009,
                312: 1,
                328: 33554432,
                344: 1048576,
                360: 1025,
                376: 34604032,
                392: 33554433,
                408: 34603008,
                424: 0,
                440: 34604033,
                456: 1049601,
                472: 1024,
                488: 33555456,
                504: 1048577
            }, {
                0: 134219808,
                1: 131072,
                2: 134217728,
                3: 32,
                4: 131104,
                5: 134350880,
                6: 134350848,
                7: 2048,
                8: 134348800,
                9: 134219776,
                10: 133120,
                11: 134348832,
                12: 2080,
                13: 0,
                14: 134217760,
                15: 133152,
                2147483648: 2048,
                2147483649: 134350880,
                2147483650: 134219808,
                2147483651: 134217728,
                2147483652: 134348800,
                2147483653: 133120,
                2147483654: 133152,
                2147483655: 32,
                2147483656: 134217760,
                2147483657: 2080,
                2147483658: 131104,
                2147483659: 134350848,
                2147483660: 0,
                2147483661: 134348832,
                2147483662: 134219776,
                2147483663: 131072,
                16: 133152,
                17: 134350848,
                18: 32,
                19: 2048,
                20: 134219776,
                21: 134217760,
                22: 134348832,
                23: 131072,
                24: 0,
                25: 131104,
                26: 134348800,
                27: 134219808,
                28: 134350880,
                29: 133120,
                30: 2080,
                31: 134217728,
                2147483664: 131072,
                2147483665: 2048,
                2147483666: 134348832,
                2147483667: 133152,
                2147483668: 32,
                2147483669: 134348800,
                2147483670: 134217728,
                2147483671: 134219808,
                2147483672: 134350880,
                2147483673: 134217760,
                2147483674: 134219776,
                2147483675: 0,
                2147483676: 133120,
                2147483677: 2080,
                2147483678: 131104,
                2147483679: 134350848
            } ];
            var SBOX_MASK = [ 4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679 ];
            var DES = C_algo.DES = BlockCipher.extend({
                _doReset: function() {
                    var key = this._key;
                    var keyWords = key.words;
                    var keyBits = [];
                    for (var i = 0; i < 56; i++) {
                        var keyBitPos = PC1[i] - 1;
                        keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                    }
                    var subKeys = this._subKeys = [];
                    for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                        var subKey = subKeys[nSubKey] = [];
                        var bitShift = BIT_SHIFTS[nSubKey];
                        for (var i = 0; i < 24; i++) {
                            subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                            subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                        }
                        subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                        for (var i = 1; i < 7; i++) {
                            subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                        }
                        subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                    }
                    var invSubKeys = this._invSubKeys = [];
                    for (var i = 0; i < 16; i++) {
                        invSubKeys[i] = subKeys[15 - i];
                    }
                },
                encryptBlock: function(M, offset) {
                    this._doCryptBlock(M, offset, this._subKeys);
                },
                decryptBlock: function(M, offset) {
                    this._doCryptBlock(M, offset, this._invSubKeys);
                },
                _doCryptBlock: function(M, offset, subKeys) {
                    this._lBlock = M[offset];
                    this._rBlock = M[offset + 1];
                    exchangeLR.call(this, 4, 252645135);
                    exchangeLR.call(this, 16, 65535);
                    exchangeRL.call(this, 2, 858993459);
                    exchangeRL.call(this, 8, 16711935);
                    exchangeLR.call(this, 1, 1431655765);
                    for (var round = 0; round < 16; round++) {
                        var subKey = subKeys[round];
                        var lBlock = this._lBlock;
                        var rBlock = this._rBlock;
                        var f = 0;
                        for (var i = 0; i < 8; i++) {
                            f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                        }
                        this._lBlock = rBlock;
                        this._rBlock = lBlock ^ f;
                    }
                    var t = this._lBlock;
                    this._lBlock = this._rBlock;
                    this._rBlock = t;
                    exchangeLR.call(this, 1, 1431655765);
                    exchangeRL.call(this, 8, 16711935);
                    exchangeRL.call(this, 2, 858993459);
                    exchangeLR.call(this, 16, 65535);
                    exchangeLR.call(this, 4, 252645135);
                    M[offset] = this._lBlock;
                    M[offset + 1] = this._rBlock;
                },
                keySize: 64 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
            });
            function exchangeLR(offset, mask) {
                var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
                this._rBlock ^= t;
                this._lBlock ^= t << offset;
            }
            function exchangeRL(offset, mask) {
                var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
                this._lBlock ^= t;
                this._rBlock ^= t << offset;
            }
            C.DES = BlockCipher._createHelper(DES);
            var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                _doReset: function() {
                    var key = this._key;
                    var keyWords = key.words;
                    this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
                    this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
                    this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
                },
                encryptBlock: function(M, offset) {
                    this._des1.encryptBlock(M, offset);
                    this._des2.decryptBlock(M, offset);
                    this._des3.encryptBlock(M, offset);
                },
                decryptBlock: function(M, offset) {
                    this._des3.decryptBlock(M, offset);
                    this._des2.encryptBlock(M, offset);
                    this._des1.decryptBlock(M, offset);
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
            });
            C.TripleDES = BlockCipher._createHelper(TripleDES);
        })();
        return CryptoJS.TripleDES;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(30), __webpack_require__(29), __webpack_require__(28), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;
            var SBOX = [];
            var INV_SBOX = [];
            var SUB_MIX_0 = [];
            var SUB_MIX_1 = [];
            var SUB_MIX_2 = [];
            var SUB_MIX_3 = [];
            var INV_SUB_MIX_0 = [];
            var INV_SUB_MIX_1 = [];
            var INV_SUB_MIX_2 = [];
            var INV_SUB_MIX_3 = [];
            (function() {
                var d = [];
                for (var i = 0; i < 256; i++) {
                    if (i < 128) {
                        d[i] = i << 1;
                    } else {
                        d[i] = i << 1 ^ 283;
                    }
                }
                var x = 0;
                var xi = 0;
                for (var i = 0; i < 256; i++) {
                    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                    sx = sx >>> 8 ^ sx & 255 ^ 99;
                    SBOX[x] = sx;
                    INV_SBOX[sx] = x;
                    var x2 = d[x];
                    var x4 = d[x2];
                    var x8 = d[x4];
                    var t = d[sx] * 257 ^ sx * 16843008;
                    SUB_MIX_0[x] = t << 24 | t >>> 8;
                    SUB_MIX_1[x] = t << 16 | t >>> 16;
                    SUB_MIX_2[x] = t << 8 | t >>> 24;
                    SUB_MIX_3[x] = t;
                    var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                    INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                    INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                    INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                    INV_SUB_MIX_3[sx] = t;
                    if (!x) {
                        x = xi = 1;
                    } else {
                        x = x2 ^ d[d[d[x8 ^ x2]]];
                        xi ^= d[d[xi]];
                    }
                }
            })();
            var RCON = [ 0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ];
            var AES = C_algo.AES = BlockCipher.extend({
                _doReset: function() {
                    if (this._nRounds && this._keyPriorReset === this._key) {
                        return;
                    }
                    var key = this._keyPriorReset = this._key;
                    var keyWords = key.words;
                    var keySize = key.sigBytes / 4;
                    var nRounds = this._nRounds = keySize + 6;
                    var ksRows = (nRounds + 1) * 4;
                    var keySchedule = this._keySchedule = [];
                    for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                        if (ksRow < keySize) {
                            keySchedule[ksRow] = keyWords[ksRow];
                        } else {
                            var t = keySchedule[ksRow - 1];
                            if (!(ksRow % keySize)) {
                                t = t << 8 | t >>> 24;
                                t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                                t ^= RCON[ksRow / keySize | 0] << 24;
                            } else if (keySize > 6 && ksRow % keySize == 4) {
                                t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                            }
                            keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                        }
                    }
                    var invKeySchedule = this._invKeySchedule = [];
                    for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                        var ksRow = ksRows - invKsRow;
                        if (invKsRow % 4) {
                            var t = keySchedule[ksRow];
                        } else {
                            var t = keySchedule[ksRow - 4];
                        }
                        if (invKsRow < 4 || ksRow <= 4) {
                            invKeySchedule[invKsRow] = t;
                        } else {
                            invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                        }
                    }
                },
                encryptBlock: function(M, offset) {
                    this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                },
                decryptBlock: function(M, offset) {
                    var t = M[offset + 1];
                    M[offset + 1] = M[offset + 3];
                    M[offset + 3] = t;
                    this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                    var t = M[offset + 1];
                    M[offset + 1] = M[offset + 3];
                    M[offset + 3] = t;
                },
                _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
                    var nRounds = this._nRounds;
                    var s0 = M[offset] ^ keySchedule[0];
                    var s1 = M[offset + 1] ^ keySchedule[1];
                    var s2 = M[offset + 2] ^ keySchedule[2];
                    var s3 = M[offset + 3] ^ keySchedule[3];
                    var ksRow = 4;
                    for (var round = 1; round < nRounds; round++) {
                        var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow++];
                        var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow++];
                        var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow++];
                        var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow++];
                        s0 = t0;
                        s1 = t1;
                        s2 = t2;
                        s3 = t3;
                    }
                    var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
                    var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
                    var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
                    var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
                    M[offset] = t0;
                    M[offset + 1] = t1;
                    M[offset + 2] = t2;
                    M[offset + 3] = t3;
                },
                keySize: 256 / 32
            });
            C.AES = BlockCipher._createHelper(AES);
        })();
        return CryptoJS.AES;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        (function(undefined) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var CipherParams = C_lib.CipherParams;
            var C_enc = C.enc;
            var Hex = C_enc.Hex;
            var C_format = C.format;
            var HexFormatter = C_format.Hex = {
                stringify: function(cipherParams) {
                    return cipherParams.ciphertext.toString(Hex);
                },
                parse: function(input) {
                    var ciphertext = Hex.parse(input);
                    return CipherParams.create({
                        ciphertext
                    });
                }
            };
        })();
        return CryptoJS.format.Hex;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.pad.NoPadding = {
            pad: function() {},
            unpad: function() {}
        };
        return CryptoJS.pad.NoPadding;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.pad.ZeroPadding = {
            pad: function(data, blockSize) {
                var blockSizeBytes = blockSize * 4;
                data.clamp();
                data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
            },
            unpad: function(data) {
                var dataWords = data.words;
                var i = data.sigBytes - 1;
                while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) {
                    i--;
                }
                data.sigBytes = i + 1;
            }
        };
        return CryptoJS.pad.ZeroPadding;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.pad.Iso97971 = {
            pad: function(data, blockSize) {
                data.concat(CryptoJS.lib.WordArray.create([ 2147483648 ], 1));
                CryptoJS.pad.ZeroPadding.pad(data, blockSize);
            },
            unpad: function(data) {
                CryptoJS.pad.ZeroPadding.unpad(data);
                data.sigBytes--;
            }
        };
        return CryptoJS.pad.Iso97971;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.pad.Iso10126 = {
            pad: function(data, blockSize) {
                var blockSizeBytes = blockSize * 4;
                var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([ nPaddingBytes << 24 ], 1));
            },
            unpad: function(data) {
                var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                data.sigBytes -= nPaddingBytes;
            }
        };
        return CryptoJS.pad.Iso10126;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.pad.AnsiX923 = {
            pad: function(data, blockSize) {
                var dataSigBytes = data.sigBytes;
                var blockSizeBytes = blockSize * 4;
                var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
                var lastBytePos = dataSigBytes + nPaddingBytes - 1;
                data.clamp();
                data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
                data.sigBytes += nPaddingBytes;
            },
            unpad: function(data) {
                var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                data.sigBytes -= nPaddingBytes;
            }
        };
        return CryptoJS.pad.Ansix923;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.mode.ECB = function() {
            var ECB = CryptoJS.lib.BlockCipherMode.extend();
            ECB.Encryptor = ECB.extend({
                processBlock: function(words, offset) {
                    this._cipher.encryptBlock(words, offset);
                }
            });
            ECB.Decryptor = ECB.extend({
                processBlock: function(words, offset) {
                    this._cipher.decryptBlock(words, offset);
                }
            });
            return ECB;
        }();
        return CryptoJS.mode.ECB;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.mode.OFB = function() {
            var OFB = CryptoJS.lib.BlockCipherMode.extend();
            var Encryptor = OFB.Encryptor = OFB.extend({
                processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    var iv = this._iv;
                    var keystream = this._keystream;
                    if (iv) {
                        keystream = this._keystream = iv.slice(0);
                        this._iv = undefined;
                    }
                    cipher.encryptBlock(keystream, 0);
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }
            });
            OFB.Decryptor = Encryptor;
            return OFB;
        }();
        return CryptoJS.mode.OFB;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.mode.CTRGladman = function() {
            var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
            function incWord(word) {
                if ((word >> 24 & 255) === 255) {
                    var b1 = word >> 16 & 255;
                    var b2 = word >> 8 & 255;
                    var b3 = word & 255;
                    if (b1 === 255) {
                        b1 = 0;
                        if (b2 === 255) {
                            b2 = 0;
                            if (b3 === 255) {
                                b3 = 0;
                            } else {
                                ++b3;
                            }
                        } else {
                            ++b2;
                        }
                    } else {
                        ++b1;
                    }
                    word = 0;
                    word += b1 << 16;
                    word += b2 << 8;
                    word += b3;
                } else {
                    word += 1 << 24;
                }
                return word;
            }
            function incCounter(counter) {
                if ((counter[0] = incWord(counter[0])) === 0) {
                    counter[1] = incWord(counter[1]);
                }
                return counter;
            }
            var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    var iv = this._iv;
                    var counter = this._counter;
                    if (iv) {
                        counter = this._counter = iv.slice(0);
                        this._iv = undefined;
                    }
                    incCounter(counter);
                    var keystream = counter.slice(0);
                    cipher.encryptBlock(keystream, 0);
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }
            });
            CTRGladman.Decryptor = Encryptor;
            return CTRGladman;
        }();
        return CryptoJS.mode.CTRGladman;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.mode.CTR = function() {
            var CTR = CryptoJS.lib.BlockCipherMode.extend();
            var Encryptor = CTR.Encryptor = CTR.extend({
                processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    var iv = this._iv;
                    var counter = this._counter;
                    if (iv) {
                        counter = this._counter = iv.slice(0);
                        this._iv = undefined;
                    }
                    var keystream = counter.slice(0);
                    cipher.encryptBlock(keystream, 0);
                    counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }
            });
            CTR.Decryptor = Encryptor;
            return CTR;
        }();
        return CryptoJS.mode.CTR;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10));
        } else {}
    })(this, function(CryptoJS) {
        CryptoJS.mode.CFB = function() {
            var CFB = CryptoJS.lib.BlockCipherMode.extend();
            CFB.Encryptor = CFB.extend({
                processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                    this._prevBlock = words.slice(offset, offset + blockSize);
                }
            });
            CFB.Decryptor = CFB.extend({
                processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    var thisBlock = words.slice(offset, offset + blockSize);
                    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                    this._prevBlock = thisBlock;
                }
            });
            function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                var iv = this._iv;
                if (iv) {
                    var keystream = iv.slice(0);
                    this._iv = undefined;
                } else {
                    var keystream = this._prevBlock;
                }
                cipher.encryptBlock(keystream, 0);
                for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= keystream[i];
                }
            }
            return CFB;
        }();
        return CryptoJS.mode.CFB;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(68), __webpack_require__(67));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA1 = C_algo.SHA1;
            var HMAC = C_algo.HMAC;
            var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                cfg: Base.extend({
                    keySize: 128 / 32,
                    hasher: SHA1,
                    iterations: 1
                }),
                init: function(cfg) {
                    this.cfg = this.cfg.extend(cfg);
                },
                compute: function(password, salt) {
                    var cfg = this.cfg;
                    var hmac = HMAC.create(cfg.hasher, password);
                    var derivedKey = WordArray.create();
                    var blockIndex = WordArray.create([ 1 ]);
                    var derivedKeyWords = derivedKey.words;
                    var blockIndexWords = blockIndex.words;
                    var keySize = cfg.keySize;
                    var iterations = cfg.iterations;
                    while (derivedKeyWords.length < keySize) {
                        var block = hmac.update(salt).finalize(blockIndex);
                        hmac.reset();
                        var blockWords = block.words;
                        var blockWordsLength = blockWords.length;
                        var intermediate = block;
                        for (var i = 1; i < iterations; i++) {
                            intermediate = hmac.finalize(intermediate);
                            hmac.reset();
                            var intermediateWords = intermediate.words;
                            for (var j = 0; j < blockWordsLength; j++) {
                                blockWords[j] ^= intermediateWords[j];
                            }
                        }
                        derivedKey.concat(block);
                        blockIndexWords[0]++;
                    }
                    derivedKey.sigBytes = keySize * 4;
                    return derivedKey;
                }
            });
            C.PBKDF2 = function(password, salt, cfg) {
                return PBKDF2.create(cfg).compute(password, salt);
            };
        })();
        return CryptoJS.PBKDF2;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function(Math) {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
            var _zl = WordArray.create([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ]);
            var _zr = WordArray.create([ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ]);
            var _sl = WordArray.create([ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ]);
            var _sr = WordArray.create([ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ]);
            var _hl = WordArray.create([ 0, 1518500249, 1859775393, 2400959708, 2840853838 ]);
            var _hr = WordArray.create([ 1352829926, 1548603684, 1836072691, 2053994217, 0 ]);
            var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                _doReset: function() {
                    this._hash = WordArray.create([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);
                },
                _doProcessBlock: function(M, offset) {
                    for (var i = 0; i < 16; i++) {
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
                        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                    }
                    var H = this._hash.words;
                    var hl = _hl.words;
                    var hr = _hr.words;
                    var zl = _zl.words;
                    var zr = _zr.words;
                    var sl = _sl.words;
                    var sr = _sr.words;
                    var al, bl, cl, dl, el;
                    var ar, br, cr, dr, er;
                    ar = al = H[0];
                    br = bl = H[1];
                    cr = cl = H[2];
                    dr = dl = H[3];
                    er = el = H[4];
                    var t;
                    for (var i = 0; i < 80; i += 1) {
                        t = al + M[offset + zl[i]] | 0;
                        if (i < 16) {
                            t += f1(bl, cl, dl) + hl[0];
                        } else if (i < 32) {
                            t += f2(bl, cl, dl) + hl[1];
                        } else if (i < 48) {
                            t += f3(bl, cl, dl) + hl[2];
                        } else if (i < 64) {
                            t += f4(bl, cl, dl) + hl[3];
                        } else {
                            t += f5(bl, cl, dl) + hl[4];
                        }
                        t = t | 0;
                        t = rotl(t, sl[i]);
                        t = t + el | 0;
                        al = el;
                        el = dl;
                        dl = rotl(cl, 10);
                        cl = bl;
                        bl = t;
                        t = ar + M[offset + zr[i]] | 0;
                        if (i < 16) {
                            t += f5(br, cr, dr) + hr[0];
                        } else if (i < 32) {
                            t += f4(br, cr, dr) + hr[1];
                        } else if (i < 48) {
                            t += f3(br, cr, dr) + hr[2];
                        } else if (i < 64) {
                            t += f2(br, cr, dr) + hr[3];
                        } else {
                            t += f1(br, cr, dr) + hr[4];
                        }
                        t = t | 0;
                        t = rotl(t, sr[i]);
                        t = t + er | 0;
                        ar = er;
                        er = dr;
                        dr = rotl(cr, 10);
                        cr = br;
                        br = t;
                    }
                    t = H[1] + cl + dr | 0;
                    H[1] = H[2] + dl + er | 0;
                    H[2] = H[3] + el + ar | 0;
                    H[3] = H[4] + al + br | 0;
                    H[4] = H[0] + bl + cr | 0;
                    H[0] = t;
                },
                _doFinalize: function() {
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
                    data.sigBytes = (dataWords.length + 1) * 4;
                    this._process();
                    var hash = this._hash;
                    var H = hash.words;
                    for (var i = 0; i < 5; i++) {
                        var H_i = H[i];
                        H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                    }
                    return hash;
                },
                clone: function() {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
                    return clone;
                }
            });
            function f1(x, y, z) {
                return x ^ y ^ z;
            }
            function f2(x, y, z) {
                return x & y | ~x & z;
            }
            function f3(x, y, z) {
                return (x | ~y) ^ z;
            }
            function f4(x, y, z) {
                return x & z | y & ~z;
            }
            function f5(x, y, z) {
                return x ^ (y | ~z);
            }
            function rotl(x, n) {
                return x << n | x >>> 32 - n;
            }
            C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
            C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
        })(Math);
        return CryptoJS.RIPEMD160;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(53), __webpack_require__(105));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C.algo;
            var SHA512 = C_algo.SHA512;
            var SHA384 = C_algo.SHA384 = SHA512.extend({
                _doReset: function() {
                    this._hash = new X64WordArray.init([ new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428) ]);
                },
                _doFinalize: function() {
                    var hash = SHA512._doFinalize.call(this);
                    hash.sigBytes -= 16;
                    return hash;
                }
            });
            C.SHA384 = SHA512._createHelper(SHA384);
            C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
        })();
        return CryptoJS.SHA384;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(106));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA256 = C_algo.SHA256;
            var SHA224 = C_algo.SHA224 = SHA256.extend({
                _doReset: function() {
                    this._hash = new WordArray.init([ 3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428 ]);
                },
                _doFinalize: function() {
                    var hash = SHA256._doFinalize.call(this);
                    hash.sigBytes -= 4;
                    return hash;
                }
            });
            C.SHA224 = SHA256._createHelper(SHA224);
            C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
        })();
        return CryptoJS.SHA224;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;
            var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
                stringify: function(wordArray) {
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var utf16Chars = [];
                    for (var i = 0; i < sigBytes; i += 2) {
                        var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                        utf16Chars.push(String.fromCharCode(codePoint));
                    }
                    return utf16Chars.join("");
                },
                parse: function(utf16Str) {
                    var utf16StrLength = utf16Str.length;
                    var words = [];
                    for (var i = 0; i < utf16StrLength; i++) {
                        words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                    }
                    return WordArray.create(words, utf16StrLength * 2);
                }
            };
            C_enc.Utf16LE = {
                stringify: function(wordArray) {
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var utf16Chars = [];
                    for (var i = 0; i < sigBytes; i += 2) {
                        var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                        utf16Chars.push(String.fromCharCode(codePoint));
                    }
                    return utf16Chars.join("");
                },
                parse: function(utf16Str) {
                    var utf16StrLength = utf16Str.length;
                    var words = [];
                    for (var i = 0; i < utf16StrLength; i++) {
                        words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                    }
                    return WordArray.create(words, utf16StrLength * 2);
                }
            };
            function swapEndian(word) {
                return word << 8 & 4278255360 | word >>> 8 & 16711935;
            }
        })();
        return CryptoJS.enc.Utf16;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6));
        } else {}
    })(this, function(CryptoJS) {
        (function() {
            if (typeof ArrayBuffer != "function") {
                return;
            }
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var superInit = WordArray.init;
            var subInit = WordArray.init = function(typedArray) {
                if (typedArray instanceof ArrayBuffer) {
                    typedArray = new Uint8Array(typedArray);
                }
                if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                    typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                }
                if (typedArray instanceof Uint8Array) {
                    var typedArrayByteLength = typedArray.byteLength;
                    var words = [];
                    for (var i = 0; i < typedArrayByteLength; i++) {
                        words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                    }
                    superInit.call(this, words, typedArrayByteLength);
                } else {
                    superInit.apply(this, arguments);
                }
            };
            subInit.prototype = WordArray;
        })();
        return CryptoJS.lib.WordArray;
    });
}, function(module, exports, __webpack_require__) {
    (function(root, factory, undef) {
        if (true) {
            module.exports = exports = factory(__webpack_require__(6), __webpack_require__(53), __webpack_require__(257), __webpack_require__(256), __webpack_require__(30), __webpack_require__(29), __webpack_require__(68), __webpack_require__(106), __webpack_require__(255), __webpack_require__(105), __webpack_require__(254), __webpack_require__(104), __webpack_require__(253), __webpack_require__(67), __webpack_require__(252), __webpack_require__(28), __webpack_require__(10), __webpack_require__(251), __webpack_require__(250), __webpack_require__(249), __webpack_require__(248), __webpack_require__(247), __webpack_require__(246), __webpack_require__(245), __webpack_require__(244), __webpack_require__(243), __webpack_require__(242), __webpack_require__(241), __webpack_require__(240), __webpack_require__(239), __webpack_require__(238), __webpack_require__(237), __webpack_require__(236));
        } else {}
    })(this, function(CryptoJS) {
        return CryptoJS;
    });
}, function(module, exports, __webpack_require__) {
    var Jsonrpc = __webpack_require__(107);
    var utils = __webpack_require__(11);
    var c = __webpack_require__(52);
    var errors = __webpack_require__(31);
    var RequestManager = function(provider) {
        this.provider = provider;
        this.polls = {};
        this.timeout = null;
    };
    RequestManager.prototype.send = function(data) {
        if (!this.provider) {
            console.error(errors.InvalidProvider());
            return null;
        }
        var payload = Jsonrpc.toPayload(data.method, data.params);
        var result = this.provider.send(payload);
        if (!Jsonrpc.isValidResponse(result)) {
            throw errors.InvalidResponse(result);
        }
        return result.result;
    };
    RequestManager.prototype.sendAsync = function(data, callback) {
        if (!this.provider) {
            return callback(errors.InvalidProvider());
        }
        var payload = Jsonrpc.toPayload(data.method, data.params);
        this.provider.sendAsync(payload, function(err, result) {
            if (err) {
                return callback(err);
            }
            if (!Jsonrpc.isValidResponse(result)) {
                return callback(errors.InvalidResponse(result));
            }
            callback(null, result.result);
        });
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
        if (!this.provider) {
            return callback(errors.InvalidProvider());
        }
        var payload = Jsonrpc.toBatchPayload(data);
        this.provider.sendAsync(payload, function(err, results) {
            if (err) {
                return callback(err);
            }
            if (!utils.isArray(results)) {
                return callback(errors.InvalidResponse(results));
            }
            callback(err, results);
        });
    };
    RequestManager.prototype.setProvider = function(p) {
        this.provider = p;
    };
    RequestManager.prototype.startPolling = function(data, pollId, callback, uninstall) {
        this.polls[pollId] = {
            data,
            id: pollId,
            callback,
            uninstall
        };
        if (!this.timeout) {
            this.poll();
        }
    };
    RequestManager.prototype.stopPolling = function(pollId) {
        delete this.polls[pollId];
        if (Object.keys(this.polls).length === 0 && this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    };
    RequestManager.prototype.reset = function(keepIsSyncing) {
        for (var key in this.polls) {
            if (!keepIsSyncing || key.indexOf("syncPoll_") === -1) {
                this.polls[key].uninstall();
                delete this.polls[key];
            }
        }
        if (Object.keys(this.polls).length === 0 && this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    };
    RequestManager.prototype.poll = function() {
        this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);
        if (Object.keys(this.polls).length === 0) {
            return;
        }
        if (!this.provider) {
            console.error(errors.InvalidProvider());
            return;
        }
        var pollsData = [];
        var pollsIds = [];
        for (var key in this.polls) {
            pollsData.push(this.polls[key].data);
            pollsIds.push(key);
        }
        if (pollsData.length === 0) {
            return;
        }
        var payload = Jsonrpc.toBatchPayload(pollsData);
        var pollsIdMap = {};
        payload.forEach(function(load, index) {
            pollsIdMap[load.id] = pollsIds[index];
        });
        var self = this;
        this.provider.sendAsync(payload, function(error, results) {
            if (error) {
                return;
            }
            if (!utils.isArray(results)) {
                throw errors.InvalidResponse(results);
            }
            results.map(function(result) {
                var id = pollsIdMap[result.id];
                if (self.polls[id]) {
                    result.callback = self.polls[id].callback;
                    return result;
                } else return false;
            }).filter(function(result) {
                return !!result;
            }).filter(function(result) {
                var valid = Jsonrpc.isValidResponse(result);
                if (!valid) {
                    result.callback(errors.InvalidResponse(result));
                }
                return valid;
            }).forEach(function(result) {
                result.callback(null, result.result);
            });
        });
    };
    module.exports = RequestManager;
}, function(module, exports, __webpack_require__) {
    var RequestManager = __webpack_require__(259);
    var Iban = __webpack_require__(51);
    var Eth = __webpack_require__(234);
    var DB = __webpack_require__(215);
    var Shh = __webpack_require__(214);
    var Net = __webpack_require__(213);
    var Personal = __webpack_require__(212);
    var Swarm = __webpack_require__(211);
    var Settings = __webpack_require__(210);
    var version = __webpack_require__(209);
    var utils = __webpack_require__(11);
    var sha3 = __webpack_require__(37);
    var extend = __webpack_require__(208);
    var Batch = __webpack_require__(207);
    var Property = __webpack_require__(27);
    var HttpProvider = __webpack_require__(108);
    var IpcProvider = __webpack_require__(206);
    var BigNumber = __webpack_require__(38);
    function Web3(provider) {
        this._requestManager = new RequestManager(provider);
        this.currentProvider = provider;
        this.eth = new Eth(this);
        this.db = new DB(this);
        this.shh = new Shh(this);
        this.net = new Net(this);
        this.personal = new Personal(this);
        this.bzz = new Swarm(this);
        this.settings = new Settings();
        this.version = {
            api: version.version
        };
        this.providers = {
            HttpProvider,
            IpcProvider
        };
        this._extend = extend(this);
        this._extend({
            properties: properties()
        });
    }
    Web3.providers = {
        HttpProvider,
        IpcProvider
    };
    Web3.prototype.setProvider = function(provider) {
        this._requestManager.setProvider(provider);
        this.currentProvider = provider;
    };
    Web3.prototype.reset = function(keepIsSyncing) {
        this._requestManager.reset(keepIsSyncing);
        this.settings = new Settings();
    };
    Web3.prototype.BigNumber = BigNumber;
    Web3.prototype.toHex = utils.toHex;
    Web3.prototype.toAscii = utils.toAscii;
    Web3.prototype.toUtf8 = utils.toUtf8;
    Web3.prototype.fromAscii = utils.fromAscii;
    Web3.prototype.fromUtf8 = utils.fromUtf8;
    Web3.prototype.toDecimal = utils.toDecimal;
    Web3.prototype.fromDecimal = utils.fromDecimal;
    Web3.prototype.toBigNumber = utils.toBigNumber;
    Web3.prototype.toWei = utils.toWei;
    Web3.prototype.fromWei = utils.fromWei;
    Web3.prototype.isAddress = utils.isAddress;
    Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
    Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
    Web3.prototype.isIBAN = utils.isIBAN;
    Web3.prototype.padLeft = utils.padLeft;
    Web3.prototype.padRight = utils.padRight;
    Web3.prototype.sha3 = function(string, options) {
        return "0x" + sha3(string, options);
    };
    Web3.prototype.fromICAP = function(icap) {
        var iban = new Iban(icap);
        return iban.address();
    };
    var properties = function() {
        return [ new Property({
            name: "version.node",
            getter: "web3_clientVersion"
        }), new Property({
            name: "version.network",
            getter: "net_version",
            inputFormatter: utils.toDecimal
        }), new Property({
            name: "version.ethereum",
            getter: "eth_protocolVersion",
            inputFormatter: utils.toDecimal
        }), new Property({
            name: "version.whisper",
            getter: "shh_version",
            inputFormatter: utils.toDecimal
        }) ];
    };
    Web3.prototype.isConnected = function() {
        return this.currentProvider && this.currentProvider.isConnected();
    };
    Web3.prototype.createBatch = function() {
        return new Batch(this);
    };
    module.exports = Web3;
}, function(module, exports, __webpack_require__) {
    var Web3 = __webpack_require__(260);
    if (typeof window !== "undefined" && typeof window.Web3 === "undefined") {
        window.Web3 = Web3;
    }
    module.exports = Web3;
}, function(module, exports) {
    module.exports = XMLHttpRequest;
}, function(module, exports, __webpack_require__) {
    "use strict";
    if (typeof XMLHttpRequest === "undefined") {
        exports.XMLHttpRequest = {};
    } else {
        exports.XMLHttpRequest = XMLHttpRequest;
    }
}, function(module, exports, __webpack_require__) {
    (function(setImmediate, process, global, module) {
        (function(global, factory) {
            true ? factory(exports) : undefined;
        })(this, function(exports) {
            "use strict";
            function slice(arrayLike, start) {
                start = start | 0;
                var newLen = Math.max(arrayLike.length - start, 0);
                var newArr = Array(newLen);
                for (var idx = 0; idx < newLen; idx++) {
                    newArr[idx] = arrayLike[start + idx];
                }
                return newArr;
            }
            var apply = function(fn) {
                var args = slice(arguments, 1);
                return function() {
                    var callArgs = slice(arguments);
                    return fn.apply(null, args.concat(callArgs));
                };
            };
            var initialParams = function(fn) {
                return function() {
                    var args = slice(arguments);
                    var callback = args.pop();
                    fn.call(this, args, callback);
                };
            };
            function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
            }
            var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
            var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
            function fallback(fn) {
                setTimeout(fn, 0);
            }
            function wrap(defer) {
                return function(fn) {
                    var args = slice(arguments, 1);
                    defer(function() {
                        fn.apply(null, args);
                    });
                };
            }
            var _defer;
            if (hasSetImmediate) {
                _defer = setImmediate;
            } else if (hasNextTick) {
                _defer = process.nextTick;
            } else {
                _defer = fallback;
            }
            var setImmediate$1 = wrap(_defer);
            function asyncify(func) {
                return initialParams(function(args, callback) {
                    var result;
                    try {
                        result = func.apply(this, args);
                    } catch (e) {
                        return callback(e);
                    }
                    if (isObject(result) && typeof result.then === "function") {
                        result.then(function(value) {
                            invokeCallback(callback, null, value);
                        }, function(err) {
                            invokeCallback(callback, err.message ? err : new Error(err));
                        });
                    } else {
                        callback(null, result);
                    }
                });
            }
            function invokeCallback(callback, error, value) {
                try {
                    callback(error, value);
                } catch (e) {
                    setImmediate$1(rethrow, e);
                }
            }
            function rethrow(error) {
                throw error;
            }
            var supportsSymbol = typeof Symbol === "function";
            function isAsync(fn) {
                return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
            }
            function wrapAsync(asyncFn) {
                return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
            }
            function applyEach$1(eachfn) {
                return function(fns) {
                    var args = slice(arguments, 1);
                    var go = initialParams(function(args, callback) {
                        var that = this;
                        return eachfn(fns, function(fn, cb) {
                            wrapAsync(fn).apply(that, args.concat(cb));
                        }, callback);
                    });
                    if (args.length) {
                        return go.apply(this, args);
                    } else {
                        return go;
                    }
                };
            }
            var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var Symbol$1 = root.Symbol;
            var objectProto = Object.prototype;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var nativeObjectToString = objectProto.toString;
            var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
                try {
                    value[symToStringTag$1] = undefined;
                    var unmasked = true;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                    if (isOwn) {
                        value[symToStringTag$1] = tag;
                    } else {
                        delete value[symToStringTag$1];
                    }
                }
                return result;
            }
            var objectProto$1 = Object.prototype;
            var nativeObjectToString$1 = objectProto$1.toString;
            function objectToString(value) {
                return nativeObjectToString$1.call(value);
            }
            var nullTag = "[object Null]";
            var undefinedTag = "[object Undefined]";
            var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
            function baseGetTag(value) {
                if (value == null) {
                    return value === undefined ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            var asyncTag = "[object AsyncFunction]";
            var funcTag = "[object Function]";
            var genTag = "[object GeneratorFunction]";
            var proxyTag = "[object Proxy]";
            function isFunction(value) {
                if (!isObject(value)) {
                    return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            var MAX_SAFE_INTEGER = 9007199254740991;
            function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
            }
            var breakLoop = {};
            function noop() {}
            function once(fn) {
                return function() {
                    if (fn === null) return;
                    var callFn = fn;
                    fn = null;
                    callFn.apply(this, arguments);
                };
            }
            var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
            var getIterator = function(coll) {
                return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
            };
            function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                    result[index] = iteratee(index);
                }
                return result;
            }
            function isObjectLike(value) {
                return value != null && typeof value == "object";
            }
            var argsTag = "[object Arguments]";
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            var objectProto$3 = Object.prototype;
            var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
            var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
            var isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            };
            var isArray = Array.isArray;
            function stubFalse() {
                return false;
            }
            var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
            var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var Buffer = moduleExports ? root.Buffer : undefined;
            var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
            var isBuffer = nativeIsBuffer || stubFalse;
            var MAX_SAFE_INTEGER$1 = 9007199254740991;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER$1 : length;
                return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
            }
            var argsTag$1 = "[object Arguments]";
            var arrayTag = "[object Array]";
            var boolTag = "[object Boolean]";
            var dateTag = "[object Date]";
            var errorTag = "[object Error]";
            var funcTag$1 = "[object Function]";
            var mapTag = "[object Map]";
            var numberTag = "[object Number]";
            var objectTag = "[object Object]";
            var regexpTag = "[object RegExp]";
            var setTag = "[object Set]";
            var stringTag = "[object String]";
            var weakMapTag = "[object WeakMap]";
            var arrayBufferTag = "[object ArrayBuffer]";
            var dataViewTag = "[object DataView]";
            var float32Tag = "[object Float32Array]";
            var float64Tag = "[object Float64Array]";
            var int8Tag = "[object Int8Array]";
            var int16Tag = "[object Int16Array]";
            var int32Tag = "[object Int32Array]";
            var uint8Tag = "[object Uint8Array]";
            var uint8ClampedTag = "[object Uint8ClampedArray]";
            var uint16Tag = "[object Uint16Array]";
            var uint32Tag = "[object Uint32Array]";
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            }
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }
            var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
            var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
            var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
            var freeProcess = moduleExports$1 && freeGlobal.process;
            var nodeUtil = function() {
                try {
                    return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            var objectProto$2 = Object.prototype;
            var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) {
                    if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                        result.push(key);
                    }
                }
                return result;
            }
            var objectProto$5 = Object.prototype;
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
                return value === proto;
            }
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            var nativeKeys = overArg(Object.keys, Object);
            var objectProto$4 = Object.prototype;
            var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
            function baseKeys(object) {
                if (!isPrototype(object)) {
                    return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
                        result.push(key);
                    }
                }
                return result;
            }
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            function createArrayIterator(coll) {
                var i = -1;
                var len = coll.length;
                return function next() {
                    return ++i < len ? {
                        value: coll[i],
                        key: i
                    } : null;
                };
            }
            function createES2015Iterator(iterator) {
                var i = -1;
                return function next() {
                    var item = iterator.next();
                    if (item.done) return null;
                    i++;
                    return {
                        value: item.value,
                        key: i
                    };
                };
            }
            function createObjectIterator(obj) {
                var okeys = keys(obj);
                var i = -1;
                var len = okeys.length;
                return function next() {
                    var key = okeys[++i];
                    return i < len ? {
                        value: obj[key],
                        key
                    } : null;
                };
            }
            function iterator(coll) {
                if (isArrayLike(coll)) {
                    return createArrayIterator(coll);
                }
                var iterator = getIterator(coll);
                return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
            }
            function onlyOnce(fn) {
                return function() {
                    if (fn === null) throw new Error("Callback was already called.");
                    var callFn = fn;
                    fn = null;
                    callFn.apply(this, arguments);
                };
            }
            function _eachOfLimit(limit) {
                return function(obj, iteratee, callback) {
                    callback = once(callback || noop);
                    if (limit <= 0 || !obj) {
                        return callback(null);
                    }
                    var nextElem = iterator(obj);
                    var done = false;
                    var running = 0;
                    function iterateeCallback(err, value) {
                        running -= 1;
                        if (err) {
                            done = true;
                            callback(err);
                        } else if (value === breakLoop || done && running <= 0) {
                            done = true;
                            return callback(null);
                        } else {
                            replenish();
                        }
                    }
                    function replenish() {
                        while (running < limit && !done) {
                            var elem = nextElem();
                            if (elem === null) {
                                done = true;
                                if (running <= 0) {
                                    callback(null);
                                }
                                return;
                            }
                            running += 1;
                            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                        }
                    }
                    replenish();
                };
            }
            function eachOfLimit(coll, limit, iteratee, callback) {
                _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
            }
            function doLimit(fn, limit) {
                return function(iterable, iteratee, callback) {
                    return fn(iterable, limit, iteratee, callback);
                };
            }
            function eachOfArrayLike(coll, iteratee, callback) {
                callback = once(callback || noop);
                var index = 0, completed = 0, length = coll.length;
                if (length === 0) {
                    callback(null);
                }
                function iteratorCallback(err, value) {
                    if (err) {
                        callback(err);
                    } else if (++completed === length || value === breakLoop) {
                        callback(null);
                    }
                }
                for (;index < length; index++) {
                    iteratee(coll[index], index, onlyOnce(iteratorCallback));
                }
            }
            var eachOfGeneric = doLimit(eachOfLimit, Infinity);
            var eachOf = function(coll, iteratee, callback) {
                var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
                eachOfImplementation(coll, wrapAsync(iteratee), callback);
            };
            function doParallel(fn) {
                return function(obj, iteratee, callback) {
                    return fn(eachOf, obj, wrapAsync(iteratee), callback);
                };
            }
            function _asyncMap(eachfn, arr, iteratee, callback) {
                callback = callback || noop;
                arr = arr || [];
                var results = [];
                var counter = 0;
                var _iteratee = wrapAsync(iteratee);
                eachfn(arr, function(value, _, callback) {
                    var index = counter++;
                    _iteratee(value, function(err, v) {
                        results[index] = v;
                        callback(err);
                    });
                }, function(err) {
                    callback(err, results);
                });
            }
            var map = doParallel(_asyncMap);
            var applyEach = applyEach$1(map);
            function doParallelLimit(fn) {
                return function(obj, limit, iteratee, callback) {
                    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
                };
            }
            var mapLimit = doParallelLimit(_asyncMap);
            var mapSeries = doLimit(mapLimit, 1);
            var applyEachSeries = applyEach$1(mapSeries);
            function arrayEach(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break;
                    }
                }
                return array;
            }
            function createBaseFor(fromRight) {
                return function(object, iteratee, keysFunc) {
                    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                    while (length--) {
                        var key = props[fromRight ? length : ++index];
                        if (iteratee(iterable[key], key, iterable) === false) {
                            break;
                        }
                    }
                    return object;
                };
            }
            var baseFor = createBaseFor();
            function baseForOwn(object, iteratee) {
                return object && baseFor(object, iteratee, keys);
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                while (fromRight ? index-- : ++index < length) {
                    if (predicate(array[index], index, array)) {
                        return index;
                    }
                }
                return -1;
            }
            function baseIsNaN(value) {
                return value !== value;
            }
            function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1, length = array.length;
                while (++index < length) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            var auto = function(tasks, concurrency, callback) {
                if (typeof concurrency === "function") {
                    callback = concurrency;
                    concurrency = null;
                }
                callback = once(callback || noop);
                var keys$$1 = keys(tasks);
                var numTasks = keys$$1.length;
                if (!numTasks) {
                    return callback(null);
                }
                if (!concurrency) {
                    concurrency = numTasks;
                }
                var results = {};
                var runningTasks = 0;
                var hasError = false;
                var listeners = Object.create(null);
                var readyTasks = [];
                var readyToCheck = [];
                var uncheckedDependencies = {};
                baseForOwn(tasks, function(task, key) {
                    if (!isArray(task)) {
                        enqueueTask(key, [ task ]);
                        readyToCheck.push(key);
                        return;
                    }
                    var dependencies = task.slice(0, task.length - 1);
                    var remainingDependencies = dependencies.length;
                    if (remainingDependencies === 0) {
                        enqueueTask(key, task);
                        readyToCheck.push(key);
                        return;
                    }
                    uncheckedDependencies[key] = remainingDependencies;
                    arrayEach(dependencies, function(dependencyName) {
                        if (!tasks[dependencyName]) {
                            throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
                        }
                        addListener(dependencyName, function() {
                            remainingDependencies--;
                            if (remainingDependencies === 0) {
                                enqueueTask(key, task);
                            }
                        });
                    });
                });
                checkForDeadlocks();
                processQueue();
                function enqueueTask(key, task) {
                    readyTasks.push(function() {
                        runTask(key, task);
                    });
                }
                function processQueue() {
                    if (readyTasks.length === 0 && runningTasks === 0) {
                        return callback(null, results);
                    }
                    while (readyTasks.length && runningTasks < concurrency) {
                        var run = readyTasks.shift();
                        run();
                    }
                }
                function addListener(taskName, fn) {
                    var taskListeners = listeners[taskName];
                    if (!taskListeners) {
                        taskListeners = listeners[taskName] = [];
                    }
                    taskListeners.push(fn);
                }
                function taskComplete(taskName) {
                    var taskListeners = listeners[taskName] || [];
                    arrayEach(taskListeners, function(fn) {
                        fn();
                    });
                    processQueue();
                }
                function runTask(key, task) {
                    if (hasError) return;
                    var taskCallback = onlyOnce(function(err, result) {
                        runningTasks--;
                        if (arguments.length > 2) {
                            result = slice(arguments, 1);
                        }
                        if (err) {
                            var safeResults = {};
                            baseForOwn(results, function(val, rkey) {
                                safeResults[rkey] = val;
                            });
                            safeResults[key] = result;
                            hasError = true;
                            listeners = Object.create(null);
                            callback(err, safeResults);
                        } else {
                            results[key] = result;
                            taskComplete(key);
                        }
                    });
                    runningTasks++;
                    var taskFn = wrapAsync(task[task.length - 1]);
                    if (task.length > 1) {
                        taskFn(results, taskCallback);
                    } else {
                        taskFn(taskCallback);
                    }
                }
                function checkForDeadlocks() {
                    var currentTask;
                    var counter = 0;
                    while (readyToCheck.length) {
                        currentTask = readyToCheck.pop();
                        counter++;
                        arrayEach(getDependents(currentTask), function(dependent) {
                            if (--uncheckedDependencies[dependent] === 0) {
                                readyToCheck.push(dependent);
                            }
                        });
                    }
                    if (counter !== numTasks) {
                        throw new Error("async.auto cannot execute tasks due to a recursive dependency");
                    }
                }
                function getDependents(taskName) {
                    var result = [];
                    baseForOwn(tasks, function(task, key) {
                        if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                            result.push(key);
                        }
                    });
                    return result;
                }
            };
            function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                    result[index] = iteratee(array[index], index, array);
                }
                return result;
            }
            var symbolTag = "[object Symbol]";
            function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
            }
            var INFINITY = 1 / 0;
            var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
            var symbolToString = symbolProto ? symbolProto.toString : undefined;
            function baseToString(value) {
                if (typeof value == "string") {
                    return value;
                }
                if (isArray(value)) {
                    return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : "";
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
            }
            function baseSlice(array, start, end) {
                var index = -1, length = array.length;
                if (start < 0) {
                    start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                    end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result = Array(length);
                while (++index < length) {
                    result[index] = array[index + start];
                }
                return result;
            }
            function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined ? length : end;
                return !start && end >= length ? array : baseSlice(array, start, end);
            }
            function charsEndIndex(strSymbols, chrSymbols) {
                var index = strSymbols.length;
                while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                return index;
            }
            function charsStartIndex(strSymbols, chrSymbols) {
                var index = -1, length = strSymbols.length;
                while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                return index;
            }
            function asciiToArray(string) {
                return string.split("");
            }
            var rsAstralRange = "\\ud800-\\udfff";
            var rsComboMarksRange = "\\u0300-\\u036f";
            var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
            var rsComboSymbolsRange = "\\u20d0-\\u20ff";
            var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
            var rsVarRange = "\\ufe0e\\ufe0f";
            var rsZWJ = "\\u200d";
            var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
            function hasUnicode(string) {
                return reHasUnicode.test(string);
            }
            var rsAstralRange$1 = "\\ud800-\\udfff";
            var rsComboMarksRange$1 = "\\u0300-\\u036f";
            var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
            var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
            var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
            var rsVarRange$1 = "\\ufe0e\\ufe0f";
            var rsAstral = "[" + rsAstralRange$1 + "]";
            var rsCombo = "[" + rsComboRange$1 + "]";
            var rsFitz = "\\ud83c[\\udffb-\\udfff]";
            var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
            var rsNonAstral = "[^" + rsAstralRange$1 + "]";
            var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
            var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
            var rsZWJ$1 = "\\u200d";
            var reOptMod = rsModifier + "?";
            var rsOptVar = "[" + rsVarRange$1 + "]?";
            var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [ rsNonAstral, rsRegional, rsSurrPair ].join("|") + ")" + rsOptVar + reOptMod + ")*";
            var rsSeq = rsOptVar + reOptMod + rsOptJoin;
            var rsSymbol = "(?:" + [ rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral ].join("|") + ")";
            var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
            function unicodeToArray(string) {
                return string.match(reUnicode) || [];
            }
            function stringToArray(string) {
                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
            }
            function toString(value) {
                return value == null ? "" : baseToString(value);
            }
            var reTrim = /^\s+|\s+$/g;
            function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                    return string.replace(reTrim, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                    return string;
                }
                var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start, end).join("");
            }
            var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
            var FN_ARG_SPLIT = /,/;
            var FN_ARG = /(=.+)?(\s*)$/;
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
            function parseParams(func) {
                func = func.toString().replace(STRIP_COMMENTS, "");
                func = func.match(FN_ARGS)[2].replace(" ", "");
                func = func ? func.split(FN_ARG_SPLIT) : [];
                func = func.map(function(arg) {
                    return trim(arg.replace(FN_ARG, ""));
                });
                return func;
            }
            function autoInject(tasks, callback) {
                var newTasks = {};
                baseForOwn(tasks, function(taskFn, key) {
                    var params;
                    var fnIsAsync = isAsync(taskFn);
                    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
                    if (isArray(taskFn)) {
                        params = taskFn.slice(0, -1);
                        taskFn = taskFn[taskFn.length - 1];
                        newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
                    } else if (hasNoDeps) {
                        newTasks[key] = taskFn;
                    } else {
                        params = parseParams(taskFn);
                        if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                            throw new Error("autoInject task functions require explicit parameters.");
                        }
                        if (!fnIsAsync) params.pop();
                        newTasks[key] = params.concat(newTask);
                    }
                    function newTask(results, taskCb) {
                        var newArgs = arrayMap(params, function(name) {
                            return results[name];
                        });
                        newArgs.push(taskCb);
                        wrapAsync(taskFn).apply(null, newArgs);
                    }
                });
                auto(newTasks, callback);
            }
            function DLL() {
                this.head = this.tail = null;
                this.length = 0;
            }
            function setInitial(dll, node) {
                dll.length = 1;
                dll.head = dll.tail = node;
            }
            DLL.prototype.removeLink = function(node) {
                if (node.prev) node.prev.next = node.next; else this.head = node.next;
                if (node.next) node.next.prev = node.prev; else this.tail = node.prev;
                node.prev = node.next = null;
                this.length -= 1;
                return node;
            };
            DLL.prototype.empty = function() {
                while (this.head) this.shift();
                return this;
            };
            DLL.prototype.insertAfter = function(node, newNode) {
                newNode.prev = node;
                newNode.next = node.next;
                if (node.next) node.next.prev = newNode; else this.tail = newNode;
                node.next = newNode;
                this.length += 1;
            };
            DLL.prototype.insertBefore = function(node, newNode) {
                newNode.prev = node.prev;
                newNode.next = node;
                if (node.prev) node.prev.next = newNode; else this.head = newNode;
                node.prev = newNode;
                this.length += 1;
            };
            DLL.prototype.unshift = function(node) {
                if (this.head) this.insertBefore(this.head, node); else setInitial(this, node);
            };
            DLL.prototype.push = function(node) {
                if (this.tail) this.insertAfter(this.tail, node); else setInitial(this, node);
            };
            DLL.prototype.shift = function() {
                return this.head && this.removeLink(this.head);
            };
            DLL.prototype.pop = function() {
                return this.tail && this.removeLink(this.tail);
            };
            DLL.prototype.toArray = function() {
                var arr = Array(this.length);
                var curr = this.head;
                for (var idx = 0; idx < this.length; idx++) {
                    arr[idx] = curr.data;
                    curr = curr.next;
                }
                return arr;
            };
            DLL.prototype.remove = function(testFn) {
                var curr = this.head;
                while (!!curr) {
                    var next = curr.next;
                    if (testFn(curr)) {
                        this.removeLink(curr);
                    }
                    curr = next;
                }
                return this;
            };
            function queue(worker, concurrency, payload) {
                if (concurrency == null) {
                    concurrency = 1;
                } else if (concurrency === 0) {
                    throw new Error("Concurrency must not be zero");
                }
                var _worker = wrapAsync(worker);
                var numRunning = 0;
                var workersList = [];
                var processingScheduled = false;
                function _insert(data, insertAtFront, callback) {
                    if (callback != null && typeof callback !== "function") {
                        throw new Error("task callback must be a function");
                    }
                    q.started = true;
                    if (!isArray(data)) {
                        data = [ data ];
                    }
                    if (data.length === 0 && q.idle()) {
                        return setImmediate$1(function() {
                            q.drain();
                        });
                    }
                    for (var i = 0, l = data.length; i < l; i++) {
                        var item = {
                            data: data[i],
                            callback: callback || noop
                        };
                        if (insertAtFront) {
                            q._tasks.unshift(item);
                        } else {
                            q._tasks.push(item);
                        }
                    }
                    if (!processingScheduled) {
                        processingScheduled = true;
                        setImmediate$1(function() {
                            processingScheduled = false;
                            q.process();
                        });
                    }
                }
                function _next(tasks) {
                    return function(err) {
                        numRunning -= 1;
                        for (var i = 0, l = tasks.length; i < l; i++) {
                            var task = tasks[i];
                            var index = baseIndexOf(workersList, task, 0);
                            if (index === 0) {
                                workersList.shift();
                            } else if (index > 0) {
                                workersList.splice(index, 1);
                            }
                            task.callback.apply(task, arguments);
                            if (err != null) {
                                q.error(err, task.data);
                            }
                        }
                        if (numRunning <= q.concurrency - q.buffer) {
                            q.unsaturated();
                        }
                        if (q.idle()) {
                            q.drain();
                        }
                        q.process();
                    };
                }
                var isProcessing = false;
                var q = {
                    _tasks: new DLL(),
                    concurrency,
                    payload,
                    saturated: noop,
                    unsaturated: noop,
                    buffer: concurrency / 4,
                    empty: noop,
                    drain: noop,
                    error: noop,
                    started: false,
                    paused: false,
                    push: function(data, callback) {
                        _insert(data, false, callback);
                    },
                    kill: function() {
                        q.drain = noop;
                        q._tasks.empty();
                    },
                    unshift: function(data, callback) {
                        _insert(data, true, callback);
                    },
                    remove: function(testFn) {
                        q._tasks.remove(testFn);
                    },
                    process: function() {
                        if (isProcessing) {
                            return;
                        }
                        isProcessing = true;
                        while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                            var tasks = [], data = [];
                            var l = q._tasks.length;
                            if (q.payload) l = Math.min(l, q.payload);
                            for (var i = 0; i < l; i++) {
                                var node = q._tasks.shift();
                                tasks.push(node);
                                workersList.push(node);
                                data.push(node.data);
                            }
                            numRunning += 1;
                            if (q._tasks.length === 0) {
                                q.empty();
                            }
                            if (numRunning === q.concurrency) {
                                q.saturated();
                            }
                            var cb = onlyOnce(_next(tasks));
                            _worker(data, cb);
                        }
                        isProcessing = false;
                    },
                    length: function() {
                        return q._tasks.length;
                    },
                    running: function() {
                        return numRunning;
                    },
                    workersList: function() {
                        return workersList;
                    },
                    idle: function() {
                        return q._tasks.length + numRunning === 0;
                    },
                    pause: function() {
                        q.paused = true;
                    },
                    resume: function() {
                        if (q.paused === false) {
                            return;
                        }
                        q.paused = false;
                        setImmediate$1(q.process);
                    }
                };
                return q;
            }
            function cargo(worker, payload) {
                return queue(worker, 1, payload);
            }
            var eachOfSeries = doLimit(eachOfLimit, 1);
            function reduce(coll, memo, iteratee, callback) {
                callback = once(callback || noop);
                var _iteratee = wrapAsync(iteratee);
                eachOfSeries(coll, function(x, i, callback) {
                    _iteratee(memo, x, function(err, v) {
                        memo = v;
                        callback(err);
                    });
                }, function(err) {
                    callback(err, memo);
                });
            }
            function seq() {
                var _functions = arrayMap(arguments, wrapAsync);
                return function() {
                    var args = slice(arguments);
                    var that = this;
                    var cb = args[args.length - 1];
                    if (typeof cb == "function") {
                        args.pop();
                    } else {
                        cb = noop;
                    }
                    reduce(_functions, args, function(newargs, fn, cb) {
                        fn.apply(that, newargs.concat(function(err) {
                            var nextargs = slice(arguments, 1);
                            cb(err, nextargs);
                        }));
                    }, function(err, results) {
                        cb.apply(that, [ err ].concat(results));
                    });
                };
            }
            var compose = function() {
                return seq.apply(null, slice(arguments).reverse());
            };
            var _concat = Array.prototype.concat;
            var concatLimit = function(coll, limit, iteratee, callback) {
                callback = callback || noop;
                var _iteratee = wrapAsync(iteratee);
                mapLimit(coll, limit, function(val, callback) {
                    _iteratee(val, function(err) {
                        if (err) return callback(err);
                        return callback(null, slice(arguments, 1));
                    });
                }, function(err, mapResults) {
                    var result = [];
                    for (var i = 0; i < mapResults.length; i++) {
                        if (mapResults[i]) {
                            result = _concat.apply(result, mapResults[i]);
                        }
                    }
                    return callback(err, result);
                });
            };
            var concat = doLimit(concatLimit, Infinity);
            var concatSeries = doLimit(concatLimit, 1);
            var constant = function() {
                var values = slice(arguments);
                var args = [ null ].concat(values);
                return function() {
                    var callback = arguments[arguments.length - 1];
                    return callback.apply(this, args);
                };
            };
            function identity(value) {
                return value;
            }
            function _createTester(check, getResult) {
                return function(eachfn, arr, iteratee, cb) {
                    cb = cb || noop;
                    var testPassed = false;
                    var testResult;
                    eachfn(arr, function(value, _, callback) {
                        iteratee(value, function(err, result) {
                            if (err) {
                                callback(err);
                            } else if (check(result) && !testResult) {
                                testPassed = true;
                                testResult = getResult(true, value);
                                callback(null, breakLoop);
                            } else {
                                callback();
                            }
                        });
                    }, function(err) {
                        if (err) {
                            cb(err);
                        } else {
                            cb(null, testPassed ? testResult : getResult(false));
                        }
                    });
                };
            }
            function _findGetResult(v, x) {
                return x;
            }
            var detect = doParallel(_createTester(identity, _findGetResult));
            var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));
            var detectSeries = doLimit(detectLimit, 1);
            function consoleFunc(name) {
                return function(fn) {
                    var args = slice(arguments, 1);
                    args.push(function(err) {
                        var args = slice(arguments, 1);
                        if (typeof console === "object") {
                            if (err) {
                                if (console.error) {
                                    console.error(err);
                                }
                            } else if (console[name]) {
                                arrayEach(args, function(x) {
                                    console[name](x);
                                });
                            }
                        }
                    });
                    wrapAsync(fn).apply(null, args);
                };
            }
            var dir = consoleFunc("dir");
            function doDuring(fn, test, callback) {
                callback = onlyOnce(callback || noop);
                var _fn = wrapAsync(fn);
                var _test = wrapAsync(test);
                function next(err) {
                    if (err) return callback(err);
                    var args = slice(arguments, 1);
                    args.push(check);
                    _test.apply(this, args);
                }
                function check(err, truth) {
                    if (err) return callback(err);
                    if (!truth) return callback(null);
                    _fn(next);
                }
                check(null, true);
            }
            function doWhilst(iteratee, test, callback) {
                callback = onlyOnce(callback || noop);
                var _iteratee = wrapAsync(iteratee);
                var next = function(err) {
                    if (err) return callback(err);
                    var args = slice(arguments, 1);
                    if (test.apply(this, args)) return _iteratee(next);
                    callback.apply(null, [ null ].concat(args));
                };
                _iteratee(next);
            }
            function doUntil(iteratee, test, callback) {
                doWhilst(iteratee, function() {
                    return !test.apply(this, arguments);
                }, callback);
            }
            function during(test, fn, callback) {
                callback = onlyOnce(callback || noop);
                var _fn = wrapAsync(fn);
                var _test = wrapAsync(test);
                function next(err) {
                    if (err) return callback(err);
                    _test(check);
                }
                function check(err, truth) {
                    if (err) return callback(err);
                    if (!truth) return callback(null);
                    _fn(next);
                }
                _test(check);
            }
            function _withoutIndex(iteratee) {
                return function(value, index, callback) {
                    return iteratee(value, callback);
                };
            }
            function eachLimit(coll, iteratee, callback) {
                eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
            }
            function eachLimit$1(coll, limit, iteratee, callback) {
                _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
            }
            var eachSeries = doLimit(eachLimit$1, 1);
            function ensureAsync(fn) {
                if (isAsync(fn)) return fn;
                return initialParams(function(args, callback) {
                    var sync = true;
                    args.push(function() {
                        var innerArgs = arguments;
                        if (sync) {
                            setImmediate$1(function() {
                                callback.apply(null, innerArgs);
                            });
                        } else {
                            callback.apply(null, innerArgs);
                        }
                    });
                    fn.apply(this, args);
                    sync = false;
                });
            }
            function notId(v) {
                return !v;
            }
            var every = doParallel(_createTester(notId, notId));
            var everyLimit = doParallelLimit(_createTester(notId, notId));
            var everySeries = doLimit(everyLimit, 1);
            function baseProperty(key) {
                return function(object) {
                    return object == null ? undefined : object[key];
                };
            }
            function filterArray(eachfn, arr, iteratee, callback) {
                var truthValues = new Array(arr.length);
                eachfn(arr, function(x, index, callback) {
                    iteratee(x, function(err, v) {
                        truthValues[index] = !!v;
                        callback(err);
                    });
                }, function(err) {
                    if (err) return callback(err);
                    var results = [];
                    for (var i = 0; i < arr.length; i++) {
                        if (truthValues[i]) results.push(arr[i]);
                    }
                    callback(null, results);
                });
            }
            function filterGeneric(eachfn, coll, iteratee, callback) {
                var results = [];
                eachfn(coll, function(x, index, callback) {
                    iteratee(x, function(err, v) {
                        if (err) {
                            callback(err);
                        } else {
                            if (v) {
                                results.push({
                                    index,
                                    value: x
                                });
                            }
                            callback();
                        }
                    });
                }, function(err) {
                    if (err) {
                        callback(err);
                    } else {
                        callback(null, arrayMap(results.sort(function(a, b) {
                            return a.index - b.index;
                        }), baseProperty("value")));
                    }
                });
            }
            function _filter(eachfn, coll, iteratee, callback) {
                var filter = isArrayLike(coll) ? filterArray : filterGeneric;
                filter(eachfn, coll, wrapAsync(iteratee), callback || noop);
            }
            var filter = doParallel(_filter);
            var filterLimit = doParallelLimit(_filter);
            var filterSeries = doLimit(filterLimit, 1);
            function forever(fn, errback) {
                var done = onlyOnce(errback || noop);
                var task = wrapAsync(ensureAsync(fn));
                function next(err) {
                    if (err) return done(err);
                    task(next);
                }
                next();
            }
            var groupByLimit = function(coll, limit, iteratee, callback) {
                callback = callback || noop;
                var _iteratee = wrapAsync(iteratee);
                mapLimit(coll, limit, function(val, callback) {
                    _iteratee(val, function(err, key) {
                        if (err) return callback(err);
                        return callback(null, {
                            key,
                            val
                        });
                    });
                }, function(err, mapResults) {
                    var result = {};
                    var hasOwnProperty = Object.prototype.hasOwnProperty;
                    for (var i = 0; i < mapResults.length; i++) {
                        if (mapResults[i]) {
                            var key = mapResults[i].key;
                            var val = mapResults[i].val;
                            if (hasOwnProperty.call(result, key)) {
                                result[key].push(val);
                            } else {
                                result[key] = [ val ];
                            }
                        }
                    }
                    return callback(err, result);
                });
            };
            var groupBy = doLimit(groupByLimit, Infinity);
            var groupBySeries = doLimit(groupByLimit, 1);
            var log = consoleFunc("log");
            function mapValuesLimit(obj, limit, iteratee, callback) {
                callback = once(callback || noop);
                var newObj = {};
                var _iteratee = wrapAsync(iteratee);
                eachOfLimit(obj, limit, function(val, key, next) {
                    _iteratee(val, key, function(err, result) {
                        if (err) return next(err);
                        newObj[key] = result;
                        next();
                    });
                }, function(err) {
                    callback(err, newObj);
                });
            }
            var mapValues = doLimit(mapValuesLimit, Infinity);
            var mapValuesSeries = doLimit(mapValuesLimit, 1);
            function has(obj, key) {
                return key in obj;
            }
            function memoize(fn, hasher) {
                var memo = Object.create(null);
                var queues = Object.create(null);
                hasher = hasher || identity;
                var _fn = wrapAsync(fn);
                var memoized = initialParams(function memoized(args, callback) {
                    var key = hasher.apply(null, args);
                    if (has(memo, key)) {
                        setImmediate$1(function() {
                            callback.apply(null, memo[key]);
                        });
                    } else if (has(queues, key)) {
                        queues[key].push(callback);
                    } else {
                        queues[key] = [ callback ];
                        _fn.apply(null, args.concat(function() {
                            var args = slice(arguments);
                            memo[key] = args;
                            var q = queues[key];
                            delete queues[key];
                            for (var i = 0, l = q.length; i < l; i++) {
                                q[i].apply(null, args);
                            }
                        }));
                    }
                });
                memoized.memo = memo;
                memoized.unmemoized = fn;
                return memoized;
            }
            var _defer$1;
            if (hasNextTick) {
                _defer$1 = process.nextTick;
            } else if (hasSetImmediate) {
                _defer$1 = setImmediate;
            } else {
                _defer$1 = fallback;
            }
            var nextTick = wrap(_defer$1);
            function _parallel(eachfn, tasks, callback) {
                callback = callback || noop;
                var results = isArrayLike(tasks) ? [] : {};
                eachfn(tasks, function(task, key, callback) {
                    wrapAsync(task)(function(err, result) {
                        if (arguments.length > 2) {
                            result = slice(arguments, 1);
                        }
                        results[key] = result;
                        callback(err);
                    });
                }, function(err) {
                    callback(err, results);
                });
            }
            function parallelLimit(tasks, callback) {
                _parallel(eachOf, tasks, callback);
            }
            function parallelLimit$1(tasks, limit, callback) {
                _parallel(_eachOfLimit(limit), tasks, callback);
            }
            var queue$1 = function(worker, concurrency) {
                var _worker = wrapAsync(worker);
                return queue(function(items, cb) {
                    _worker(items[0], cb);
                }, concurrency, 1);
            };
            var priorityQueue = function(worker, concurrency) {
                var q = queue$1(worker, concurrency);
                q.push = function(data, priority, callback) {
                    if (callback == null) callback = noop;
                    if (typeof callback !== "function") {
                        throw new Error("task callback must be a function");
                    }
                    q.started = true;
                    if (!isArray(data)) {
                        data = [ data ];
                    }
                    if (data.length === 0) {
                        return setImmediate$1(function() {
                            q.drain();
                        });
                    }
                    priority = priority || 0;
                    var nextNode = q._tasks.head;
                    while (nextNode && priority >= nextNode.priority) {
                        nextNode = nextNode.next;
                    }
                    for (var i = 0, l = data.length; i < l; i++) {
                        var item = {
                            data: data[i],
                            priority,
                            callback
                        };
                        if (nextNode) {
                            q._tasks.insertBefore(nextNode, item);
                        } else {
                            q._tasks.push(item);
                        }
                    }
                    setImmediate$1(q.process);
                };
                delete q.unshift;
                return q;
            };
            function race(tasks, callback) {
                callback = once(callback || noop);
                if (!isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
                if (!tasks.length) return callback();
                for (var i = 0, l = tasks.length; i < l; i++) {
                    wrapAsync(tasks[i])(callback);
                }
            }
            function reduceRight(array, memo, iteratee, callback) {
                var reversed = slice(array).reverse();
                reduce(reversed, memo, iteratee, callback);
            }
            function reflect(fn) {
                var _fn = wrapAsync(fn);
                return initialParams(function reflectOn(args, reflectCallback) {
                    args.push(function callback(error, cbArg) {
                        if (error) {
                            reflectCallback(null, {
                                error
                            });
                        } else {
                            var value;
                            if (arguments.length <= 2) {
                                value = cbArg;
                            } else {
                                value = slice(arguments, 1);
                            }
                            reflectCallback(null, {
                                value
                            });
                        }
                    });
                    return _fn.apply(this, args);
                });
            }
            function reflectAll(tasks) {
                var results;
                if (isArray(tasks)) {
                    results = arrayMap(tasks, reflect);
                } else {
                    results = {};
                    baseForOwn(tasks, function(task, key) {
                        results[key] = reflect.call(this, task);
                    });
                }
                return results;
            }
            function reject$1(eachfn, arr, iteratee, callback) {
                _filter(eachfn, arr, function(value, cb) {
                    iteratee(value, function(err, v) {
                        cb(err, !v);
                    });
                }, callback);
            }
            var reject = doParallel(reject$1);
            var rejectLimit = doParallelLimit(reject$1);
            var rejectSeries = doLimit(rejectLimit, 1);
            function constant$1(value) {
                return function() {
                    return value;
                };
            }
            function retry(opts, task, callback) {
                var DEFAULT_TIMES = 5;
                var DEFAULT_INTERVAL = 0;
                var options = {
                    times: DEFAULT_TIMES,
                    intervalFunc: constant$1(DEFAULT_INTERVAL)
                };
                function parseTimes(acc, t) {
                    if (typeof t === "object") {
                        acc.times = +t.times || DEFAULT_TIMES;
                        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
                        acc.errorFilter = t.errorFilter;
                    } else if (typeof t === "number" || typeof t === "string") {
                        acc.times = +t || DEFAULT_TIMES;
                    } else {
                        throw new Error("Invalid arguments for async.retry");
                    }
                }
                if (arguments.length < 3 && typeof opts === "function") {
                    callback = task || noop;
                    task = opts;
                } else {
                    parseTimes(options, opts);
                    callback = callback || noop;
                }
                if (typeof task !== "function") {
                    throw new Error("Invalid arguments for async.retry");
                }
                var _task = wrapAsync(task);
                var attempt = 1;
                function retryAttempt() {
                    _task(function(err) {
                        if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
                            setTimeout(retryAttempt, options.intervalFunc(attempt));
                        } else {
                            callback.apply(null, arguments);
                        }
                    });
                }
                retryAttempt();
            }
            var retryable = function(opts, task) {
                if (!task) {
                    task = opts;
                    opts = null;
                }
                var _task = wrapAsync(task);
                return initialParams(function(args, callback) {
                    function taskFn(cb) {
                        _task.apply(null, args.concat(cb));
                    }
                    if (opts) retry(opts, taskFn, callback); else retry(taskFn, callback);
                });
            };
            function series(tasks, callback) {
                _parallel(eachOfSeries, tasks, callback);
            }
            var some = doParallel(_createTester(Boolean, identity));
            var someLimit = doParallelLimit(_createTester(Boolean, identity));
            var someSeries = doLimit(someLimit, 1);
            function sortBy(coll, iteratee, callback) {
                var _iteratee = wrapAsync(iteratee);
                map(coll, function(x, callback) {
                    _iteratee(x, function(err, criteria) {
                        if (err) return callback(err);
                        callback(null, {
                            value: x,
                            criteria
                        });
                    });
                }, function(err, results) {
                    if (err) return callback(err);
                    callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
                });
                function comparator(left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                }
            }
            function timeout(asyncFn, milliseconds, info) {
                var fn = wrapAsync(asyncFn);
                return initialParams(function(args, callback) {
                    var timedOut = false;
                    var timer;
                    function timeoutCallback() {
                        var name = asyncFn.name || "anonymous";
                        var error = new Error('Callback function "' + name + '" timed out.');
                        error.code = "ETIMEDOUT";
                        if (info) {
                            error.info = info;
                        }
                        timedOut = true;
                        callback(error);
                    }
                    args.push(function() {
                        if (!timedOut) {
                            callback.apply(null, arguments);
                            clearTimeout(timer);
                        }
                    });
                    timer = setTimeout(timeoutCallback, milliseconds);
                    fn.apply(null, args);
                });
            }
            var nativeCeil = Math.ceil;
            var nativeMax = Math.max;
            function baseRange(start, end, step, fromRight) {
                var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                while (length--) {
                    result[fromRight ? length : ++index] = start;
                    start += step;
                }
                return result;
            }
            function timeLimit(count, limit, iteratee, callback) {
                var _iteratee = wrapAsync(iteratee);
                mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
            }
            var times = doLimit(timeLimit, Infinity);
            var timesSeries = doLimit(timeLimit, 1);
            function transform(coll, accumulator, iteratee, callback) {
                if (arguments.length <= 3) {
                    callback = iteratee;
                    iteratee = accumulator;
                    accumulator = isArray(coll) ? [] : {};
                }
                callback = once(callback || noop);
                var _iteratee = wrapAsync(iteratee);
                eachOf(coll, function(v, k, cb) {
                    _iteratee(accumulator, v, k, cb);
                }, function(err) {
                    callback(err, accumulator);
                });
            }
            function tryEach(tasks, callback) {
                var error = null;
                var result;
                callback = callback || noop;
                eachSeries(tasks, function(task, callback) {
                    wrapAsync(task)(function(err, res) {
                        if (arguments.length > 2) {
                            result = slice(arguments, 1);
                        } else {
                            result = res;
                        }
                        error = err;
                        callback(!err);
                    });
                }, function() {
                    callback(error, result);
                });
            }
            function unmemoize(fn) {
                return function() {
                    return (fn.unmemoized || fn).apply(null, arguments);
                };
            }
            function whilst(test, iteratee, callback) {
                callback = onlyOnce(callback || noop);
                var _iteratee = wrapAsync(iteratee);
                if (!test()) return callback(null);
                var next = function(err) {
                    if (err) return callback(err);
                    if (test()) return _iteratee(next);
                    var args = slice(arguments, 1);
                    callback.apply(null, [ null ].concat(args));
                };
                _iteratee(next);
            }
            function until(test, iteratee, callback) {
                whilst(function() {
                    return !test.apply(this, arguments);
                }, iteratee, callback);
            }
            var waterfall = function(tasks, callback) {
                callback = once(callback || noop);
                if (!isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
                if (!tasks.length) return callback();
                var taskIndex = 0;
                function nextTask(args) {
                    var task = wrapAsync(tasks[taskIndex++]);
                    args.push(onlyOnce(next));
                    task.apply(null, args);
                }
                function next(err) {
                    if (err || taskIndex === tasks.length) {
                        return callback.apply(null, arguments);
                    }
                    nextTask(slice(arguments, 1));
                }
                nextTask([]);
            };
            var index = {
                apply,
                applyEach,
                applyEachSeries,
                asyncify,
                auto,
                autoInject,
                cargo,
                compose,
                concat,
                concatLimit,
                concatSeries,
                constant,
                detect,
                detectLimit,
                detectSeries,
                dir,
                doDuring,
                doUntil,
                doWhilst,
                during,
                each: eachLimit,
                eachLimit: eachLimit$1,
                eachOf,
                eachOfLimit,
                eachOfSeries,
                eachSeries,
                ensureAsync,
                every,
                everyLimit,
                everySeries,
                filter,
                filterLimit,
                filterSeries,
                forever,
                groupBy,
                groupByLimit,
                groupBySeries,
                log,
                map,
                mapLimit,
                mapSeries,
                mapValues,
                mapValuesLimit,
                mapValuesSeries,
                memoize,
                nextTick,
                parallel: parallelLimit,
                parallelLimit: parallelLimit$1,
                priorityQueue,
                queue: queue$1,
                race,
                reduce,
                reduceRight,
                reflect,
                reflectAll,
                reject,
                rejectLimit,
                rejectSeries,
                retry,
                retryable,
                seq,
                series,
                setImmediate: setImmediate$1,
                some,
                someLimit,
                someSeries,
                sortBy,
                timeout,
                times,
                timesLimit: timeLimit,
                timesSeries,
                transform,
                tryEach,
                unmemoize,
                until,
                waterfall,
                whilst,
                all: every,
                allLimit: everyLimit,
                allSeries: everySeries,
                any: some,
                anyLimit: someLimit,
                anySeries: someSeries,
                find: detect,
                findLimit: detectLimit,
                findSeries: detectSeries,
                forEach: eachLimit,
                forEachSeries: eachSeries,
                forEachLimit: eachLimit$1,
                forEachOf: eachOf,
                forEachOfSeries: eachOfSeries,
                forEachOfLimit: eachOfLimit,
                inject: reduce,
                foldl: reduce,
                foldr: reduceRight,
                select: filter,
                selectLimit: filterLimit,
                selectSeries: filterSeries,
                wrapSync: asyncify
            };
            exports["default"] = index;
            exports.apply = apply;
            exports.applyEach = applyEach;
            exports.applyEachSeries = applyEachSeries;
            exports.asyncify = asyncify;
            exports.auto = auto;
            exports.autoInject = autoInject;
            exports.cargo = cargo;
            exports.compose = compose;
            exports.concat = concat;
            exports.concatLimit = concatLimit;
            exports.concatSeries = concatSeries;
            exports.constant = constant;
            exports.detect = detect;
            exports.detectLimit = detectLimit;
            exports.detectSeries = detectSeries;
            exports.dir = dir;
            exports.doDuring = doDuring;
            exports.doUntil = doUntil;
            exports.doWhilst = doWhilst;
            exports.during = during;
            exports.each = eachLimit;
            exports.eachLimit = eachLimit$1;
            exports.eachOf = eachOf;
            exports.eachOfLimit = eachOfLimit;
            exports.eachOfSeries = eachOfSeries;
            exports.eachSeries = eachSeries;
            exports.ensureAsync = ensureAsync;
            exports.every = every;
            exports.everyLimit = everyLimit;
            exports.everySeries = everySeries;
            exports.filter = filter;
            exports.filterLimit = filterLimit;
            exports.filterSeries = filterSeries;
            exports.forever = forever;
            exports.groupBy = groupBy;
            exports.groupByLimit = groupByLimit;
            exports.groupBySeries = groupBySeries;
            exports.log = log;
            exports.map = map;
            exports.mapLimit = mapLimit;
            exports.mapSeries = mapSeries;
            exports.mapValues = mapValues;
            exports.mapValuesLimit = mapValuesLimit;
            exports.mapValuesSeries = mapValuesSeries;
            exports.memoize = memoize;
            exports.nextTick = nextTick;
            exports.parallel = parallelLimit;
            exports.parallelLimit = parallelLimit$1;
            exports.priorityQueue = priorityQueue;
            exports.queue = queue$1;
            exports.race = race;
            exports.reduce = reduce;
            exports.reduceRight = reduceRight;
            exports.reflect = reflect;
            exports.reflectAll = reflectAll;
            exports.reject = reject;
            exports.rejectLimit = rejectLimit;
            exports.rejectSeries = rejectSeries;
            exports.retry = retry;
            exports.retryable = retryable;
            exports.seq = seq;
            exports.series = series;
            exports.setImmediate = setImmediate$1;
            exports.some = some;
            exports.someLimit = someLimit;
            exports.someSeries = someSeries;
            exports.sortBy = sortBy;
            exports.timeout = timeout;
            exports.times = times;
            exports.timesLimit = timeLimit;
            exports.timesSeries = timesSeries;
            exports.transform = transform;
            exports.tryEach = tryEach;
            exports.unmemoize = unmemoize;
            exports.until = until;
            exports.waterfall = waterfall;
            exports.whilst = whilst;
            exports.all = every;
            exports.allLimit = everyLimit;
            exports.allSeries = everySeries;
            exports.any = some;
            exports.anyLimit = someLimit;
            exports.anySeries = someSeries;
            exports.find = detect;
            exports.findLimit = detectLimit;
            exports.findSeries = detectSeries;
            exports.forEach = eachLimit;
            exports.forEachSeries = eachSeries;
            exports.forEachLimit = eachLimit$1;
            exports.forEachOf = eachOf;
            exports.forEachOfSeries = eachOfSeries;
            exports.forEachOfLimit = eachOfLimit;
            exports.inject = reduce;
            exports.foldl = reduce;
            exports.foldr = reduceRight;
            exports.select = filter;
            exports.selectLimit = filterLimit;
            exports.selectSeries = filterSeries;
            exports.wrapSync = asyncify;
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
        });
    }).call(this, __webpack_require__(151).setImmediate, __webpack_require__(13), __webpack_require__(12), __webpack_require__(46)(module));
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _async = __webpack_require__(264);
    var _async2 = _interopRequireDefault(_async);
    var _mnid = __webpack_require__(55);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var UportSubprovider = function() {
        function UportSubprovider(_ref) {
            var _this = this;
            var requestAddress = _ref.requestAddress, sendTransaction = _ref.sendTransaction, provider = _ref.provider, networkId = _ref.networkId;
            _classCallCheck(this, UportSubprovider);
            var self = this;
            this.provider = provider;
            this.networkId = networkId;
            this.getAddress = function(cb) {
                if (self.address) return cb(null, self.address);
                requestAddress().then(function(address) {
                    var errorMatch = new Error("Address/Account received does not match the network your provider is configured for");
                    _this.setAccount(address) ? cb(null, self.address) : cb(errorMatch);
                }, function(error) {
                    return cb(error);
                });
            };
            this.sendTransaction = function(txobj, cb) {
                sendTransaction(txobj).then(function(address) {
                    return cb(null, address);
                }, function(error) {
                    return cb(error);
                });
            };
        }
        _createClass(UportSubprovider, [ {
            key: "setAccount",
            value: function setAccount(address) {
                if (this.networkId && (0, _mnid.isMNID)(address)) {
                    var mnid = (0, _mnid.decode)(address);
                    if (this.networkId === mnid.network) {
                        this.address = mnid.address;
                        return true;
                    }
                    return false;
                }
                this.address = (0, _mnid.isMNID)(address) ? (0, _mnid.decode)(address).address : address;
                return true;
            }
        }, {
            key: "send",
            value: function send(payload) {
                throw new Error("Uport Web3 SubProvider does not support synchronous requests.");
            }
        }, {
            key: "sendAsync",
            value: function sendAsync(payload, callback) {
                var self = this;
                var respond = function respond(error, result) {
                    if (error) {
                        callback({
                            id: payload.id,
                            jsonrpc: "2.0",
                            error: error.message
                        });
                    } else {
                        callback(null, {
                            id: payload.id,
                            jsonrpc: "2.0",
                            result
                        });
                    }
                };
                if (Array.isArray(payload)) {
                    _async2.default.map(payload, self.sendAsync.bind(self), callback);
                    return;
                }
                switch (payload.method) {
                  case "eth_coinbase":
                    return self.getAddress(respond);

                  case "eth_accounts":
                    return self.getAddress(function(error, address) {
                        respond(error, [ address ]);
                    });

                  case "eth_sendTransaction":
                    var txParams = payload.params[0];
                    return self.sendTransaction(txParams, function(err, tx) {
                        respond(err, tx);
                    });

                  default:
                    self.provider.sendAsync(payload, callback);
                }
            }
        } ]);
        return UportSubprovider;
    }();
    exports.default = UportSubprovider;
}, function(module, exports, __webpack_require__) {
    var isHexPrefixed = __webpack_require__(109);
    module.exports = function stripHexPrefix(str) {
        if (typeof str !== "string") {
            return str;
        }
        return isHexPrefixed(str) ? str.slice(2) : str;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var isHexPrefixed = __webpack_require__(109);
        var stripHexPrefix = __webpack_require__(266);
        function padToEven(value) {
            var a = value;
            if (typeof a !== "string") {
                throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a + ", while padToEven.");
            }
            if (a.length % 2) {
                a = "0" + a;
            }
            return a;
        }
        function intToHex(i) {
            var hex = i.toString(16);
            return "0x" + padToEven(hex);
        }
        function intToBuffer(i) {
            var hex = intToHex(i);
            return new Buffer(hex.slice(2), "hex");
        }
        function getBinarySize(str) {
            if (typeof str !== "string") {
                throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
            }
            return Buffer.byteLength(str, "utf8");
        }
        function arrayContainsArray(superset, subset, some) {
            if (Array.isArray(superset) !== true) {
                throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
            }
            if (Array.isArray(subset) !== true) {
                throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
            }
            return subset[Boolean(some) && "some" || "every"](function(value) {
                return superset.indexOf(value) >= 0;
            });
        }
        function toUtf8(hex) {
            var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, "")), "hex");
            return bufferValue.toString("utf8");
        }
        function toAscii(hex) {
            var str = "";
            var i = 0, l = hex.length;
            if (hex.substring(0, 2) === "0x") {
                i = 2;
            }
            for (;i < l; i += 2) {
                var code = parseInt(hex.substr(i, 2), 16);
                str += String.fromCharCode(code);
            }
            return str;
        }
        function fromUtf8(stringValue) {
            var str = new Buffer(stringValue, "utf8");
            return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
        }
        function fromAscii(stringValue) {
            var hex = "";
            for (var i = 0; i < stringValue.length; i++) {
                var code = stringValue.charCodeAt(i);
                var n = code.toString(16);
                hex += n.length < 2 ? "0" + n : n;
            }
            return "0x" + hex;
        }
        function getKeys(params, key, allowEmpty) {
            if (!Array.isArray(params)) {
                throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
            }
            if (typeof key !== "string") {
                throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key + "'.");
            }
            var result = [];
            for (var i = 0; i < params.length; i++) {
                var value = params[i][key];
                if (allowEmpty && !value) {
                    value = "";
                } else if (typeof value !== "string") {
                    throw new Error("invalid abi");
                }
                result.push(value);
            }
            return result;
        }
        function isHexString(value, length) {
            if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
                return false;
            }
            if (length && value.length !== 2 + 2 * length) {
                return false;
            }
            return true;
        }
        module.exports = {
            arrayContainsArray,
            intToBuffer,
            getBinarySize,
            isHexPrefixed,
            stripHexPrefix,
            padToEven,
            intToHex,
            fromAscii,
            fromUtf8,
            toAscii,
            toUtf8,
            getKeys,
            isHexString
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        } else {
            return Array.from(arr);
        }
    }
    var arrayContainsArray = __webpack_require__(267).arrayContainsArray;
    var hasTransactionObject = function hasTransactionObject(args) {
        var txObjectProperties = [ "from", "to", "data", "value", "gasPrice", "gas" ];
        if ((typeof args === "undefined" ? "undefined" : _typeof(args)) === "object" && Array.isArray(args) === true && args.length > 0) {
            if (_typeof(args[args.length - 1]) === "object" && (Object.keys(args[args.length - 1]).length === 0 || arrayContainsArray(Object.keys(args[args.length - 1]), txObjectProperties, true))) {
                return true;
            }
        }
        return false;
    };
    var getCallableMethodsFromABI = function getCallableMethodsFromABI(contractABI) {
        return contractABI.filter(function(json) {
            return (json.type === "function" || json.type === "event") && json.name.length > 0;
        });
    };
    var encodeMethodReadable = function encodeMethodReadable(methodObject, methodArgs) {
        var dataString = methodObject.name + "(";
        for (var i = 0; i < methodObject.inputs.length; i++) {
            var input = methodObject.inputs[i];
            var argString = input.type + " ";
            if (input.type === "string") {
                argString += "'" + methodArgs[i] + "'";
            } else if (input.type === ("bytes32" || "bytes")) {
                argString += "" + methodArgs[i];
            } else {
                argString += "" + methodArgs[i];
            }
            dataString += argString;
            if (methodObject.inputs.length - 1 !== i) {
                dataString += ", ";
            }
        }
        return dataString += ")";
    };
    var ContractFactory = function ContractFactory(extend) {
        return function(contractABI) {
            var output = {};
            output.at = function atContract(address) {
                function Contract() {
                    var self = this;
                    self.abi = contractABI || [];
                    self.address = address || "0x";
                    getCallableMethodsFromABI(contractABI).forEach(function(methodObject) {
                        self[methodObject.name] = function contractMethod() {
                            if (methodObject.constant === true) {
                                throw new Error("A call does not return the txobject, no transaction necessary.");
                            }
                            if (methodObject.type === "event") {
                                throw new Error("An event does not return the txobject, events not supported");
                            }
                            var providedTxObject = {};
                            var methodArgs = [].slice.call(arguments);
                            if (methodObject.type === "function") {
                                if (hasTransactionObject(methodArgs)) providedTxObject = methodArgs.pop();
                                var methodTxObject = Object.assign({}, providedTxObject, {
                                    to: self.address
                                });
                                methodTxObject.function = encodeMethodReadable(methodObject, methodArgs);
                                if (!extend) return methodTxObject;
                                var extendArgs = methodArgs.slice(methodObject.inputs.length);
                                return extend.apply(undefined, [ methodTxObject ].concat(_toConsumableArray(extendArgs)));
                            }
                        };
                    });
                }
                return new Contract();
            };
            return output;
        };
    };
    var buildRequestURI = function buildRequestURI(txObject) {
        return "me.uport:" + txObject.to + "?function=" + txObject.function;
    };
    var Contract = ContractFactory(buildRequestURI);
    exports.ContractFactory = ContractFactory;
    exports.Contract = Contract;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = SimpleSigner;
    var _jsontokens = __webpack_require__(86);
    function SimpleSigner(privateKey) {
        return function(data, callback) {
            var hash = _jsontokens.SECP256K1Client.createHash(data);
            var signature = _jsontokens.SECP256K1Client.signHash(hash, privateKey);
            callback(null, signature);
        };
    }
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        (function(root, f) {
            "use strict";
            if (typeof module !== "undefined" && module.exports) module.exports = f(); else if (root.nacl) root.nacl.util = f(); else {
                root.nacl = {};
                root.nacl.util = f();
            }
        })(this, function() {
            "use strict";
            var util = {};
            function validateBase64(s) {
                if (!/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s)) {
                    throw new TypeError("invalid encoding");
                }
            }
            util.decodeUTF8 = function(s) {
                if (typeof s !== "string") throw new TypeError("expected string");
                var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
                for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
                return b;
            };
            util.encodeUTF8 = function(arr) {
                var i, s = [];
                for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
                return decodeURIComponent(escape(s.join("")));
            };
            if (typeof atob === "undefined") {
                if (typeof Buffer.from !== "undefined") {
                    util.encodeBase64 = function(arr) {
                        return Buffer.from(arr).toString("base64");
                    };
                    util.decodeBase64 = function(s) {
                        validateBase64(s);
                        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, "base64"), 0));
                    };
                } else {
                    util.encodeBase64 = function(arr) {
                        return new Buffer(arr).toString("base64");
                    };
                    util.decodeBase64 = function(s) {
                        validateBase64(s);
                        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, "base64"), 0));
                    };
                }
            } else {
                util.encodeBase64 = function(arr) {
                    var i, s = [], len = arr.length;
                    for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
                    return btoa(s.join(""));
                };
                util.decodeBase64 = function(s) {
                    validateBase64(s);
                    var i, d = atob(s), b = new Uint8Array(d.length);
                    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
                    return b;
                };
            }
            return util;
        });
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    (function(nacl) {
        "use strict";
        var gf = function(init) {
            var i, r = new Float64Array(16);
            if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
            return r;
        };
        var randombytes = function() {
            throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([ 1 ]), _121665 = gf([ 56129, 1 ]), D = gf([ 30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995 ]), D2 = gf([ 61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222 ]), X = gf([ 54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553 ]), Y = gf([ 26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214 ]), I = gf([ 41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139 ]);
        function ts64(x, i, h, l) {
            x[i] = h >> 24 & 255;
            x[i + 1] = h >> 16 & 255;
            x[i + 2] = h >> 8 & 255;
            x[i + 3] = h & 255;
            x[i + 4] = l >> 24 & 255;
            x[i + 5] = l >> 16 & 255;
            x[i + 6] = l >> 8 & 255;
            x[i + 7] = l & 255;
        }
        function vn(x, xi, y, yi, n) {
            var i, d = 0;
            for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
            return (1 & d - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x, xi, y, yi) {
            return vn(x, xi, y, yi, 16);
        }
        function crypto_verify_32(x, xi, y, yi) {
            return vn(x, xi, y, yi, 32);
        }
        function core_salsa20(o, p, k, c) {
            var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
            var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
            for (var i = 0; i < 20; i += 2) {
                u = x0 + x12 | 0;
                x4 ^= u << 7 | u >>> 32 - 7;
                u = x4 + x0 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x4 | 0;
                x12 ^= u << 13 | u >>> 32 - 13;
                u = x12 + x8 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x1 | 0;
                x9 ^= u << 7 | u >>> 32 - 7;
                u = x9 + x5 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x9 | 0;
                x1 ^= u << 13 | u >>> 32 - 13;
                u = x1 + x13 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x6 | 0;
                x14 ^= u << 7 | u >>> 32 - 7;
                u = x14 + x10 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x14 | 0;
                x6 ^= u << 13 | u >>> 32 - 13;
                u = x6 + x2 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x11 | 0;
                x3 ^= u << 7 | u >>> 32 - 7;
                u = x3 + x15 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x3 | 0;
                x11 ^= u << 13 | u >>> 32 - 13;
                u = x11 + x7 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
                u = x0 + x3 | 0;
                x1 ^= u << 7 | u >>> 32 - 7;
                u = x1 + x0 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x1 | 0;
                x3 ^= u << 13 | u >>> 32 - 13;
                u = x3 + x2 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x4 | 0;
                x6 ^= u << 7 | u >>> 32 - 7;
                u = x6 + x5 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x6 | 0;
                x4 ^= u << 13 | u >>> 32 - 13;
                u = x4 + x7 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x9 | 0;
                x11 ^= u << 7 | u >>> 32 - 7;
                u = x11 + x10 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x11 | 0;
                x9 ^= u << 13 | u >>> 32 - 13;
                u = x9 + x8 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x14 | 0;
                x12 ^= u << 7 | u >>> 32 - 7;
                u = x12 + x15 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x12 | 0;
                x14 ^= u << 13 | u >>> 32 - 13;
                u = x14 + x13 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
            }
            x0 = x0 + j0 | 0;
            x1 = x1 + j1 | 0;
            x2 = x2 + j2 | 0;
            x3 = x3 + j3 | 0;
            x4 = x4 + j4 | 0;
            x5 = x5 + j5 | 0;
            x6 = x6 + j6 | 0;
            x7 = x7 + j7 | 0;
            x8 = x8 + j8 | 0;
            x9 = x9 + j9 | 0;
            x10 = x10 + j10 | 0;
            x11 = x11 + j11 | 0;
            x12 = x12 + j12 | 0;
            x13 = x13 + j13 | 0;
            x14 = x14 + j14 | 0;
            x15 = x15 + j15 | 0;
            o[0] = x0 >>> 0 & 255;
            o[1] = x0 >>> 8 & 255;
            o[2] = x0 >>> 16 & 255;
            o[3] = x0 >>> 24 & 255;
            o[4] = x1 >>> 0 & 255;
            o[5] = x1 >>> 8 & 255;
            o[6] = x1 >>> 16 & 255;
            o[7] = x1 >>> 24 & 255;
            o[8] = x2 >>> 0 & 255;
            o[9] = x2 >>> 8 & 255;
            o[10] = x2 >>> 16 & 255;
            o[11] = x2 >>> 24 & 255;
            o[12] = x3 >>> 0 & 255;
            o[13] = x3 >>> 8 & 255;
            o[14] = x3 >>> 16 & 255;
            o[15] = x3 >>> 24 & 255;
            o[16] = x4 >>> 0 & 255;
            o[17] = x4 >>> 8 & 255;
            o[18] = x4 >>> 16 & 255;
            o[19] = x4 >>> 24 & 255;
            o[20] = x5 >>> 0 & 255;
            o[21] = x5 >>> 8 & 255;
            o[22] = x5 >>> 16 & 255;
            o[23] = x5 >>> 24 & 255;
            o[24] = x6 >>> 0 & 255;
            o[25] = x6 >>> 8 & 255;
            o[26] = x6 >>> 16 & 255;
            o[27] = x6 >>> 24 & 255;
            o[28] = x7 >>> 0 & 255;
            o[29] = x7 >>> 8 & 255;
            o[30] = x7 >>> 16 & 255;
            o[31] = x7 >>> 24 & 255;
            o[32] = x8 >>> 0 & 255;
            o[33] = x8 >>> 8 & 255;
            o[34] = x8 >>> 16 & 255;
            o[35] = x8 >>> 24 & 255;
            o[36] = x9 >>> 0 & 255;
            o[37] = x9 >>> 8 & 255;
            o[38] = x9 >>> 16 & 255;
            o[39] = x9 >>> 24 & 255;
            o[40] = x10 >>> 0 & 255;
            o[41] = x10 >>> 8 & 255;
            o[42] = x10 >>> 16 & 255;
            o[43] = x10 >>> 24 & 255;
            o[44] = x11 >>> 0 & 255;
            o[45] = x11 >>> 8 & 255;
            o[46] = x11 >>> 16 & 255;
            o[47] = x11 >>> 24 & 255;
            o[48] = x12 >>> 0 & 255;
            o[49] = x12 >>> 8 & 255;
            o[50] = x12 >>> 16 & 255;
            o[51] = x12 >>> 24 & 255;
            o[52] = x13 >>> 0 & 255;
            o[53] = x13 >>> 8 & 255;
            o[54] = x13 >>> 16 & 255;
            o[55] = x13 >>> 24 & 255;
            o[56] = x14 >>> 0 & 255;
            o[57] = x14 >>> 8 & 255;
            o[58] = x14 >>> 16 & 255;
            o[59] = x14 >>> 24 & 255;
            o[60] = x15 >>> 0 & 255;
            o[61] = x15 >>> 8 & 255;
            o[62] = x15 >>> 16 & 255;
            o[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o, p, k, c) {
            var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
            var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
            for (var i = 0; i < 20; i += 2) {
                u = x0 + x12 | 0;
                x4 ^= u << 7 | u >>> 32 - 7;
                u = x4 + x0 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x4 | 0;
                x12 ^= u << 13 | u >>> 32 - 13;
                u = x12 + x8 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x1 | 0;
                x9 ^= u << 7 | u >>> 32 - 7;
                u = x9 + x5 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x9 | 0;
                x1 ^= u << 13 | u >>> 32 - 13;
                u = x1 + x13 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x6 | 0;
                x14 ^= u << 7 | u >>> 32 - 7;
                u = x14 + x10 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x14 | 0;
                x6 ^= u << 13 | u >>> 32 - 13;
                u = x6 + x2 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x11 | 0;
                x3 ^= u << 7 | u >>> 32 - 7;
                u = x3 + x15 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x3 | 0;
                x11 ^= u << 13 | u >>> 32 - 13;
                u = x11 + x7 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
                u = x0 + x3 | 0;
                x1 ^= u << 7 | u >>> 32 - 7;
                u = x1 + x0 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x1 | 0;
                x3 ^= u << 13 | u >>> 32 - 13;
                u = x3 + x2 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x4 | 0;
                x6 ^= u << 7 | u >>> 32 - 7;
                u = x6 + x5 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x6 | 0;
                x4 ^= u << 13 | u >>> 32 - 13;
                u = x4 + x7 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x9 | 0;
                x11 ^= u << 7 | u >>> 32 - 7;
                u = x11 + x10 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x11 | 0;
                x9 ^= u << 13 | u >>> 32 - 13;
                u = x9 + x8 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x14 | 0;
                x12 ^= u << 7 | u >>> 32 - 7;
                u = x12 + x15 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x12 | 0;
                x14 ^= u << 13 | u >>> 32 - 13;
                u = x14 + x13 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
            }
            o[0] = x0 >>> 0 & 255;
            o[1] = x0 >>> 8 & 255;
            o[2] = x0 >>> 16 & 255;
            o[3] = x0 >>> 24 & 255;
            o[4] = x5 >>> 0 & 255;
            o[5] = x5 >>> 8 & 255;
            o[6] = x5 >>> 16 & 255;
            o[7] = x5 >>> 24 & 255;
            o[8] = x10 >>> 0 & 255;
            o[9] = x10 >>> 8 & 255;
            o[10] = x10 >>> 16 & 255;
            o[11] = x10 >>> 24 & 255;
            o[12] = x15 >>> 0 & 255;
            o[13] = x15 >>> 8 & 255;
            o[14] = x15 >>> 16 & 255;
            o[15] = x15 >>> 24 & 255;
            o[16] = x6 >>> 0 & 255;
            o[17] = x6 >>> 8 & 255;
            o[18] = x6 >>> 16 & 255;
            o[19] = x6 >>> 24 & 255;
            o[20] = x7 >>> 0 & 255;
            o[21] = x7 >>> 8 & 255;
            o[22] = x7 >>> 16 & 255;
            o[23] = x7 >>> 24 & 255;
            o[24] = x8 >>> 0 & 255;
            o[25] = x8 >>> 8 & 255;
            o[26] = x8 >>> 16 & 255;
            o[27] = x8 >>> 24 & 255;
            o[28] = x9 >>> 0 & 255;
            o[29] = x9 >>> 8 & 255;
            o[30] = x9 >>> 16 & 255;
            o[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k, c) {
            core_salsa20(out, inp, k, c);
        }
        function crypto_core_hsalsa20(out, inp, k, c) {
            core_hsalsa20(out, inp, k, c);
        }
        var sigma = new Uint8Array([ 101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107 ]);
        function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
            var z = new Uint8Array(16), x = new Uint8Array(64);
            var u, i;
            for (i = 0; i < 16; i++) z[i] = 0;
            for (i = 0; i < 8; i++) z[i] = n[i];
            while (b >= 64) {
                crypto_core_salsa20(x, z, k, sigma);
                for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
                u = 1;
                for (i = 8; i < 16; i++) {
                    u = u + (z[i] & 255) | 0;
                    z[i] = u & 255;
                    u >>>= 8;
                }
                b -= 64;
                cpos += 64;
                mpos += 64;
            }
            if (b > 0) {
                crypto_core_salsa20(x, z, k, sigma);
                for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
            }
            return 0;
        }
        function crypto_stream_salsa20(c, cpos, b, n, k) {
            var z = new Uint8Array(16), x = new Uint8Array(64);
            var u, i;
            for (i = 0; i < 16; i++) z[i] = 0;
            for (i = 0; i < 8; i++) z[i] = n[i];
            while (b >= 64) {
                crypto_core_salsa20(x, z, k, sigma);
                for (i = 0; i < 64; i++) c[cpos + i] = x[i];
                u = 1;
                for (i = 8; i < 16; i++) {
                    u = u + (z[i] & 255) | 0;
                    z[i] = u & 255;
                    u >>>= 8;
                }
                b -= 64;
                cpos += 64;
            }
            if (b > 0) {
                crypto_core_salsa20(x, z, k, sigma);
                for (i = 0; i < b; i++) c[cpos + i] = x[i];
            }
            return 0;
        }
        function crypto_stream(c, cpos, d, n, k) {
            var s = new Uint8Array(32);
            crypto_core_hsalsa20(s, n, k, sigma);
            var sn = new Uint8Array(8);
            for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
            return crypto_stream_salsa20(c, cpos, d, sn, s);
        }
        function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
            var s = new Uint8Array(32);
            crypto_core_hsalsa20(s, n, k, sigma);
            var sn = new Uint8Array(8);
            for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
            return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
        }
        var poly1305 = function(key) {
            this.buffer = new Uint8Array(16);
            this.r = new Uint16Array(10);
            this.h = new Uint16Array(10);
            this.pad = new Uint16Array(8);
            this.leftover = 0;
            this.fin = 0;
            var t0, t1, t2, t3, t4, t5, t6, t7;
            t0 = key[0] & 255 | (key[1] & 255) << 8;
            this.r[0] = t0 & 8191;
            t1 = key[2] & 255 | (key[3] & 255) << 8;
            this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
            t2 = key[4] & 255 | (key[5] & 255) << 8;
            this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
            t3 = key[6] & 255 | (key[7] & 255) << 8;
            this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
            t4 = key[8] & 255 | (key[9] & 255) << 8;
            this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
            this.r[5] = t4 >>> 1 & 8190;
            t5 = key[10] & 255 | (key[11] & 255) << 8;
            this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
            t6 = key[12] & 255 | (key[13] & 255) << 8;
            this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
            t7 = key[14] & 255 | (key[15] & 255) << 8;
            this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
            this.r[9] = t7 >>> 5 & 127;
            this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
            this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
            this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
            this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
            this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
            this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
            this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
            this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m, mpos, bytes) {
            var hibit = this.fin ? 0 : 1 << 11;
            var t0, t1, t2, t3, t4, t5, t6, t7, c;
            var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
            var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
            var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
            while (bytes >= 16) {
                t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
                h0 += t0 & 8191;
                t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
                h1 += (t0 >>> 13 | t1 << 3) & 8191;
                t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
                h2 += (t1 >>> 10 | t2 << 6) & 8191;
                t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
                h3 += (t2 >>> 7 | t3 << 9) & 8191;
                t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
                h4 += (t3 >>> 4 | t4 << 12) & 8191;
                h5 += t4 >>> 1 & 8191;
                t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
                h6 += (t4 >>> 14 | t5 << 2) & 8191;
                t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
                h7 += (t5 >>> 11 | t6 << 5) & 8191;
                t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
                h8 += (t6 >>> 8 | t7 << 8) & 8191;
                h9 += t7 >>> 5 | hibit;
                c = 0;
                d0 = c;
                d0 += h0 * r0;
                d0 += h1 * (5 * r9);
                d0 += h2 * (5 * r8);
                d0 += h3 * (5 * r7);
                d0 += h4 * (5 * r6);
                c = d0 >>> 13;
                d0 &= 8191;
                d0 += h5 * (5 * r5);
                d0 += h6 * (5 * r4);
                d0 += h7 * (5 * r3);
                d0 += h8 * (5 * r2);
                d0 += h9 * (5 * r1);
                c += d0 >>> 13;
                d0 &= 8191;
                d1 = c;
                d1 += h0 * r1;
                d1 += h1 * r0;
                d1 += h2 * (5 * r9);
                d1 += h3 * (5 * r8);
                d1 += h4 * (5 * r7);
                c = d1 >>> 13;
                d1 &= 8191;
                d1 += h5 * (5 * r6);
                d1 += h6 * (5 * r5);
                d1 += h7 * (5 * r4);
                d1 += h8 * (5 * r3);
                d1 += h9 * (5 * r2);
                c += d1 >>> 13;
                d1 &= 8191;
                d2 = c;
                d2 += h0 * r2;
                d2 += h1 * r1;
                d2 += h2 * r0;
                d2 += h3 * (5 * r9);
                d2 += h4 * (5 * r8);
                c = d2 >>> 13;
                d2 &= 8191;
                d2 += h5 * (5 * r7);
                d2 += h6 * (5 * r6);
                d2 += h7 * (5 * r5);
                d2 += h8 * (5 * r4);
                d2 += h9 * (5 * r3);
                c += d2 >>> 13;
                d2 &= 8191;
                d3 = c;
                d3 += h0 * r3;
                d3 += h1 * r2;
                d3 += h2 * r1;
                d3 += h3 * r0;
                d3 += h4 * (5 * r9);
                c = d3 >>> 13;
                d3 &= 8191;
                d3 += h5 * (5 * r8);
                d3 += h6 * (5 * r7);
                d3 += h7 * (5 * r6);
                d3 += h8 * (5 * r5);
                d3 += h9 * (5 * r4);
                c += d3 >>> 13;
                d3 &= 8191;
                d4 = c;
                d4 += h0 * r4;
                d4 += h1 * r3;
                d4 += h2 * r2;
                d4 += h3 * r1;
                d4 += h4 * r0;
                c = d4 >>> 13;
                d4 &= 8191;
                d4 += h5 * (5 * r9);
                d4 += h6 * (5 * r8);
                d4 += h7 * (5 * r7);
                d4 += h8 * (5 * r6);
                d4 += h9 * (5 * r5);
                c += d4 >>> 13;
                d4 &= 8191;
                d5 = c;
                d5 += h0 * r5;
                d5 += h1 * r4;
                d5 += h2 * r3;
                d5 += h3 * r2;
                d5 += h4 * r1;
                c = d5 >>> 13;
                d5 &= 8191;
                d5 += h5 * r0;
                d5 += h6 * (5 * r9);
                d5 += h7 * (5 * r8);
                d5 += h8 * (5 * r7);
                d5 += h9 * (5 * r6);
                c += d5 >>> 13;
                d5 &= 8191;
                d6 = c;
                d6 += h0 * r6;
                d6 += h1 * r5;
                d6 += h2 * r4;
                d6 += h3 * r3;
                d6 += h4 * r2;
                c = d6 >>> 13;
                d6 &= 8191;
                d6 += h5 * r1;
                d6 += h6 * r0;
                d6 += h7 * (5 * r9);
                d6 += h8 * (5 * r8);
                d6 += h9 * (5 * r7);
                c += d6 >>> 13;
                d6 &= 8191;
                d7 = c;
                d7 += h0 * r7;
                d7 += h1 * r6;
                d7 += h2 * r5;
                d7 += h3 * r4;
                d7 += h4 * r3;
                c = d7 >>> 13;
                d7 &= 8191;
                d7 += h5 * r2;
                d7 += h6 * r1;
                d7 += h7 * r0;
                d7 += h8 * (5 * r9);
                d7 += h9 * (5 * r8);
                c += d7 >>> 13;
                d7 &= 8191;
                d8 = c;
                d8 += h0 * r8;
                d8 += h1 * r7;
                d8 += h2 * r6;
                d8 += h3 * r5;
                d8 += h4 * r4;
                c = d8 >>> 13;
                d8 &= 8191;
                d8 += h5 * r3;
                d8 += h6 * r2;
                d8 += h7 * r1;
                d8 += h8 * r0;
                d8 += h9 * (5 * r9);
                c += d8 >>> 13;
                d8 &= 8191;
                d9 = c;
                d9 += h0 * r9;
                d9 += h1 * r8;
                d9 += h2 * r7;
                d9 += h3 * r6;
                d9 += h4 * r5;
                c = d9 >>> 13;
                d9 &= 8191;
                d9 += h5 * r4;
                d9 += h6 * r3;
                d9 += h7 * r2;
                d9 += h8 * r1;
                d9 += h9 * r0;
                c += d9 >>> 13;
                d9 &= 8191;
                c = (c << 2) + c | 0;
                c = c + d0 | 0;
                d0 = c & 8191;
                c = c >>> 13;
                d1 += c;
                h0 = d0;
                h1 = d1;
                h2 = d2;
                h3 = d3;
                h4 = d4;
                h5 = d5;
                h6 = d6;
                h7 = d7;
                h8 = d8;
                h9 = d9;
                mpos += 16;
                bytes -= 16;
            }
            this.h[0] = h0;
            this.h[1] = h1;
            this.h[2] = h2;
            this.h[3] = h3;
            this.h[4] = h4;
            this.h[5] = h5;
            this.h[6] = h6;
            this.h[7] = h7;
            this.h[8] = h8;
            this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
            var g = new Uint16Array(10);
            var c, mask, f, i;
            if (this.leftover) {
                i = this.leftover;
                this.buffer[i++] = 1;
                for (;i < 16; i++) this.buffer[i] = 0;
                this.fin = 1;
                this.blocks(this.buffer, 0, 16);
            }
            c = this.h[1] >>> 13;
            this.h[1] &= 8191;
            for (i = 2; i < 10; i++) {
                this.h[i] += c;
                c = this.h[i] >>> 13;
                this.h[i] &= 8191;
            }
            this.h[0] += c * 5;
            c = this.h[0] >>> 13;
            this.h[0] &= 8191;
            this.h[1] += c;
            c = this.h[1] >>> 13;
            this.h[1] &= 8191;
            this.h[2] += c;
            g[0] = this.h[0] + 5;
            c = g[0] >>> 13;
            g[0] &= 8191;
            for (i = 1; i < 10; i++) {
                g[i] = this.h[i] + c;
                c = g[i] >>> 13;
                g[i] &= 8191;
            }
            g[9] -= 1 << 13;
            mask = (c ^ 1) - 1;
            for (i = 0; i < 10; i++) g[i] &= mask;
            mask = ~mask;
            for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
            this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
            this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
            this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
            this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
            this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
            this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
            this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
            this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
            f = this.h[0] + this.pad[0];
            this.h[0] = f & 65535;
            for (i = 1; i < 8; i++) {
                f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
                this.h[i] = f & 65535;
            }
            mac[macpos + 0] = this.h[0] >>> 0 & 255;
            mac[macpos + 1] = this.h[0] >>> 8 & 255;
            mac[macpos + 2] = this.h[1] >>> 0 & 255;
            mac[macpos + 3] = this.h[1] >>> 8 & 255;
            mac[macpos + 4] = this.h[2] >>> 0 & 255;
            mac[macpos + 5] = this.h[2] >>> 8 & 255;
            mac[macpos + 6] = this.h[3] >>> 0 & 255;
            mac[macpos + 7] = this.h[3] >>> 8 & 255;
            mac[macpos + 8] = this.h[4] >>> 0 & 255;
            mac[macpos + 9] = this.h[4] >>> 8 & 255;
            mac[macpos + 10] = this.h[5] >>> 0 & 255;
            mac[macpos + 11] = this.h[5] >>> 8 & 255;
            mac[macpos + 12] = this.h[6] >>> 0 & 255;
            mac[macpos + 13] = this.h[6] >>> 8 & 255;
            mac[macpos + 14] = this.h[7] >>> 0 & 255;
            mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m, mpos, bytes) {
            var i, want;
            if (this.leftover) {
                want = 16 - this.leftover;
                if (want > bytes) want = bytes;
                for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];
                bytes -= want;
                mpos += want;
                this.leftover += want;
                if (this.leftover < 16) return;
                this.blocks(this.buffer, 0, 16);
                this.leftover = 0;
            }
            if (bytes >= 16) {
                want = bytes - bytes % 16;
                this.blocks(m, mpos, want);
                mpos += want;
                bytes -= want;
            }
            if (bytes) {
                for (i = 0; i < bytes; i++) this.buffer[this.leftover + i] = m[mpos + i];
                this.leftover += bytes;
            }
        };
        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
            var s = new poly1305(k);
            s.update(m, mpos, n);
            s.finish(out, outpos);
            return 0;
        }
        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
            var x = new Uint8Array(16);
            crypto_onetimeauth(x, 0, m, mpos, n, k);
            return crypto_verify_16(h, hpos, x, 0);
        }
        function crypto_secretbox(c, m, d, n, k) {
            var i;
            if (d < 32) return -1;
            crypto_stream_xor(c, 0, m, 0, d, n, k);
            crypto_onetimeauth(c, 16, c, 32, d - 32, c);
            for (i = 0; i < 16; i++) c[i] = 0;
            return 0;
        }
        function crypto_secretbox_open(m, c, d, n, k) {
            var i;
            var x = new Uint8Array(32);
            if (d < 32) return -1;
            crypto_stream(x, 0, 32, n, k);
            if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
            crypto_stream_xor(m, 0, c, 0, d, n, k);
            for (i = 0; i < 32; i++) m[i] = 0;
            return 0;
        }
        function set25519(r, a) {
            var i;
            for (i = 0; i < 16; i++) r[i] = a[i] | 0;
        }
        function car25519(o) {
            var i, v, c = 1;
            for (i = 0; i < 16; i++) {
                v = o[i] + c + 65535;
                c = Math.floor(v / 65536);
                o[i] = v - c * 65536;
            }
            o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
            var t, c = ~(b - 1);
            for (var i = 0; i < 16; i++) {
                t = c & (p[i] ^ q[i]);
                p[i] ^= t;
                q[i] ^= t;
            }
        }
        function pack25519(o, n) {
            var i, j, b;
            var m = gf(), t = gf();
            for (i = 0; i < 16; i++) t[i] = n[i];
            car25519(t);
            car25519(t);
            car25519(t);
            for (j = 0; j < 2; j++) {
                m[0] = t[0] - 65517;
                for (i = 1; i < 15; i++) {
                    m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
                    m[i - 1] &= 65535;
                }
                m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
                b = m[15] >> 16 & 1;
                m[14] &= 65535;
                sel25519(t, m, 1 - b);
            }
            for (i = 0; i < 16; i++) {
                o[2 * i] = t[i] & 255;
                o[2 * i + 1] = t[i] >> 8;
            }
        }
        function neq25519(a, b) {
            var c = new Uint8Array(32), d = new Uint8Array(32);
            pack25519(c, a);
            pack25519(d, b);
            return crypto_verify_32(c, 0, d, 0);
        }
        function par25519(a) {
            var d = new Uint8Array(32);
            pack25519(d, a);
            return d[0] & 1;
        }
        function unpack25519(o, n) {
            var i;
            for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
            o[15] &= 32767;
        }
        function A(o, a, b) {
            for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
        }
        function Z(o, a, b) {
            for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
        }
        function M(o, a, b) {
            var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
            v = a[0];
            t0 += v * b0;
            t1 += v * b1;
            t2 += v * b2;
            t3 += v * b3;
            t4 += v * b4;
            t5 += v * b5;
            t6 += v * b6;
            t7 += v * b7;
            t8 += v * b8;
            t9 += v * b9;
            t10 += v * b10;
            t11 += v * b11;
            t12 += v * b12;
            t13 += v * b13;
            t14 += v * b14;
            t15 += v * b15;
            v = a[1];
            t1 += v * b0;
            t2 += v * b1;
            t3 += v * b2;
            t4 += v * b3;
            t5 += v * b4;
            t6 += v * b5;
            t7 += v * b6;
            t8 += v * b7;
            t9 += v * b8;
            t10 += v * b9;
            t11 += v * b10;
            t12 += v * b11;
            t13 += v * b12;
            t14 += v * b13;
            t15 += v * b14;
            t16 += v * b15;
            v = a[2];
            t2 += v * b0;
            t3 += v * b1;
            t4 += v * b2;
            t5 += v * b3;
            t6 += v * b4;
            t7 += v * b5;
            t8 += v * b6;
            t9 += v * b7;
            t10 += v * b8;
            t11 += v * b9;
            t12 += v * b10;
            t13 += v * b11;
            t14 += v * b12;
            t15 += v * b13;
            t16 += v * b14;
            t17 += v * b15;
            v = a[3];
            t3 += v * b0;
            t4 += v * b1;
            t5 += v * b2;
            t6 += v * b3;
            t7 += v * b4;
            t8 += v * b5;
            t9 += v * b6;
            t10 += v * b7;
            t11 += v * b8;
            t12 += v * b9;
            t13 += v * b10;
            t14 += v * b11;
            t15 += v * b12;
            t16 += v * b13;
            t17 += v * b14;
            t18 += v * b15;
            v = a[4];
            t4 += v * b0;
            t5 += v * b1;
            t6 += v * b2;
            t7 += v * b3;
            t8 += v * b4;
            t9 += v * b5;
            t10 += v * b6;
            t11 += v * b7;
            t12 += v * b8;
            t13 += v * b9;
            t14 += v * b10;
            t15 += v * b11;
            t16 += v * b12;
            t17 += v * b13;
            t18 += v * b14;
            t19 += v * b15;
            v = a[5];
            t5 += v * b0;
            t6 += v * b1;
            t7 += v * b2;
            t8 += v * b3;
            t9 += v * b4;
            t10 += v * b5;
            t11 += v * b6;
            t12 += v * b7;
            t13 += v * b8;
            t14 += v * b9;
            t15 += v * b10;
            t16 += v * b11;
            t17 += v * b12;
            t18 += v * b13;
            t19 += v * b14;
            t20 += v * b15;
            v = a[6];
            t6 += v * b0;
            t7 += v * b1;
            t8 += v * b2;
            t9 += v * b3;
            t10 += v * b4;
            t11 += v * b5;
            t12 += v * b6;
            t13 += v * b7;
            t14 += v * b8;
            t15 += v * b9;
            t16 += v * b10;
            t17 += v * b11;
            t18 += v * b12;
            t19 += v * b13;
            t20 += v * b14;
            t21 += v * b15;
            v = a[7];
            t7 += v * b0;
            t8 += v * b1;
            t9 += v * b2;
            t10 += v * b3;
            t11 += v * b4;
            t12 += v * b5;
            t13 += v * b6;
            t14 += v * b7;
            t15 += v * b8;
            t16 += v * b9;
            t17 += v * b10;
            t18 += v * b11;
            t19 += v * b12;
            t20 += v * b13;
            t21 += v * b14;
            t22 += v * b15;
            v = a[8];
            t8 += v * b0;
            t9 += v * b1;
            t10 += v * b2;
            t11 += v * b3;
            t12 += v * b4;
            t13 += v * b5;
            t14 += v * b6;
            t15 += v * b7;
            t16 += v * b8;
            t17 += v * b9;
            t18 += v * b10;
            t19 += v * b11;
            t20 += v * b12;
            t21 += v * b13;
            t22 += v * b14;
            t23 += v * b15;
            v = a[9];
            t9 += v * b0;
            t10 += v * b1;
            t11 += v * b2;
            t12 += v * b3;
            t13 += v * b4;
            t14 += v * b5;
            t15 += v * b6;
            t16 += v * b7;
            t17 += v * b8;
            t18 += v * b9;
            t19 += v * b10;
            t20 += v * b11;
            t21 += v * b12;
            t22 += v * b13;
            t23 += v * b14;
            t24 += v * b15;
            v = a[10];
            t10 += v * b0;
            t11 += v * b1;
            t12 += v * b2;
            t13 += v * b3;
            t14 += v * b4;
            t15 += v * b5;
            t16 += v * b6;
            t17 += v * b7;
            t18 += v * b8;
            t19 += v * b9;
            t20 += v * b10;
            t21 += v * b11;
            t22 += v * b12;
            t23 += v * b13;
            t24 += v * b14;
            t25 += v * b15;
            v = a[11];
            t11 += v * b0;
            t12 += v * b1;
            t13 += v * b2;
            t14 += v * b3;
            t15 += v * b4;
            t16 += v * b5;
            t17 += v * b6;
            t18 += v * b7;
            t19 += v * b8;
            t20 += v * b9;
            t21 += v * b10;
            t22 += v * b11;
            t23 += v * b12;
            t24 += v * b13;
            t25 += v * b14;
            t26 += v * b15;
            v = a[12];
            t12 += v * b0;
            t13 += v * b1;
            t14 += v * b2;
            t15 += v * b3;
            t16 += v * b4;
            t17 += v * b5;
            t18 += v * b6;
            t19 += v * b7;
            t20 += v * b8;
            t21 += v * b9;
            t22 += v * b10;
            t23 += v * b11;
            t24 += v * b12;
            t25 += v * b13;
            t26 += v * b14;
            t27 += v * b15;
            v = a[13];
            t13 += v * b0;
            t14 += v * b1;
            t15 += v * b2;
            t16 += v * b3;
            t17 += v * b4;
            t18 += v * b5;
            t19 += v * b6;
            t20 += v * b7;
            t21 += v * b8;
            t22 += v * b9;
            t23 += v * b10;
            t24 += v * b11;
            t25 += v * b12;
            t26 += v * b13;
            t27 += v * b14;
            t28 += v * b15;
            v = a[14];
            t14 += v * b0;
            t15 += v * b1;
            t16 += v * b2;
            t17 += v * b3;
            t18 += v * b4;
            t19 += v * b5;
            t20 += v * b6;
            t21 += v * b7;
            t22 += v * b8;
            t23 += v * b9;
            t24 += v * b10;
            t25 += v * b11;
            t26 += v * b12;
            t27 += v * b13;
            t28 += v * b14;
            t29 += v * b15;
            v = a[15];
            t15 += v * b0;
            t16 += v * b1;
            t17 += v * b2;
            t18 += v * b3;
            t19 += v * b4;
            t20 += v * b5;
            t21 += v * b6;
            t22 += v * b7;
            t23 += v * b8;
            t24 += v * b9;
            t25 += v * b10;
            t26 += v * b11;
            t27 += v * b12;
            t28 += v * b13;
            t29 += v * b14;
            t30 += v * b15;
            t0 += 38 * t16;
            t1 += 38 * t17;
            t2 += 38 * t18;
            t3 += 38 * t19;
            t4 += 38 * t20;
            t5 += 38 * t21;
            t6 += 38 * t22;
            t7 += 38 * t23;
            t8 += 38 * t24;
            t9 += 38 * t25;
            t10 += 38 * t26;
            t11 += 38 * t27;
            t12 += 38 * t28;
            t13 += 38 * t29;
            t14 += 38 * t30;
            c = 1;
            v = t0 + c + 65535;
            c = Math.floor(v / 65536);
            t0 = v - c * 65536;
            v = t1 + c + 65535;
            c = Math.floor(v / 65536);
            t1 = v - c * 65536;
            v = t2 + c + 65535;
            c = Math.floor(v / 65536);
            t2 = v - c * 65536;
            v = t3 + c + 65535;
            c = Math.floor(v / 65536);
            t3 = v - c * 65536;
            v = t4 + c + 65535;
            c = Math.floor(v / 65536);
            t4 = v - c * 65536;
            v = t5 + c + 65535;
            c = Math.floor(v / 65536);
            t5 = v - c * 65536;
            v = t6 + c + 65535;
            c = Math.floor(v / 65536);
            t6 = v - c * 65536;
            v = t7 + c + 65535;
            c = Math.floor(v / 65536);
            t7 = v - c * 65536;
            v = t8 + c + 65535;
            c = Math.floor(v / 65536);
            t8 = v - c * 65536;
            v = t9 + c + 65535;
            c = Math.floor(v / 65536);
            t9 = v - c * 65536;
            v = t10 + c + 65535;
            c = Math.floor(v / 65536);
            t10 = v - c * 65536;
            v = t11 + c + 65535;
            c = Math.floor(v / 65536);
            t11 = v - c * 65536;
            v = t12 + c + 65535;
            c = Math.floor(v / 65536);
            t12 = v - c * 65536;
            v = t13 + c + 65535;
            c = Math.floor(v / 65536);
            t13 = v - c * 65536;
            v = t14 + c + 65535;
            c = Math.floor(v / 65536);
            t14 = v - c * 65536;
            v = t15 + c + 65535;
            c = Math.floor(v / 65536);
            t15 = v - c * 65536;
            t0 += c - 1 + 37 * (c - 1);
            c = 1;
            v = t0 + c + 65535;
            c = Math.floor(v / 65536);
            t0 = v - c * 65536;
            v = t1 + c + 65535;
            c = Math.floor(v / 65536);
            t1 = v - c * 65536;
            v = t2 + c + 65535;
            c = Math.floor(v / 65536);
            t2 = v - c * 65536;
            v = t3 + c + 65535;
            c = Math.floor(v / 65536);
            t3 = v - c * 65536;
            v = t4 + c + 65535;
            c = Math.floor(v / 65536);
            t4 = v - c * 65536;
            v = t5 + c + 65535;
            c = Math.floor(v / 65536);
            t5 = v - c * 65536;
            v = t6 + c + 65535;
            c = Math.floor(v / 65536);
            t6 = v - c * 65536;
            v = t7 + c + 65535;
            c = Math.floor(v / 65536);
            t7 = v - c * 65536;
            v = t8 + c + 65535;
            c = Math.floor(v / 65536);
            t8 = v - c * 65536;
            v = t9 + c + 65535;
            c = Math.floor(v / 65536);
            t9 = v - c * 65536;
            v = t10 + c + 65535;
            c = Math.floor(v / 65536);
            t10 = v - c * 65536;
            v = t11 + c + 65535;
            c = Math.floor(v / 65536);
            t11 = v - c * 65536;
            v = t12 + c + 65535;
            c = Math.floor(v / 65536);
            t12 = v - c * 65536;
            v = t13 + c + 65535;
            c = Math.floor(v / 65536);
            t13 = v - c * 65536;
            v = t14 + c + 65535;
            c = Math.floor(v / 65536);
            t14 = v - c * 65536;
            v = t15 + c + 65535;
            c = Math.floor(v / 65536);
            t15 = v - c * 65536;
            t0 += c - 1 + 37 * (c - 1);
            o[0] = t0;
            o[1] = t1;
            o[2] = t2;
            o[3] = t3;
            o[4] = t4;
            o[5] = t5;
            o[6] = t6;
            o[7] = t7;
            o[8] = t8;
            o[9] = t9;
            o[10] = t10;
            o[11] = t11;
            o[12] = t12;
            o[13] = t13;
            o[14] = t14;
            o[15] = t15;
        }
        function S(o, a) {
            M(o, a, a);
        }
        function inv25519(o, i) {
            var c = gf();
            var a;
            for (a = 0; a < 16; a++) c[a] = i[a];
            for (a = 253; a >= 0; a--) {
                S(c, c);
                if (a !== 2 && a !== 4) M(c, c, i);
            }
            for (a = 0; a < 16; a++) o[a] = c[a];
        }
        function pow2523(o, i) {
            var c = gf();
            var a;
            for (a = 0; a < 16; a++) c[a] = i[a];
            for (a = 250; a >= 0; a--) {
                S(c, c);
                if (a !== 1) M(c, c, i);
            }
            for (a = 0; a < 16; a++) o[a] = c[a];
        }
        function crypto_scalarmult(q, n, p) {
            var z = new Uint8Array(32);
            var x = new Float64Array(80), r, i;
            var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
            for (i = 0; i < 31; i++) z[i] = n[i];
            z[31] = n[31] & 127 | 64;
            z[0] &= 248;
            unpack25519(x, p);
            for (i = 0; i < 16; i++) {
                b[i] = x[i];
                d[i] = a[i] = c[i] = 0;
            }
            a[0] = d[0] = 1;
            for (i = 254; i >= 0; --i) {
                r = z[i >>> 3] >>> (i & 7) & 1;
                sel25519(a, b, r);
                sel25519(c, d, r);
                A(e, a, c);
                Z(a, a, c);
                A(c, b, d);
                Z(b, b, d);
                S(d, e);
                S(f, a);
                M(a, c, a);
                M(c, b, e);
                A(e, a, c);
                Z(a, a, c);
                S(b, a);
                Z(c, d, f);
                M(a, c, _121665);
                A(a, a, d);
                M(c, c, a);
                M(a, d, f);
                M(d, b, x);
                S(b, e);
                sel25519(a, b, r);
                sel25519(c, d, r);
            }
            for (i = 0; i < 16; i++) {
                x[i + 16] = a[i];
                x[i + 32] = c[i];
                x[i + 48] = b[i];
                x[i + 64] = d[i];
            }
            var x32 = x.subarray(32);
            var x16 = x.subarray(16);
            inv25519(x32, x32);
            M(x16, x16, x32);
            pack25519(q, x16);
            return 0;
        }
        function crypto_scalarmult_base(q, n) {
            return crypto_scalarmult(q, n, _9);
        }
        function crypto_box_keypair(y, x) {
            randombytes(x, 32);
            return crypto_scalarmult_base(y, x);
        }
        function crypto_box_beforenm(k, y, x) {
            var s = new Uint8Array(32);
            crypto_scalarmult(s, x, y);
            return crypto_core_hsalsa20(k, _0, s, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c, m, d, n, y, x) {
            var k = new Uint8Array(32);
            crypto_box_beforenm(k, y, x);
            return crypto_box_afternm(c, m, d, n, k);
        }
        function crypto_box_open(m, c, d, n, y, x) {
            var k = new Uint8Array(32);
            crypto_box_beforenm(k, y, x);
            return crypto_box_open_afternm(m, c, d, n, k);
        }
        var K = [ 1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591 ];
        function crypto_hashblocks_hl(hh, hl, m, n) {
            var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
            var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
            var pos = 0;
            while (n >= 128) {
                for (i = 0; i < 16; i++) {
                    j = 8 * i + pos;
                    wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
                    wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
                }
                for (i = 0; i < 80; i++) {
                    bh0 = ah0;
                    bh1 = ah1;
                    bh2 = ah2;
                    bh3 = ah3;
                    bh4 = ah4;
                    bh5 = ah5;
                    bh6 = ah6;
                    bh7 = ah7;
                    bl0 = al0;
                    bl1 = al1;
                    bl2 = al2;
                    bl3 = al3;
                    bl4 = al4;
                    bl5 = al5;
                    bl6 = al6;
                    bl7 = al7;
                    h = ah7;
                    l = al7;
                    a = l & 65535;
                    b = l >>> 16;
                    c = h & 65535;
                    d = h >>> 16;
                    h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
                    l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    h = ah4 & ah5 ^ ~ah4 & ah6;
                    l = al4 & al5 ^ ~al4 & al6;
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    h = K[i * 2];
                    l = K[i * 2 + 1];
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    h = wh[i % 16];
                    l = wl[i % 16];
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    th = c & 65535 | d << 16;
                    tl = a & 65535 | b << 16;
                    h = th;
                    l = tl;
                    a = l & 65535;
                    b = l >>> 16;
                    c = h & 65535;
                    d = h >>> 16;
                    h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
                    l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
                    l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    bh7 = c & 65535 | d << 16;
                    bl7 = a & 65535 | b << 16;
                    h = bh3;
                    l = bl3;
                    a = l & 65535;
                    b = l >>> 16;
                    c = h & 65535;
                    d = h >>> 16;
                    h = th;
                    l = tl;
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    bh3 = c & 65535 | d << 16;
                    bl3 = a & 65535 | b << 16;
                    ah1 = bh0;
                    ah2 = bh1;
                    ah3 = bh2;
                    ah4 = bh3;
                    ah5 = bh4;
                    ah6 = bh5;
                    ah7 = bh6;
                    ah0 = bh7;
                    al1 = bl0;
                    al2 = bl1;
                    al3 = bl2;
                    al4 = bl3;
                    al5 = bl4;
                    al6 = bl5;
                    al7 = bl6;
                    al0 = bl7;
                    if (i % 16 === 15) {
                        for (j = 0; j < 16; j++) {
                            h = wh[j];
                            l = wl[j];
                            a = l & 65535;
                            b = l >>> 16;
                            c = h & 65535;
                            d = h >>> 16;
                            h = wh[(j + 9) % 16];
                            l = wl[(j + 9) % 16];
                            a += l & 65535;
                            b += l >>> 16;
                            c += h & 65535;
                            d += h >>> 16;
                            th = wh[(j + 1) % 16];
                            tl = wl[(j + 1) % 16];
                            h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                            l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                            a += l & 65535;
                            b += l >>> 16;
                            c += h & 65535;
                            d += h >>> 16;
                            th = wh[(j + 14) % 16];
                            tl = wl[(j + 14) % 16];
                            h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                            l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                            a += l & 65535;
                            b += l >>> 16;
                            c += h & 65535;
                            d += h >>> 16;
                            b += a >>> 16;
                            c += b >>> 16;
                            d += c >>> 16;
                            wh[j] = c & 65535 | d << 16;
                            wl[j] = a & 65535 | b << 16;
                        }
                    }
                }
                h = ah0;
                l = al0;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[0];
                l = hl[0];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[0] = ah0 = c & 65535 | d << 16;
                hl[0] = al0 = a & 65535 | b << 16;
                h = ah1;
                l = al1;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[1];
                l = hl[1];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[1] = ah1 = c & 65535 | d << 16;
                hl[1] = al1 = a & 65535 | b << 16;
                h = ah2;
                l = al2;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[2];
                l = hl[2];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[2] = ah2 = c & 65535 | d << 16;
                hl[2] = al2 = a & 65535 | b << 16;
                h = ah3;
                l = al3;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[3];
                l = hl[3];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[3] = ah3 = c & 65535 | d << 16;
                hl[3] = al3 = a & 65535 | b << 16;
                h = ah4;
                l = al4;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[4];
                l = hl[4];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[4] = ah4 = c & 65535 | d << 16;
                hl[4] = al4 = a & 65535 | b << 16;
                h = ah5;
                l = al5;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[5];
                l = hl[5];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[5] = ah5 = c & 65535 | d << 16;
                hl[5] = al5 = a & 65535 | b << 16;
                h = ah6;
                l = al6;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[6];
                l = hl[6];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[6] = ah6 = c & 65535 | d << 16;
                hl[6] = al6 = a & 65535 | b << 16;
                h = ah7;
                l = al7;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = hh[7];
                l = hl[7];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[7] = ah7 = c & 65535 | d << 16;
                hl[7] = al7 = a & 65535 | b << 16;
                pos += 128;
                n -= 128;
            }
            return n;
        }
        function crypto_hash(out, m, n) {
            var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
            hh[0] = 1779033703;
            hh[1] = 3144134277;
            hh[2] = 1013904242;
            hh[3] = 2773480762;
            hh[4] = 1359893119;
            hh[5] = 2600822924;
            hh[6] = 528734635;
            hh[7] = 1541459225;
            hl[0] = 4089235720;
            hl[1] = 2227873595;
            hl[2] = 4271175723;
            hl[3] = 1595750129;
            hl[4] = 2917565137;
            hl[5] = 725511199;
            hl[6] = 4215389547;
            hl[7] = 327033209;
            crypto_hashblocks_hl(hh, hl, m, n);
            n %= 128;
            for (i = 0; i < n; i++) x[i] = m[b - n + i];
            x[n] = 128;
            n = 256 - 128 * (n < 112 ? 1 : 0);
            x[n - 9] = 0;
            ts64(x, n - 8, b / 536870912 | 0, b << 3);
            crypto_hashblocks_hl(hh, hl, x, n);
            for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
            return 0;
        }
        function add(p, q) {
            var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
            Z(a, p[1], p[0]);
            Z(t, q[1], q[0]);
            M(a, a, t);
            A(b, p[0], p[1]);
            A(t, q[0], q[1]);
            M(b, b, t);
            M(c, p[3], q[3]);
            M(c, c, D2);
            M(d, p[2], q[2]);
            A(d, d, d);
            Z(e, b, a);
            Z(f, d, c);
            A(g, d, c);
            A(h, b, a);
            M(p[0], e, f);
            M(p[1], h, g);
            M(p[2], g, f);
            M(p[3], e, h);
        }
        function cswap(p, q, b) {
            var i;
            for (i = 0; i < 4; i++) {
                sel25519(p[i], q[i], b);
            }
        }
        function pack(r, p) {
            var tx = gf(), ty = gf(), zi = gf();
            inv25519(zi, p[2]);
            M(tx, p[0], zi);
            M(ty, p[1], zi);
            pack25519(r, ty);
            r[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p, q, s) {
            var b, i;
            set25519(p[0], gf0);
            set25519(p[1], gf1);
            set25519(p[2], gf1);
            set25519(p[3], gf0);
            for (i = 255; i >= 0; --i) {
                b = s[i / 8 | 0] >> (i & 7) & 1;
                cswap(p, q, b);
                add(q, p);
                add(p, p);
                cswap(p, q, b);
            }
        }
        function scalarbase(p, s) {
            var q = [ gf(), gf(), gf(), gf() ];
            set25519(q[0], X);
            set25519(q[1], Y);
            set25519(q[2], gf1);
            M(q[3], X, Y);
            scalarmult(p, q, s);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
            var d = new Uint8Array(64);
            var p = [ gf(), gf(), gf(), gf() ];
            var i;
            if (!seeded) randombytes(sk, 32);
            crypto_hash(d, sk, 32);
            d[0] &= 248;
            d[31] &= 127;
            d[31] |= 64;
            scalarbase(p, d);
            pack(pk, p);
            for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
            return 0;
        }
        var L = new Float64Array([ 237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 ]);
        function modL(r, x) {
            var carry, i, j, k;
            for (i = 63; i >= 32; --i) {
                carry = 0;
                for (j = i - 32, k = i - 12; j < k; ++j) {
                    x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                    carry = x[j] + 128 >> 8;
                    x[j] -= carry * 256;
                }
                x[j] += carry;
                x[i] = 0;
            }
            carry = 0;
            for (j = 0; j < 32; j++) {
                x[j] += carry - (x[31] >> 4) * L[j];
                carry = x[j] >> 8;
                x[j] &= 255;
            }
            for (j = 0; j < 32; j++) x[j] -= carry * L[j];
            for (i = 0; i < 32; i++) {
                x[i + 1] += x[i] >> 8;
                r[i] = x[i] & 255;
            }
        }
        function reduce(r) {
            var x = new Float64Array(64), i;
            for (i = 0; i < 64; i++) x[i] = r[i];
            for (i = 0; i < 64; i++) r[i] = 0;
            modL(r, x);
        }
        function crypto_sign(sm, m, n, sk) {
            var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
            var i, j, x = new Float64Array(64);
            var p = [ gf(), gf(), gf(), gf() ];
            crypto_hash(d, sk, 32);
            d[0] &= 248;
            d[31] &= 127;
            d[31] |= 64;
            var smlen = n + 64;
            for (i = 0; i < n; i++) sm[64 + i] = m[i];
            for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
            crypto_hash(r, sm.subarray(32), n + 32);
            reduce(r);
            scalarbase(p, r);
            pack(sm, p);
            for (i = 32; i < 64; i++) sm[i] = sk[i];
            crypto_hash(h, sm, n + 64);
            reduce(h);
            for (i = 0; i < 64; i++) x[i] = 0;
            for (i = 0; i < 32; i++) x[i] = r[i];
            for (i = 0; i < 32; i++) {
                for (j = 0; j < 32; j++) {
                    x[i + j] += h[i] * d[j];
                }
            }
            modL(sm.subarray(32), x);
            return smlen;
        }
        function unpackneg(r, p) {
            var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
            set25519(r[2], gf1);
            unpack25519(r[1], p);
            S(num, r[1]);
            M(den, num, D);
            Z(num, num, r[2]);
            A(den, r[2], den);
            S(den2, den);
            S(den4, den2);
            M(den6, den4, den2);
            M(t, den6, num);
            M(t, t, den);
            pow2523(t, t);
            M(t, t, num);
            M(t, t, den);
            M(t, t, den);
            M(r[0], t, den);
            S(chk, r[0]);
            M(chk, chk, den);
            if (neq25519(chk, num)) M(r[0], r[0], I);
            S(chk, r[0]);
            M(chk, chk, den);
            if (neq25519(chk, num)) return -1;
            if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
            M(r[3], r[0], r[1]);
            return 0;
        }
        function crypto_sign_open(m, sm, n, pk) {
            var i, mlen;
            var t = new Uint8Array(32), h = new Uint8Array(64);
            var p = [ gf(), gf(), gf(), gf() ], q = [ gf(), gf(), gf(), gf() ];
            mlen = -1;
            if (n < 64) return -1;
            if (unpackneg(q, pk)) return -1;
            for (i = 0; i < n; i++) m[i] = sm[i];
            for (i = 0; i < 32; i++) m[i + 32] = pk[i];
            crypto_hash(h, m, n);
            reduce(h);
            scalarmult(p, q, h);
            scalarbase(q, sm.subarray(32));
            add(p, q);
            pack(t, p);
            n -= 64;
            if (crypto_verify_32(sm, 0, t, 0)) {
                for (i = 0; i < n; i++) m[i] = 0;
                return -1;
            }
            for (i = 0; i < n; i++) m[i] = sm[i + 64];
            mlen = n;
            return mlen;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl.lowlevel = {
            crypto_core_hsalsa20,
            crypto_stream_xor,
            crypto_stream,
            crypto_stream_salsa20_xor,
            crypto_stream_salsa20,
            crypto_onetimeauth,
            crypto_onetimeauth_verify,
            crypto_verify_16,
            crypto_verify_32,
            crypto_secretbox,
            crypto_secretbox_open,
            crypto_scalarmult,
            crypto_scalarmult_base,
            crypto_box_beforenm,
            crypto_box_afternm,
            crypto_box,
            crypto_box_open,
            crypto_box_keypair,
            crypto_hash,
            crypto_sign,
            crypto_sign_keypair,
            crypto_sign_open,
            crypto_secretbox_KEYBYTES,
            crypto_secretbox_NONCEBYTES,
            crypto_secretbox_ZEROBYTES,
            crypto_secretbox_BOXZEROBYTES,
            crypto_scalarmult_BYTES,
            crypto_scalarmult_SCALARBYTES,
            crypto_box_PUBLICKEYBYTES,
            crypto_box_SECRETKEYBYTES,
            crypto_box_BEFORENMBYTES,
            crypto_box_NONCEBYTES,
            crypto_box_ZEROBYTES,
            crypto_box_BOXZEROBYTES,
            crypto_sign_BYTES,
            crypto_sign_PUBLICKEYBYTES,
            crypto_sign_SECRETKEYBYTES,
            crypto_sign_SEEDBYTES,
            crypto_hash_BYTES
        };
        function checkLengths(k, n) {
            if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
            if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
            if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
            if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
            for (var i = 0; i < arguments.length; i++) {
                if (!(arguments[i] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
            }
        }
        function cleanup(arr) {
            for (var i = 0; i < arr.length; i++) arr[i] = 0;
        }
        nacl.randomBytes = function(n) {
            var b = new Uint8Array(n);
            randombytes(b, n);
            return b;
        };
        nacl.secretbox = function(msg, nonce, key) {
            checkArrayTypes(msg, nonce, key);
            checkLengths(key, nonce);
            var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
            var c = new Uint8Array(m.length);
            for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
            crypto_secretbox(c, m, m.length, nonce, key);
            return c.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl.secretbox.open = function(box, nonce, key) {
            checkArrayTypes(box, nonce, key);
            checkLengths(key, nonce);
            var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
            var m = new Uint8Array(c.length);
            for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
            if (c.length < 32) return null;
            if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
            return m.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl.scalarMult = function(n, p) {
            checkArrayTypes(n, p);
            if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
            if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
            var q = new Uint8Array(crypto_scalarmult_BYTES);
            crypto_scalarmult(q, n, p);
            return q;
        };
        nacl.scalarMult.base = function(n) {
            checkArrayTypes(n);
            if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
            var q = new Uint8Array(crypto_scalarmult_BYTES);
            crypto_scalarmult_base(q, n);
            return q;
        };
        nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl.box = function(msg, nonce, publicKey, secretKey) {
            var k = nacl.box.before(publicKey, secretKey);
            return nacl.secretbox(msg, nonce, k);
        };
        nacl.box.before = function(publicKey, secretKey) {
            checkArrayTypes(publicKey, secretKey);
            checkBoxLengths(publicKey, secretKey);
            var k = new Uint8Array(crypto_box_BEFORENMBYTES);
            crypto_box_beforenm(k, publicKey, secretKey);
            return k;
        };
        nacl.box.after = nacl.secretbox;
        nacl.box.open = function(msg, nonce, publicKey, secretKey) {
            var k = nacl.box.before(publicKey, secretKey);
            return nacl.secretbox.open(msg, nonce, k);
        };
        nacl.box.open.after = nacl.secretbox.open;
        nacl.box.keyPair = function() {
            var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
            var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
            crypto_box_keypair(pk, sk);
            return {
                publicKey: pk,
                secretKey: sk
            };
        };
        nacl.box.keyPair.fromSecretKey = function(secretKey) {
            checkArrayTypes(secretKey);
            if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
            var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
            crypto_scalarmult_base(pk, secretKey);
            return {
                publicKey: pk,
                secretKey: new Uint8Array(secretKey)
            };
        };
        nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl.box.nonceLength = crypto_box_NONCEBYTES;
        nacl.box.overheadLength = nacl.secretbox.overheadLength;
        nacl.sign = function(msg, secretKey) {
            checkArrayTypes(msg, secretKey);
            if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
            var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
            crypto_sign(signedMsg, msg, msg.length, secretKey);
            return signedMsg;
        };
        nacl.sign.open = function(signedMsg, publicKey) {
            checkArrayTypes(signedMsg, publicKey);
            if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
            var tmp = new Uint8Array(signedMsg.length);
            var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
            if (mlen < 0) return null;
            var m = new Uint8Array(mlen);
            for (var i = 0; i < m.length; i++) m[i] = tmp[i];
            return m;
        };
        nacl.sign.detached = function(msg, secretKey) {
            var signedMsg = nacl.sign(msg, secretKey);
            var sig = new Uint8Array(crypto_sign_BYTES);
            for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
            return sig;
        };
        nacl.sign.detached.verify = function(msg, sig, publicKey) {
            checkArrayTypes(msg, sig, publicKey);
            if (sig.length !== crypto_sign_BYTES) throw new Error("bad signature size");
            if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
            var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
            var m = new Uint8Array(crypto_sign_BYTES + msg.length);
            var i;
            for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
            for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
            return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        nacl.sign.keyPair = function() {
            var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
            var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
            crypto_sign_keypair(pk, sk);
            return {
                publicKey: pk,
                secretKey: sk
            };
        };
        nacl.sign.keyPair.fromSecretKey = function(secretKey) {
            checkArrayTypes(secretKey);
            if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
            var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
            for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
            return {
                publicKey: pk,
                secretKey: new Uint8Array(secretKey)
            };
        };
        nacl.sign.keyPair.fromSeed = function(seed) {
            checkArrayTypes(seed);
            if (seed.length !== crypto_sign_SEEDBYTES) throw new Error("bad seed size");
            var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
            var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
            for (var i = 0; i < 32; i++) sk[i] = seed[i];
            crypto_sign_keypair(pk, sk, true);
            return {
                publicKey: pk,
                secretKey: sk
            };
        };
        nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl.sign.signatureLength = crypto_sign_BYTES;
        nacl.hash = function(msg) {
            checkArrayTypes(msg);
            var h = new Uint8Array(crypto_hash_BYTES);
            crypto_hash(h, msg, msg.length);
            return h;
        };
        nacl.hash.hashLength = crypto_hash_BYTES;
        nacl.verify = function(x, y) {
            checkArrayTypes(x, y);
            if (x.length === 0 || y.length === 0) return false;
            if (x.length !== y.length) return false;
            return vn(x, 0, y, 0, x.length) === 0 ? true : false;
        };
        nacl.setPRNG = function(fn) {
            randombytes = fn;
        };
        (function() {
            var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
            if (crypto && crypto.getRandomValues) {
                var QUOTA = 65536;
                nacl.setPRNG(function(x, n) {
                    var i, v = new Uint8Array(n);
                    for (i = 0; i < n; i += QUOTA) {
                        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
                    }
                    for (i = 0; i < n; i++) x[i] = v[i];
                    cleanup(v);
                });
            } else if (true) {
                crypto = __webpack_require__(271);
                if (crypto && crypto.randomBytes) {
                    nacl.setPRNG(function(x, n) {
                        var i, v = crypto.randomBytes(n);
                        for (i = 0; i < n; i++) x[i] = v[i];
                        cleanup(v);
                    });
                }
            }
        })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    "use strict";
    var BASE58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var base58 = __webpack_require__(54)(BASE58);
    var hex = __webpack_require__(54)("0123456789abcdef");
    var XMLHttpRequest = typeof window !== "undefined" ? window.XMLHttpRequest : __webpack_require__(273).XMLHttpRequest;
    var functionSignature = "0x447885f0";
    var getAttributesData = "0x446d5aa4000000000000000000000000";
    function http(opts, callback) {
        var request = new XMLHttpRequest();
        var options = opts || {};
        request.onreadystatechange = function() {
            if (request.readyState === 4 && request.timeout !== 1) {
                if (request.status !== 200) {
                    callback(new Error("[uport-lite] status " + request.status + ": " + request.responseText));
                } else {
                    try {
                        callback(null, JSON.parse(request.responseText));
                    } catch (jsonError) {
                        callback(new Error("[uport-lite] while parsing data: '" + String(request.responseText) + "', error: " + String(jsonError)));
                    }
                }
            }
        };
        if (options.data) {
            request.open("POST", opts.uri);
        } else {
            request.open("GET", opts.uri);
        }
        if (options.accept) {
            request.setRequestHeader("accept", options.accept);
        }
        if (options.data) {
            request.setRequestHeader("Content-Type", "application/json");
            request.send(JSON.stringify(options.data));
        } else {
            request.send();
        }
    }
    function registryEncodingToIPFS(hexStr) {
        return base58.encode(hex.decode("1220" + hexStr.slice(2)));
    }
    function eaeDecode(encoded) {
        var data = base58.decode(encoded);
        var netLength = data.length - 24;
        var network = data.slice(1, netLength);
        var address = data.slice(netLength, 20 + netLength);
        return {
            network: "0x" + hex.encode(network),
            address: "0x" + hex.encode(address)
        };
    }
    var defaultNetworks = {
        "0x1": {
            registry: "0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6",
            rpcUrl: "https://mainnet.infura.io"
        },
        "0x3": {
            registry: "0x41566e3a081f5032bdcad470adb797635ddfe1f0",
            rpcUrl: "https://ropsten.infura.io"
        },
        "0x2a": {
            registry: "0x5f8e9351dc2d238fb878b6ae43aa740d62fc9758",
            rpcUrl: "https://kovan.infura.io"
        },
        "0x4": {
            registry: "0x2cc31912b2b0f3075a87b3640923d45a26cef3ee",
            rpcUrl: "https://rinkeby.infura.io"
        }
    };
    function toBase58(hexStr) {
        return base58.encode(hex.decode(hexStr));
    }
    function UportLite() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var infuraKey = opts.infuraKey || "uport-lite-library";
        var ipfsGw = opts.ipfsGw || "https://ipfs.infura.io/ipfs/";
        var networks = opts.networks ? Object.assign({}, defaultNetworks, opts.networks) : defaultNetworks;
        function asciiToHex(string, delim) {
            return string.split("").map(function(c) {
                return ("0" + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(delim || "");
        }
        function pad(pad, str, padLeft) {
            if (typeof str === "undefined") {
                return pad;
            }
            if (padLeft) {
                return (pad + str).slice(-pad.length);
            } else {
                return (str + pad).substring(0, pad.length);
            }
        }
        function encodeFunctionCall(functionSignature, registrationIdentifier, issuer, subject) {
            var callString = functionSignature;
            callString += pad("0000000000000000000000000000000000000000000000000000000000000000", asciiToHex(registrationIdentifier));
            callString += pad("0000000000000000000000000000000000000000000000000000000000000000", issuer.slice(2), true);
            callString += pad("0000000000000000000000000000000000000000000000000000000000000000", subject.slice(2), true);
            return callString;
        }
        function callLegacyRegistry(address, callback) {
            var rpcUrl = "https://ropsten.infura.io/" + infuraKey;
            if (!address) return callback(null);
            return http({
                uri: rpcUrl,
                accept: "application/json",
                data: {
                    method: "eth_call",
                    params: [ {
                        to: "0xb9C1598e24650437a3055F7f66AC1820c419a679",
                        data: getAttributesData + address.slice(2)
                    }, "latest" ],
                    id: 1,
                    jsonrpc: "2.0"
                }
            }, function(error, response) {
                if (error) return callback(error);
                if (response.error) return callback(response.error);
                var hexHash = response.result.slice(130).slice(0, 68);
                return callback(null, toBase58(hexHash));
            });
        }
        function callRegistry(registrationIdentifier, issuerId, subjectId, callback) {
            var issuer = eaeDecode(issuerId);
            var subject = eaeDecode(subjectId);
            if (issuer.network !== subject.network) {
                callback(new Error("Issuer and subject must be on the same network"));
                return;
            }
            if (!networks[issuer.network]) {
                callback(new Error("Network id " + issuer.network + " is not configured"));
                return;
            }
            var rpcUrl = networks[issuer.network].rpcUrl;
            var registryAddress = networks[issuer.network].registry;
            var callString = encodeFunctionCall(functionSignature, registrationIdentifier, issuer.address, subject.address);
            return http({
                uri: rpcUrl + "/" + infuraKey,
                accept: "application/json",
                data: {
                    method: "eth_call",
                    params: [ {
                        to: registryAddress,
                        data: callString
                    }, "latest" ],
                    id: 1,
                    jsonrpc: "2.0"
                }
            }, function(error, response) {
                if (error) return callback(error);
                if (response.error) return callback(response.error);
                if (response.result == 0) return callback(error);
                return callback(null, registryEncodingToIPFS(response.result));
            });
        }
        function fetchIpfs(ipfsHash, callback) {
            if (!ipfsHash || ipfsHash === "0x") return callback();
            return http({
                uri: "" + ipfsGw + ipfsHash
            }, callback);
        }
        function get(issuer, callback, subjectAddress) {
            var registrationIdentifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "uPortProfileIPFS1220";
            if (!issuer) return callback(null);
            var subject = subjectAddress || issuer;
            if (issuer.match(/0x[0-9a-fA-F]{40}/)) {
                return callLegacyRegistry(issuer, function(error, ipfsHash) {
                    if (error) return callback(error);
                    fetchIpfs(ipfsHash, callback);
                });
            } else {
                return callRegistry(registrationIdentifier, issuer, subject, function(error, ipfsHash) {
                    if (error) return callback(error);
                    fetchIpfs(ipfsHash, callback);
                });
            }
        }
        return get;
    }
    module.exports = UportLite;
}, function(module, exports, __webpack_require__) {
    (function(process, global) {
        (function() {
            "use strict";
            var root = typeof window === "object" ? window : {};
            var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
            if (NODE_JS) {
                root = global;
            }
            var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
            var HEX_CHARS = "0123456789abcdef".split("");
            var SHAKE_PADDING = [ 31, 7936, 2031616, 520093696 ];
            var KECCAK_PADDING = [ 1, 256, 65536, 16777216 ];
            var PADDING = [ 6, 1536, 393216, 100663296 ];
            var SHIFT = [ 0, 8, 16, 24 ];
            var RC = [ 1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648 ];
            var BITS = [ 224, 256, 384, 512 ];
            var SHAKE_BITS = [ 128, 256 ];
            var OUTPUT_TYPES = [ "hex", "buffer", "arrayBuffer", "array" ];
            var createOutputMethod = function(bits, padding, outputType) {
                return function(message) {
                    return new Keccak(bits, padding, bits).update(message)[outputType]();
                };
            };
            var createShakeOutputMethod = function(bits, padding, outputType) {
                return function(message, outputBits) {
                    return new Keccak(bits, padding, outputBits).update(message)[outputType]();
                };
            };
            var createMethod = function(bits, padding) {
                var method = createOutputMethod(bits, padding, "hex");
                method.create = function() {
                    return new Keccak(bits, padding, bits);
                };
                method.update = function(message) {
                    return method.create().update(message);
                };
                for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
                    var type = OUTPUT_TYPES[i];
                    method[type] = createOutputMethod(bits, padding, type);
                }
                return method;
            };
            var createShakeMethod = function(bits, padding) {
                var method = createShakeOutputMethod(bits, padding, "hex");
                method.create = function(outputBits) {
                    return new Keccak(bits, padding, outputBits);
                };
                method.update = function(message, outputBits) {
                    return method.create(outputBits).update(message);
                };
                for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
                    var type = OUTPUT_TYPES[i];
                    method[type] = createShakeOutputMethod(bits, padding, type);
                }
                return method;
            };
            var algorithms = [ {
                name: "keccak",
                padding: KECCAK_PADDING,
                bits: BITS,
                createMethod
            }, {
                name: "sha3",
                padding: PADDING,
                bits: BITS,
                createMethod
            }, {
                name: "shake",
                padding: SHAKE_PADDING,
                bits: SHAKE_BITS,
                createMethod: createShakeMethod
            } ];
            var methods = {}, methodNames = [];
            for (var i = 0; i < algorithms.length; ++i) {
                var algorithm = algorithms[i];
                var bits = algorithm.bits;
                for (var j = 0; j < bits.length; ++j) {
                    var methodName = algorithm.name + "_" + bits[j];
                    methodNames.push(methodName);
                    methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
                }
            }
            function Keccak(bits, padding, outputBits) {
                this.blocks = [];
                this.s = [];
                this.padding = padding;
                this.outputBits = outputBits;
                this.reset = true;
                this.block = 0;
                this.start = 0;
                this.blockCount = 1600 - (bits << 1) >> 5;
                this.byteCount = this.blockCount << 2;
                this.outputBlocks = outputBits >> 5;
                this.extraBytes = (outputBits & 31) >> 3;
                for (var i = 0; i < 50; ++i) {
                    this.s[i] = 0;
                }
            }
            Keccak.prototype.update = function(message) {
                var notString = typeof message !== "string";
                if (notString && message.constructor === ArrayBuffer) {
                    message = new Uint8Array(message);
                }
                var length = message.length, blocks = this.blocks, byteCount = this.byteCount, blockCount = this.blockCount, index = 0, s = this.s, i, code;
                while (index < length) {
                    if (this.reset) {
                        this.reset = false;
                        blocks[0] = this.block;
                        for (i = 1; i < blockCount + 1; ++i) {
                            blocks[i] = 0;
                        }
                    }
                    if (notString) {
                        for (i = this.start; index < length && i < byteCount; ++index) {
                            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
                        }
                    } else {
                        for (i = this.start; index < length && i < byteCount; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 128) {
                                blocks[i >> 2] |= code << SHIFT[i++ & 3];
                            } else if (code < 2048) {
                                blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                                blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                            } else if (code < 55296 || code >= 57344) {
                                blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                                blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                                blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                            } else {
                                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                                blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                                blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                                blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                                blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                            }
                        }
                    }
                    this.lastByteIndex = i;
                    if (i >= byteCount) {
                        this.start = i - byteCount;
                        this.block = blocks[blockCount];
                        for (i = 0; i < blockCount; ++i) {
                            s[i] ^= blocks[i];
                        }
                        f(s);
                        this.reset = true;
                    } else {
                        this.start = i;
                    }
                }
                return this;
            };
            Keccak.prototype.finalize = function() {
                var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
                blocks[i >> 2] |= this.padding[i & 3];
                if (this.lastByteIndex === this.byteCount) {
                    blocks[0] = blocks[blockCount];
                    for (i = 1; i < blockCount + 1; ++i) {
                        blocks[i] = 0;
                    }
                }
                blocks[blockCount - 1] |= 2147483648;
                for (i = 0; i < blockCount; ++i) {
                    s[i] ^= blocks[i];
                }
                f(s);
            };
            Keccak.prototype.toString = Keccak.prototype.hex = function() {
                this.finalize();
                var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
                var hex = "", block;
                while (j < outputBlocks) {
                    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
                        block = s[i];
                        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
                    }
                    if (j % blockCount === 0) {
                        f(s);
                        i = 0;
                    }
                }
                if (extraBytes) {
                    block = s[i];
                    if (extraBytes > 0) {
                        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
                    }
                    if (extraBytes > 1) {
                        hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
                    }
                    if (extraBytes > 2) {
                        hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
                    }
                }
                return hex;
            };
            Keccak.prototype.arrayBuffer = function() {
                this.finalize();
                var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
                var bytes = this.outputBits >> 3;
                var buffer;
                if (extraBytes) {
                    buffer = new ArrayBuffer(outputBlocks + 1 << 2);
                } else {
                    buffer = new ArrayBuffer(bytes);
                }
                var array = new Uint32Array(buffer);
                while (j < outputBlocks) {
                    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
                        array[j] = s[i];
                    }
                    if (j % blockCount === 0) {
                        f(s);
                    }
                }
                if (extraBytes) {
                    array[i] = s[i];
                    buffer = buffer.slice(0, bytes);
                }
                return buffer;
            };
            Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
            Keccak.prototype.digest = Keccak.prototype.array = function() {
                this.finalize();
                var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
                var array = [], offset, block;
                while (j < outputBlocks) {
                    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
                        offset = j << 2;
                        block = s[i];
                        array[offset] = block & 255;
                        array[offset + 1] = block >> 8 & 255;
                        array[offset + 2] = block >> 16 & 255;
                        array[offset + 3] = block >> 24 & 255;
                    }
                    if (j % blockCount === 0) {
                        f(s);
                    }
                }
                if (extraBytes) {
                    offset = j << 2;
                    block = s[i];
                    if (extraBytes > 0) {
                        array[offset] = block & 255;
                    }
                    if (extraBytes > 1) {
                        array[offset + 1] = block >> 8 & 255;
                    }
                    if (extraBytes > 2) {
                        array[offset + 2] = block >> 16 & 255;
                    }
                }
                return array;
            };
            var f = function(s) {
                var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
                for (n = 0; n < 48; n += 2) {
                    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
                    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
                    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
                    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
                    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
                    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
                    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
                    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
                    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
                    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
                    h = c8 ^ (c2 << 1 | c3 >>> 31);
                    l = c9 ^ (c3 << 1 | c2 >>> 31);
                    s[0] ^= h;
                    s[1] ^= l;
                    s[10] ^= h;
                    s[11] ^= l;
                    s[20] ^= h;
                    s[21] ^= l;
                    s[30] ^= h;
                    s[31] ^= l;
                    s[40] ^= h;
                    s[41] ^= l;
                    h = c0 ^ (c4 << 1 | c5 >>> 31);
                    l = c1 ^ (c5 << 1 | c4 >>> 31);
                    s[2] ^= h;
                    s[3] ^= l;
                    s[12] ^= h;
                    s[13] ^= l;
                    s[22] ^= h;
                    s[23] ^= l;
                    s[32] ^= h;
                    s[33] ^= l;
                    s[42] ^= h;
                    s[43] ^= l;
                    h = c2 ^ (c6 << 1 | c7 >>> 31);
                    l = c3 ^ (c7 << 1 | c6 >>> 31);
                    s[4] ^= h;
                    s[5] ^= l;
                    s[14] ^= h;
                    s[15] ^= l;
                    s[24] ^= h;
                    s[25] ^= l;
                    s[34] ^= h;
                    s[35] ^= l;
                    s[44] ^= h;
                    s[45] ^= l;
                    h = c4 ^ (c8 << 1 | c9 >>> 31);
                    l = c5 ^ (c9 << 1 | c8 >>> 31);
                    s[6] ^= h;
                    s[7] ^= l;
                    s[16] ^= h;
                    s[17] ^= l;
                    s[26] ^= h;
                    s[27] ^= l;
                    s[36] ^= h;
                    s[37] ^= l;
                    s[46] ^= h;
                    s[47] ^= l;
                    h = c6 ^ (c0 << 1 | c1 >>> 31);
                    l = c7 ^ (c1 << 1 | c0 >>> 31);
                    s[8] ^= h;
                    s[9] ^= l;
                    s[18] ^= h;
                    s[19] ^= l;
                    s[28] ^= h;
                    s[29] ^= l;
                    s[38] ^= h;
                    s[39] ^= l;
                    s[48] ^= h;
                    s[49] ^= l;
                    b0 = s[0];
                    b1 = s[1];
                    b32 = s[11] << 4 | s[10] >>> 28;
                    b33 = s[10] << 4 | s[11] >>> 28;
                    b14 = s[20] << 3 | s[21] >>> 29;
                    b15 = s[21] << 3 | s[20] >>> 29;
                    b46 = s[31] << 9 | s[30] >>> 23;
                    b47 = s[30] << 9 | s[31] >>> 23;
                    b28 = s[40] << 18 | s[41] >>> 14;
                    b29 = s[41] << 18 | s[40] >>> 14;
                    b20 = s[2] << 1 | s[3] >>> 31;
                    b21 = s[3] << 1 | s[2] >>> 31;
                    b2 = s[13] << 12 | s[12] >>> 20;
                    b3 = s[12] << 12 | s[13] >>> 20;
                    b34 = s[22] << 10 | s[23] >>> 22;
                    b35 = s[23] << 10 | s[22] >>> 22;
                    b16 = s[33] << 13 | s[32] >>> 19;
                    b17 = s[32] << 13 | s[33] >>> 19;
                    b48 = s[42] << 2 | s[43] >>> 30;
                    b49 = s[43] << 2 | s[42] >>> 30;
                    b40 = s[5] << 30 | s[4] >>> 2;
                    b41 = s[4] << 30 | s[5] >>> 2;
                    b22 = s[14] << 6 | s[15] >>> 26;
                    b23 = s[15] << 6 | s[14] >>> 26;
                    b4 = s[25] << 11 | s[24] >>> 21;
                    b5 = s[24] << 11 | s[25] >>> 21;
                    b36 = s[34] << 15 | s[35] >>> 17;
                    b37 = s[35] << 15 | s[34] >>> 17;
                    b18 = s[45] << 29 | s[44] >>> 3;
                    b19 = s[44] << 29 | s[45] >>> 3;
                    b10 = s[6] << 28 | s[7] >>> 4;
                    b11 = s[7] << 28 | s[6] >>> 4;
                    b42 = s[17] << 23 | s[16] >>> 9;
                    b43 = s[16] << 23 | s[17] >>> 9;
                    b24 = s[26] << 25 | s[27] >>> 7;
                    b25 = s[27] << 25 | s[26] >>> 7;
                    b6 = s[36] << 21 | s[37] >>> 11;
                    b7 = s[37] << 21 | s[36] >>> 11;
                    b38 = s[47] << 24 | s[46] >>> 8;
                    b39 = s[46] << 24 | s[47] >>> 8;
                    b30 = s[8] << 27 | s[9] >>> 5;
                    b31 = s[9] << 27 | s[8] >>> 5;
                    b12 = s[18] << 20 | s[19] >>> 12;
                    b13 = s[19] << 20 | s[18] >>> 12;
                    b44 = s[29] << 7 | s[28] >>> 25;
                    b45 = s[28] << 7 | s[29] >>> 25;
                    b26 = s[38] << 8 | s[39] >>> 24;
                    b27 = s[39] << 8 | s[38] >>> 24;
                    b8 = s[48] << 14 | s[49] >>> 18;
                    b9 = s[49] << 14 | s[48] >>> 18;
                    s[0] = b0 ^ ~b2 & b4;
                    s[1] = b1 ^ ~b3 & b5;
                    s[10] = b10 ^ ~b12 & b14;
                    s[11] = b11 ^ ~b13 & b15;
                    s[20] = b20 ^ ~b22 & b24;
                    s[21] = b21 ^ ~b23 & b25;
                    s[30] = b30 ^ ~b32 & b34;
                    s[31] = b31 ^ ~b33 & b35;
                    s[40] = b40 ^ ~b42 & b44;
                    s[41] = b41 ^ ~b43 & b45;
                    s[2] = b2 ^ ~b4 & b6;
                    s[3] = b3 ^ ~b5 & b7;
                    s[12] = b12 ^ ~b14 & b16;
                    s[13] = b13 ^ ~b15 & b17;
                    s[22] = b22 ^ ~b24 & b26;
                    s[23] = b23 ^ ~b25 & b27;
                    s[32] = b32 ^ ~b34 & b36;
                    s[33] = b33 ^ ~b35 & b37;
                    s[42] = b42 ^ ~b44 & b46;
                    s[43] = b43 ^ ~b45 & b47;
                    s[4] = b4 ^ ~b6 & b8;
                    s[5] = b5 ^ ~b7 & b9;
                    s[14] = b14 ^ ~b16 & b18;
                    s[15] = b15 ^ ~b17 & b19;
                    s[24] = b24 ^ ~b26 & b28;
                    s[25] = b25 ^ ~b27 & b29;
                    s[34] = b34 ^ ~b36 & b38;
                    s[35] = b35 ^ ~b37 & b39;
                    s[44] = b44 ^ ~b46 & b48;
                    s[45] = b45 ^ ~b47 & b49;
                    s[6] = b6 ^ ~b8 & b0;
                    s[7] = b7 ^ ~b9 & b1;
                    s[16] = b16 ^ ~b18 & b10;
                    s[17] = b17 ^ ~b19 & b11;
                    s[26] = b26 ^ ~b28 & b20;
                    s[27] = b27 ^ ~b29 & b21;
                    s[36] = b36 ^ ~b38 & b30;
                    s[37] = b37 ^ ~b39 & b31;
                    s[46] = b46 ^ ~b48 & b40;
                    s[47] = b47 ^ ~b49 & b41;
                    s[8] = b8 ^ ~b0 & b2;
                    s[9] = b9 ^ ~b1 & b3;
                    s[18] = b18 ^ ~b10 & b12;
                    s[19] = b19 ^ ~b11 & b13;
                    s[28] = b28 ^ ~b20 & b22;
                    s[29] = b29 ^ ~b21 & b23;
                    s[38] = b38 ^ ~b30 & b32;
                    s[39] = b39 ^ ~b31 & b33;
                    s[48] = b48 ^ ~b40 & b42;
                    s[49] = b49 ^ ~b41 & b43;
                    s[0] ^= RC[n];
                    s[1] ^= RC[n + 1];
                }
            };
            if (COMMON_JS) {
                module.exports = methods;
            } else {
                for (var i = 0; i < methodNames.length; ++i) {
                    root[methodNames[i]] = methods[methodNames[i]];
                }
            }
        })();
    }).call(this, __webpack_require__(13), __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.TokenVerifier = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _base64url = __webpack_require__(64);
    var _base64url2 = _interopRequireDefault(_base64url);
    var _cryptoClients = __webpack_require__(85);
    var _decode = __webpack_require__(69);
    var _decode2 = _interopRequireDefault(_decode);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var TokenVerifier = exports.TokenVerifier = function() {
        function TokenVerifier(signingAlgorithm, rawPublicKey) {
            _classCallCheck(this, TokenVerifier);
            if (!(signingAlgorithm && rawPublicKey)) {
                throw new MissingParametersError("a signing algorithm and public key are required");
            }
            if (typeof signingAlgorithm !== "string") {
                throw "signing algorithm parameter must be a string";
            }
            signingAlgorithm = signingAlgorithm.toUpperCase();
            if (!_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm)) {
                throw "invalid signing algorithm";
            }
            this.tokenType = "JWT";
            this.cryptoClient = _cryptoClients.cryptoClients[signingAlgorithm];
            this.rawPublicKey = rawPublicKey;
        }
        _createClass(TokenVerifier, [ {
            key: "verify",
            value: function verify(token) {
                if (typeof token === "string") {
                    return this.verifyCompact(token);
                } else if ((typeof token === "undefined" ? "undefined" : _typeof(token)) === "object") {
                    return this.verifyExpanded(token);
                } else {
                    return false;
                }
            }
        }, {
            key: "verifyCompact",
            value: function verifyCompact(token) {
                var tokenParts = token.split(".");
                var signingInput = tokenParts[0] + "." + tokenParts[1];
                var signingInputHash = this.cryptoClient.createHash(signingInput);
                var derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]);
                return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);
            }
        }, {
            key: "verifyExpanded",
            value: function verifyExpanded(token) {
                var _this = this;
                var signingInput = [ token["header"].join("."), _base64url2.default.encode(token["payload"]) ].join(".");
                var signingInputHash = this.cryptoClient.createHash(signingInput);
                var verified = true;
                token["signature"].map(function(signature) {
                    var derSignatureBuffer = _this.cryptoClient.loadSignature(signature);
                    var signatureVerified = _this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, _this.rawPublicKey);
                    if (!signatureVerified) {
                        verified = false;
                    }
                });
                return verified;
            }
        } ]);
        return TokenVerifier;
    }();
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.derToJose = derToJose;
        exports.joseToDer = joseToDer;
        var asn1 = __webpack_require__(33);
        function base64UrlEscape(str) {
            return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
        }
        var ECDSASigValue = asn1.define("ECDSASigValue", function() {
            this.seq().obj(this.key("r").int(), this.key("s").int());
        });
        var seq = 16, int = 2;
        function getParamSize(keySize) {
            var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
            return result;
        }
        var paramBytesForAlg = {
            ES256: getParamSize(256),
            ES384: getParamSize(384),
            ES512: getParamSize(521)
        };
        function getParamBytesForAlg(alg) {
            var paramBytes = paramBytesForAlg[alg];
            if (paramBytes) {
                return paramBytes;
            }
            throw new Error('Unknown algorithm "' + alg + '"');
        }
        function bignumToBuf(bn, numBytes) {
            var buf = new Buffer(bn.toString("hex", numBytes), "hex");
            return buf;
        }
        function signatureAsBuffer(signature) {
            if (Buffer.isBuffer(signature)) {
                return new Buffer(signature);
            } else if ("string" === typeof signature) {
                return new Buffer(signature, "base64");
            }
            throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
        }
        function reduceBuffer(buf) {
            var padding = 0;
            for (var n = buf.length; padding < n && buf[padding] === 0; ) {
                ++padding;
            }
            var needsSign = buf[padding] >= 128;
            if (needsSign) {
                --padding;
                if (padding < 0) {
                    var old = buf;
                    buf = new Buffer(1 + buf.length);
                    buf[0] = 0;
                    old.copy(buf, 1);
                    return buf;
                }
            }
            if (padding === 0) {
                return buf;
            }
            buf = buf.slice(padding);
            return buf;
        }
        function derToJose(signature, alg) {
            signature = signatureAsBuffer(signature);
            var paramBytes = getParamBytesForAlg(alg);
            signature = ECDSASigValue.decode(signature, "der");
            var r = bignumToBuf(signature.r, paramBytes);
            var s = bignumToBuf(signature.s, paramBytes);
            signature = Buffer.concat([ r, s ], r.length + s.length);
            signature = signature.toString("base64");
            signature = base64UrlEscape(signature);
            return signature;
        }
        function joseToDer(signature, alg) {
            signature = signatureAsBuffer(signature);
            var paramBytes = getParamBytesForAlg(alg);
            var signatureBytes = signature.length;
            if (signatureBytes !== paramBytes * 2) {
                throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
            }
            var r = reduceBuffer(signature.slice(0, paramBytes));
            var s = reduceBuffer(signature.slice(paramBytes));
            var rsBytes = 1 + 1 + r.length + 1 + 1 + s.length;
            var oneByteLength = rsBytes < 128;
            signature = new Buffer((oneByteLength ? 2 : 3) + rsBytes);
            var offset = 0;
            signature[offset++] = seq | 32 | 0 << 6;
            if (oneByteLength) {
                signature[offset++] = rsBytes;
            } else {
                signature[offset++] = 128 | 1;
                signature[offset++] = rsBytes & 255;
            }
            signature[offset++] = int | 0 << 6;
            signature[offset++] = r.length;
            r.copy(signature, offset);
            offset += r.length;
            signature[offset++] = int | 0 << 6;
            signature[offset++] = s.length;
            s.copy(signature, offset);
            return signature;
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = normalizeEmail;
    var _isEmail = __webpack_require__(119);
    var _isEmail2 = _interopRequireDefault(_isEmail);
    var _merge = __webpack_require__(39);
    var _merge2 = _interopRequireDefault(_merge);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var default_normalize_email_options = {
        all_lowercase: true,
        gmail_lowercase: true,
        gmail_remove_dots: true,
        gmail_remove_subaddress: true,
        gmail_convert_googlemaildotcom: true,
        outlookdotcom_lowercase: true,
        outlookdotcom_remove_subaddress: true,
        yahoo_lowercase: true,
        yahoo_remove_subaddress: true,
        icloud_lowercase: true,
        icloud_remove_subaddress: true
    };
    var icloud_domains = [ "icloud.com", "me.com" ];
    var outlookdotcom_domains = [ "hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com" ];
    var yahoo_domains = [ "rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com" ];
    function normalizeEmail(email, options) {
        options = (0, _merge2.default)(options, default_normalize_email_options);
        if (!(0, _isEmail2.default)(email)) {
            return false;
        }
        var raw_parts = email.split("@");
        var domain = raw_parts.pop();
        var user = raw_parts.join("@");
        var parts = [ user, domain ];
        parts[1] = parts[1].toLowerCase();
        if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
            if (options.gmail_remove_subaddress) {
                parts[0] = parts[0].split("+")[0];
            }
            if (options.gmail_remove_dots) {
                parts[0] = parts[0].replace(/\./g, "");
            }
            if (!parts[0].length) {
                return false;
            }
            if (options.all_lowercase || options.gmail_lowercase) {
                parts[0] = parts[0].toLowerCase();
            }
            parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
        } else if (~icloud_domains.indexOf(parts[1])) {
            if (options.icloud_remove_subaddress) {
                parts[0] = parts[0].split("+")[0];
            }
            if (!parts[0].length) {
                return false;
            }
            if (options.all_lowercase || options.icloud_lowercase) {
                parts[0] = parts[0].toLowerCase();
            }
        } else if (~outlookdotcom_domains.indexOf(parts[1])) {
            if (options.outlookdotcom_remove_subaddress) {
                parts[0] = parts[0].split("+")[0];
            }
            if (!parts[0].length) {
                return false;
            }
            if (options.all_lowercase || options.outlookdotcom_lowercase) {
                parts[0] = parts[0].toLowerCase();
            }
        } else if (~yahoo_domains.indexOf(parts[1])) {
            if (options.yahoo_remove_subaddress) {
                var components = parts[0].split("-");
                parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
            }
            if (!parts[0].length) {
                return false;
            }
            if (options.all_lowercase || options.yahoo_lowercase) {
                parts[0] = parts[0].toLowerCase();
            }
        } else if (options.all_lowercase) {
            parts[0] = parts[0].toLowerCase();
        }
        return parts.join("@");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isWhitelisted;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isWhitelisted(str, chars) {
        (0, _assertString2.default)(str);
        for (var i = str.length - 1; i >= 0; i--) {
            if (chars.indexOf(str[i]) === -1) {
                return false;
            }
        }
        return true;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = whitelist;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function whitelist(str, chars) {
        (0, _assertString2.default)(str);
        return str.replace(new RegExp("[^" + chars + "]+", "g"), "");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = stripLow;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _blacklist = __webpack_require__(110);
    var _blacklist2 = _interopRequireDefault(_blacklist);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function stripLow(str, keep_new_lines) {
        (0, _assertString2.default)(str);
        var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
        return (0, _blacklist2.default)(str, chars);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = unescape;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function unescape(str) {
        (0, _assertString2.default)(str);
        return str.replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#96;/g, "`");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = escape;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function escape(str) {
        (0, _assertString2.default)(str);
        return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = trim;
    var _rtrim = __webpack_require__(111);
    var _rtrim2 = _interopRequireDefault(_rtrim);
    var _ltrim = __webpack_require__(112);
    var _ltrim2 = _interopRequireDefault(_ltrim);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function trim(str, chars) {
        return (0, _rtrim2.default)((0, _ltrim2.default)(str, chars), chars);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isDataURI;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var dataURI = /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9!\$&',\(\)\*\+,;=\-\._~:@\/\?%\s]*\s*$/i;
    function isDataURI(str) {
        (0, _assertString2.default)(str);
        return dataURI.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isBase64;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var notBase64 = /[^A-Z0-9+\/=]/i;
    function isBase64(str) {
        (0, _assertString2.default)(str);
        var len = str.length;
        if (!len || len % 4 !== 0 || notBase64.test(str)) {
            return false;
        }
        var firstPaddingChar = str.indexOf("=");
        return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.iso8601 = undefined;
    exports.default = function(str) {
        (0, _assertString2.default)(str);
        return iso8601.test(str);
    };
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var iso8601 = exports.iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isCurrency;
    var _merge = __webpack_require__(39);
    var _merge2 = _interopRequireDefault(_merge);
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function currencyRegex(options) {
        var symbol = "(\\" + options.symbol.replace(/\./g, "\\.") + ")" + (options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\" + options.thousands_separator + "\\d{3})*", valid_whole_dollar_amounts = [ "0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep ], whole_dollar_amount = "(" + valid_whole_dollar_amounts.join("|") + ")?", decimal_amount = "(\\" + options.decimal_separator + "\\d{2})?";
        var pattern = whole_dollar_amount + decimal_amount;
        if (options.allow_negatives && !options.parens_for_negatives) {
            if (options.negative_sign_after_digits) {
                pattern += negative;
            } else if (options.negative_sign_before_digits) {
                pattern = negative + pattern;
            }
        }
        if (options.allow_negative_sign_placeholder) {
            pattern = "( (?!\\-))?" + pattern;
        } else if (options.allow_space_after_symbol) {
            pattern = " ?" + pattern;
        } else if (options.allow_space_after_digits) {
            pattern += "( (?!$))?";
        }
        if (options.symbol_after_digits) {
            pattern += symbol;
        } else {
            pattern = symbol + pattern;
        }
        if (options.allow_negatives) {
            if (options.parens_for_negatives) {
                pattern = "(\\(" + pattern + "\\)|" + pattern + ")";
            } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
                pattern = negative + pattern;
            }
        }
        return new RegExp("^(?!-? )(?=.*\\d)" + pattern + "$");
    }
    var default_currency_options = {
        symbol: "$",
        require_symbol: false,
        allow_space_after_symbol: false,
        symbol_after_digits: false,
        allow_negatives: true,
        parens_for_negatives: false,
        negative_sign_before_digits: false,
        negative_sign_after_digits: false,
        allow_negative_sign_placeholder: false,
        thousands_separator: ",",
        decimal_separator: ".",
        allow_space_after_digits: false
    };
    function isCurrency(str, options) {
        (0, _assertString2.default)(str);
        options = (0, _merge2.default)(options, default_currency_options);
        return currencyRegex(options).test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isMobilePhone;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var phones = {
        "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
        "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
        "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
        "en-US": /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
        "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        "de-DE": /^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
        "da-DK": /^(\+?45)?(\d{8})$/,
        "el-GR": /^(\+?30)?(69\d{8})$/,
        "en-AU": /^(\+?61|0)4\d{8}$/,
        "en-GB": /^(\+?44|0)7\d{9}$/,
        "en-HK": /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
        "en-IN": /^(\+?91|0)?[789]\d{9}$/,
        "en-KE": /^(\+?254|0)?[7]\d{8}$/,
        "en-NG": /^(\+?234|0)?[789]\d{9}$/,
        "en-NZ": /^(\+?64|0)2\d{7,9}$/,
        "en-UG": /^(\+?256|0)?[7]\d{8}$/,
        "en-RW": /^(\+?250|0)?[7]\d{8}$/,
        "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
        "en-ZA": /^(\+?27|0)\d{9}$/,
        "en-ZM": /^(\+?26)?09[567]\d{7}$/,
        "es-ES": /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
        "fi-FI": /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
        "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
        "fr-FR": /^(\+?33|0)[67]\d{8}$/,
        "he-IL": /^(\+972|0)([23489]|5[0248]|77)[1-9]\d{6}/,
        "hu-HU": /^(\+?36)(20|30|70)\d{7}$/,
        "lt-LT": /^(\+370|8)\d{8}$/,
        "id-ID": /^(\+?62|0[1-9])[\s|\d]+$/,
        "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
        "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
        "ja-JP": /^(\+?81|0)\d{1,4}[ \-]?\d{1,4}[ \-]?\d{4}$/,
        "ms-MY": /^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
        "nb-NO": /^(\+?47)?[49]\d{7}$/,
        "nl-BE": /^(\+?32|0)4?\d{8}$/,
        "nn-NO": /^(\+?47)?[49]\d{7}$/,
        "pl-PL": /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
        "pt-BR": /^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,
        "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
        "ro-RO": /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
        "en-PK": /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
        "ru-RU": /^(\+?7|8)?9\d{9}$/,
        "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
        "tr-TR": /^(\+?90|0)?5\d{9}$/,
        "vi-VN": /^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
        "zh-CN": /^(\+?0?86\-?)?1[345789]\d{9}$/,
        "zh-TW": /^(\+?886\-?|0)?9\d{8}$/
    };
    phones["en-CA"] = phones["en-US"];
    phones["fr-BE"] = phones["nl-BE"];
    phones["zh-HK"] = phones["en-HK"];
    function isMobilePhone(str, locale) {
        (0, _assertString2.default)(str);
        if (locale in phones) {
            return phones[locale].test(str);
        } else if (locale === "any") {
            return !!Object.values(phones).find(function(phone) {
                return phone.test(str);
            });
        }
        return false;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isISSN;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var issn = "^\\d{4}-?\\d{3}[\\dX]$";
    function isISSN(str) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, _assertString2.default)(str);
        var testIssn = issn;
        testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
        testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
        if (!testIssn.test(str)) {
            return false;
        }
        var issnDigits = str.replace("-", "");
        var position = 8;
        var checksum = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for (var _iterator = issnDigits[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var digit = _step.value;
                var digitValue = digit.toUpperCase() === "X" ? 10 : +digit;
                checksum += digitValue * position;
                --position;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return checksum % 11 === 0;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isISBN;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
    var isbn13Maybe = /^(?:[0-9]{13})$/;
    var factor = [ 1, 3 ];
    function isISBN(str) {
        var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        (0, _assertString2.default)(str);
        version = String(version);
        if (!version) {
            return isISBN(str, 10) || isISBN(str, 13);
        }
        var sanitized = str.replace(/[\s-]+/g, "");
        var checksum = 0;
        var i = void 0;
        if (version === "10") {
            if (!isbn10Maybe.test(sanitized)) {
                return false;
            }
            for (i = 0; i < 9; i++) {
                checksum += (i + 1) * sanitized.charAt(i);
            }
            if (sanitized.charAt(9) === "X") {
                checksum += 10 * 10;
            } else {
                checksum += 10 * sanitized.charAt(9);
            }
            if (checksum % 11 === 0) {
                return !!sanitized;
            }
        } else if (version === "13") {
            if (!isbn13Maybe.test(sanitized)) {
                return false;
            }
            for (i = 0; i < 12; i++) {
                checksum += factor[i % 2] * sanitized.charAt(i);
            }
            if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
                return !!sanitized;
            }
        }
        return false;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isISIN;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
    function isISIN(str) {
        (0, _assertString2.default)(str);
        if (!isin.test(str)) {
            return false;
        }
        var checksumStr = str.replace(/[A-Z]/g, function(character) {
            return parseInt(character, 36);
        });
        var sum = 0;
        var digit = void 0;
        var tmpNum = void 0;
        var shouldDouble = true;
        for (var i = checksumStr.length - 2; i >= 0; i--) {
            digit = checksumStr.substring(i, i + 1);
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += tmpNum + 1;
                } else {
                    sum += tmpNum;
                }
            } else {
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        return parseInt(str.substr(str.length - 1), 10) === (1e4 - sum) % 10;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isCreditCard;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|62[0-9]{14})$/;
    function isCreditCard(str) {
        (0, _assertString2.default)(str);
        var sanitized = str.replace(/[- ]+/g, "");
        if (!creditCard.test(sanitized)) {
            return false;
        }
        var sum = 0;
        var digit = void 0;
        var tmpNum = void 0;
        var shouldDouble = void 0;
        for (var i = sanitized.length - 1; i >= 0; i--) {
            digit = sanitized.substring(i, i + 1);
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += tmpNum % 10 + 1;
                } else {
                    sum += tmpNum;
                }
            } else {
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        return !!(sum % 10 === 0 ? sanitized : false);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = isIn;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _toString = __webpack_require__(71);
    var _toString2 = _interopRequireDefault(_toString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isIn(str, options) {
        (0, _assertString2.default)(str);
        var i = void 0;
        if (Object.prototype.toString.call(options) === "[object Array]") {
            var array = [];
            for (i in options) {
                if ({}.hasOwnProperty.call(options, i)) {
                    array[i] = (0, _toString2.default)(options[i]);
                }
            }
            return array.indexOf(str) >= 0;
        } else if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
            return options.hasOwnProperty(str);
        } else if (options && typeof options.indexOf === "function") {
            return options.indexOf(str) >= 0;
        }
        return false;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isBefore;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _toDate = __webpack_require__(72);
    var _toDate2 = _interopRequireDefault(_toDate);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isBefore(str) {
        var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
        (0, _assertString2.default)(str);
        var comparison = (0, _toDate2.default)(date);
        var original = (0, _toDate2.default)(str);
        return !!(original && comparison && original < comparison);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isAfter;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _toDate = __webpack_require__(72);
    var _toDate2 = _interopRequireDefault(_toDate);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isAfter(str) {
        var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
        (0, _assertString2.default)(str);
        var comparison = (0, _toDate2.default)(date);
        var original = (0, _toDate2.default)(str);
        return !!(original && comparison && original > comparison);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isMongoId;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _isHexadecimal = __webpack_require__(113);
    var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isMongoId(str) {
        (0, _assertString2.default)(str);
        return (0, _isHexadecimal2.default)(str) && str.length === 24;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isUUID;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var uuid = {
        3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };
    function isUUID(str) {
        var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all";
        (0, _assertString2.default)(str);
        var pattern = uuid[version];
        return pattern && pattern.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = isLength;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isLength(str, options) {
        (0, _assertString2.default)(str);
        var min = void 0;
        var max = void 0;
        if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
            min = options.min || 0;
            max = options.max;
        } else {
            min = arguments[1];
            max = arguments[2];
        }
        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
        var len = str.length - surrogatePairs.length;
        return len >= min && (typeof max === "undefined" || len <= max);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isEmpty;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isEmpty(str) {
        (0, _assertString2.default)(str);
        return str.length === 0;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = isJSON;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isJSON(str) {
        (0, _assertString2.default)(str);
        try {
            var obj = JSON.parse(str);
            return !!obj && (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object";
        } catch (e) {}
        return false;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isMD5;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var md5 = /^[a-f0-9]{32}$/;
    function isMD5(str) {
        (0, _assertString2.default)(str);
        return md5.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isISRC;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
    function isISRC(str) {
        (0, _assertString2.default)(str);
        return isrc.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isHexColor;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;
    function isHexColor(str) {
        (0, _assertString2.default)(str);
        return hexcolor.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isDivisibleBy;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _toFloat = __webpack_require__(120);
    var _toFloat2 = _interopRequireDefault(_toFloat);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isDivisibleBy(str, num) {
        (0, _assertString2.default)(str);
        return (0, _toFloat2.default)(str) % parseInt(num, 10) === 0;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isDecimal;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var decimal = /^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/;
    function isDecimal(str) {
        (0, _assertString2.default)(str);
        return str !== "" && decimal.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isFloat;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var float = /^(?:[-+])?(?:[0-9]+)?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/;
    function isFloat(str, options) {
        (0, _assertString2.default)(str);
        options = options || {};
        if (str === "" || str === ".") {
            return false;
        }
        return float.test(str) && (!options.hasOwnProperty("min") || str >= options.min) && (!options.hasOwnProperty("max") || str <= options.max) && (!options.hasOwnProperty("lt") || str < options.lt) && (!options.hasOwnProperty("gt") || str > options.gt);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isInt;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
    var intLeadingZeroes = /^[-+]?[0-9]+$/;
    function isInt(str, options) {
        (0, _assertString2.default)(str);
        options = options || {};
        var regex = options.hasOwnProperty("allow_leading_zeroes") && !options.allow_leading_zeroes ? int : intLeadingZeroes;
        var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
        var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
        var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
        var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
        return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isSurrogatePair;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    function isSurrogatePair(str) {
        (0, _assertString2.default)(str);
        return surrogatePair.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isMultibyte;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var multibyte = /[^\x00-\x7F]/;
    function isMultibyte(str) {
        (0, _assertString2.default)(str);
        return multibyte.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isVariableWidth;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _isFullWidth = __webpack_require__(115);
    var _isHalfWidth = __webpack_require__(114);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isVariableWidth(str) {
        (0, _assertString2.default)(str);
        return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isAscii;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var ascii = /^[\x00-\x7F]+$/;
    function isAscii(str) {
        (0, _assertString2.default)(str);
        return ascii.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isUppercase;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isUppercase(str) {
        (0, _assertString2.default)(str);
        return str === str.toUpperCase();
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isLowercase;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isLowercase(str) {
        (0, _assertString2.default)(str);
        return str === str.toLowerCase();
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isNumeric;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var numeric = /^[-+]?[0-9]+$/;
    function isNumeric(str) {
        (0, _assertString2.default)(str);
        return numeric.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isAlphanumeric;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _alpha = __webpack_require__(116);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isAlphanumeric(str) {
        var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
        (0, _assertString2.default)(str);
        if (locale in _alpha.alphanumeric) {
            return _alpha.alphanumeric[locale].test(str);
        }
        throw new Error("Invalid locale '" + locale + "'");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isAlpha;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _alpha = __webpack_require__(116);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isAlpha(str) {
        var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
        (0, _assertString2.default)(str);
        if (locale in _alpha.alpha) {
            return _alpha.alpha[locale].test(str);
        }
        throw new Error("Invalid locale '" + locale + "'");
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isBoolean;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function isBoolean(str) {
        (0, _assertString2.default)(str);
        return [ "true", "false", "1", "0" ].indexOf(str) >= 0;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isMACAddress;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
    function isMACAddress(str) {
        (0, _assertString2.default)(str);
        return macAddress.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = isURL;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _isFQDN = __webpack_require__(70);
    var _isFQDN2 = _interopRequireDefault(_isFQDN);
    var _isIP = __webpack_require__(117);
    var _isIP2 = _interopRequireDefault(_isIP);
    var _merge = __webpack_require__(39);
    var _merge2 = _interopRequireDefault(_merge);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var default_url_options = {
        protocols: [ "http", "https", "ftp" ],
        require_tld: true,
        require_protocol: false,
        require_host: true,
        require_valid_protocol: true,
        allow_underscores: false,
        allow_trailing_dot: false,
        allow_protocol_relative_urls: false
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function checkHost(host, matches) {
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            if (host === match || isRegExp(match) && match.test(host)) {
                return true;
            }
        }
        return false;
    }
    function isURL(url, options) {
        (0, _assertString2.default)(url);
        if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
            return false;
        }
        if (url.indexOf("mailto:") === 0) {
            return false;
        }
        options = (0, _merge2.default)(options, default_url_options);
        var protocol = void 0, auth = void 0, host = void 0, hostname = void 0, port = void 0, port_str = void 0, split = void 0, ipv6 = void 0;
        split = url.split("#");
        url = split.shift();
        split = url.split("?");
        url = split.shift();
        split = url.split("://");
        if (split.length > 1) {
            protocol = split.shift();
            if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
                return false;
            }
        } else if (options.require_protocol) {
            return false;
        } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === "//") {
            split[0] = url.substr(2);
        }
        url = split.join("://");
        split = url.split("/");
        url = split.shift();
        if (url === "" && !options.require_host) {
            return true;
        }
        split = url.split("@");
        if (split.length > 1) {
            auth = split.shift();
            if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
                return false;
            }
        }
        hostname = split.join("@");
        port_str = null;
        ipv6 = null;
        var ipv6_match = hostname.match(wrapped_ipv6);
        if (ipv6_match) {
            host = "";
            ipv6 = ipv6_match[1];
            port_str = ipv6_match[2] || null;
        } else {
            split = hostname.split(":");
            host = split.shift();
            if (split.length) {
                port_str = split.join(":");
            }
        }
        if (port_str !== null) {
            port = parseInt(port_str, 10);
            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
                return false;
            }
        }
        if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, 
        _isIP2.default)(ipv6, 6)) && host !== "localhost") {
            return false;
        }
        host = host || ipv6;
        if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
            return false;
        }
        if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
            return false;
        }
        return true;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = matches;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function matches(str, pattern, modifiers) {
        (0, _assertString2.default)(str);
        if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
            pattern = new RegExp(pattern, modifiers);
        }
        return pattern.test(str);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = contains;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    var _toString = __webpack_require__(71);
    var _toString2 = _interopRequireDefault(_toString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function contains(str, elem) {
        (0, _assertString2.default)(str);
        return str.indexOf((0, _toString2.default)(elem)) >= 0;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = equals;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function equals(str, comparison) {
        (0, _assertString2.default)(str);
        return str === comparison;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = toBoolean;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function toBoolean(str, strict) {
        (0, _assertString2.default)(str);
        if (strict) {
            return str === "1" || str === "true";
        }
        return str !== "0" && str !== "false" && str !== "";
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = toInt;
    var _assertString = __webpack_require__(1);
    var _assertString2 = _interopRequireDefault(_assertString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function toInt(str, radix) {
        (0, _assertString2.default)(str);
        return parseInt(str, radix || 10);
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _toDate = __webpack_require__(72);
    var _toDate2 = _interopRequireDefault(_toDate);
    var _toFloat = __webpack_require__(120);
    var _toFloat2 = _interopRequireDefault(_toFloat);
    var _toInt = __webpack_require__(325);
    var _toInt2 = _interopRequireDefault(_toInt);
    var _toBoolean = __webpack_require__(324);
    var _toBoolean2 = _interopRequireDefault(_toBoolean);
    var _equals = __webpack_require__(323);
    var _equals2 = _interopRequireDefault(_equals);
    var _contains = __webpack_require__(322);
    var _contains2 = _interopRequireDefault(_contains);
    var _matches = __webpack_require__(321);
    var _matches2 = _interopRequireDefault(_matches);
    var _isEmail = __webpack_require__(119);
    var _isEmail2 = _interopRequireDefault(_isEmail);
    var _isURL = __webpack_require__(320);
    var _isURL2 = _interopRequireDefault(_isURL);
    var _isMACAddress = __webpack_require__(319);
    var _isMACAddress2 = _interopRequireDefault(_isMACAddress);
    var _isIP = __webpack_require__(117);
    var _isIP2 = _interopRequireDefault(_isIP);
    var _isFQDN = __webpack_require__(70);
    var _isFQDN2 = _interopRequireDefault(_isFQDN);
    var _isBoolean = __webpack_require__(318);
    var _isBoolean2 = _interopRequireDefault(_isBoolean);
    var _isAlpha = __webpack_require__(317);
    var _isAlpha2 = _interopRequireDefault(_isAlpha);
    var _isAlphanumeric = __webpack_require__(316);
    var _isAlphanumeric2 = _interopRequireDefault(_isAlphanumeric);
    var _isNumeric = __webpack_require__(315);
    var _isNumeric2 = _interopRequireDefault(_isNumeric);
    var _isLowercase = __webpack_require__(314);
    var _isLowercase2 = _interopRequireDefault(_isLowercase);
    var _isUppercase = __webpack_require__(313);
    var _isUppercase2 = _interopRequireDefault(_isUppercase);
    var _isAscii = __webpack_require__(312);
    var _isAscii2 = _interopRequireDefault(_isAscii);
    var _isFullWidth = __webpack_require__(115);
    var _isFullWidth2 = _interopRequireDefault(_isFullWidth);
    var _isHalfWidth = __webpack_require__(114);
    var _isHalfWidth2 = _interopRequireDefault(_isHalfWidth);
    var _isVariableWidth = __webpack_require__(311);
    var _isVariableWidth2 = _interopRequireDefault(_isVariableWidth);
    var _isMultibyte = __webpack_require__(310);
    var _isMultibyte2 = _interopRequireDefault(_isMultibyte);
    var _isSurrogatePair = __webpack_require__(309);
    var _isSurrogatePair2 = _interopRequireDefault(_isSurrogatePair);
    var _isInt = __webpack_require__(308);
    var _isInt2 = _interopRequireDefault(_isInt);
    var _isFloat = __webpack_require__(307);
    var _isFloat2 = _interopRequireDefault(_isFloat);
    var _isDecimal = __webpack_require__(306);
    var _isDecimal2 = _interopRequireDefault(_isDecimal);
    var _isHexadecimal = __webpack_require__(113);
    var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
    var _isDivisibleBy = __webpack_require__(305);
    var _isDivisibleBy2 = _interopRequireDefault(_isDivisibleBy);
    var _isHexColor = __webpack_require__(304);
    var _isHexColor2 = _interopRequireDefault(_isHexColor);
    var _isISRC = __webpack_require__(303);
    var _isISRC2 = _interopRequireDefault(_isISRC);
    var _isMD = __webpack_require__(302);
    var _isMD2 = _interopRequireDefault(_isMD);
    var _isJSON = __webpack_require__(301);
    var _isJSON2 = _interopRequireDefault(_isJSON);
    var _isEmpty = __webpack_require__(300);
    var _isEmpty2 = _interopRequireDefault(_isEmpty);
    var _isLength = __webpack_require__(299);
    var _isLength2 = _interopRequireDefault(_isLength);
    var _isByteLength = __webpack_require__(118);
    var _isByteLength2 = _interopRequireDefault(_isByteLength);
    var _isUUID = __webpack_require__(298);
    var _isUUID2 = _interopRequireDefault(_isUUID);
    var _isMongoId = __webpack_require__(297);
    var _isMongoId2 = _interopRequireDefault(_isMongoId);
    var _isAfter = __webpack_require__(296);
    var _isAfter2 = _interopRequireDefault(_isAfter);
    var _isBefore = __webpack_require__(295);
    var _isBefore2 = _interopRequireDefault(_isBefore);
    var _isIn = __webpack_require__(294);
    var _isIn2 = _interopRequireDefault(_isIn);
    var _isCreditCard = __webpack_require__(293);
    var _isCreditCard2 = _interopRequireDefault(_isCreditCard);
    var _isISIN = __webpack_require__(292);
    var _isISIN2 = _interopRequireDefault(_isISIN);
    var _isISBN = __webpack_require__(291);
    var _isISBN2 = _interopRequireDefault(_isISBN);
    var _isISSN = __webpack_require__(290);
    var _isISSN2 = _interopRequireDefault(_isISSN);
    var _isMobilePhone = __webpack_require__(289);
    var _isMobilePhone2 = _interopRequireDefault(_isMobilePhone);
    var _isCurrency = __webpack_require__(288);
    var _isCurrency2 = _interopRequireDefault(_isCurrency);
    var _isISO = __webpack_require__(287);
    var _isISO2 = _interopRequireDefault(_isISO);
    var _isBase = __webpack_require__(286);
    var _isBase2 = _interopRequireDefault(_isBase);
    var _isDataURI = __webpack_require__(285);
    var _isDataURI2 = _interopRequireDefault(_isDataURI);
    var _ltrim = __webpack_require__(112);
    var _ltrim2 = _interopRequireDefault(_ltrim);
    var _rtrim = __webpack_require__(111);
    var _rtrim2 = _interopRequireDefault(_rtrim);
    var _trim = __webpack_require__(284);
    var _trim2 = _interopRequireDefault(_trim);
    var _escape = __webpack_require__(283);
    var _escape2 = _interopRequireDefault(_escape);
    var _unescape = __webpack_require__(282);
    var _unescape2 = _interopRequireDefault(_unescape);
    var _stripLow = __webpack_require__(281);
    var _stripLow2 = _interopRequireDefault(_stripLow);
    var _whitelist = __webpack_require__(280);
    var _whitelist2 = _interopRequireDefault(_whitelist);
    var _blacklist = __webpack_require__(110);
    var _blacklist2 = _interopRequireDefault(_blacklist);
    var _isWhitelisted = __webpack_require__(279);
    var _isWhitelisted2 = _interopRequireDefault(_isWhitelisted);
    var _normalizeEmail = __webpack_require__(278);
    var _normalizeEmail2 = _interopRequireDefault(_normalizeEmail);
    var _toString = __webpack_require__(71);
    var _toString2 = _interopRequireDefault(_toString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var version = "7.2.0";
    var validator = {
        version,
        toDate: _toDate2.default,
        toFloat: _toFloat2.default,
        toInt: _toInt2.default,
        toBoolean: _toBoolean2.default,
        equals: _equals2.default,
        contains: _contains2.default,
        matches: _matches2.default,
        isEmail: _isEmail2.default,
        isURL: _isURL2.default,
        isMACAddress: _isMACAddress2.default,
        isIP: _isIP2.default,
        isFQDN: _isFQDN2.default,
        isBoolean: _isBoolean2.default,
        isAlpha: _isAlpha2.default,
        isAlphanumeric: _isAlphanumeric2.default,
        isNumeric: _isNumeric2.default,
        isLowercase: _isLowercase2.default,
        isUppercase: _isUppercase2.default,
        isAscii: _isAscii2.default,
        isFullWidth: _isFullWidth2.default,
        isHalfWidth: _isHalfWidth2.default,
        isVariableWidth: _isVariableWidth2.default,
        isMultibyte: _isMultibyte2.default,
        isSurrogatePair: _isSurrogatePair2.default,
        isInt: _isInt2.default,
        isFloat: _isFloat2.default,
        isDecimal: _isDecimal2.default,
        isHexadecimal: _isHexadecimal2.default,
        isDivisibleBy: _isDivisibleBy2.default,
        isHexColor: _isHexColor2.default,
        isISRC: _isISRC2.default,
        isMD5: _isMD2.default,
        isJSON: _isJSON2.default,
        isEmpty: _isEmpty2.default,
        isLength: _isLength2.default,
        isByteLength: _isByteLength2.default,
        isUUID: _isUUID2.default,
        isMongoId: _isMongoId2.default,
        isAfter: _isAfter2.default,
        isBefore: _isBefore2.default,
        isIn: _isIn2.default,
        isCreditCard: _isCreditCard2.default,
        isISIN: _isISIN2.default,
        isISBN: _isISBN2.default,
        isISSN: _isISSN2.default,
        isMobilePhone: _isMobilePhone2.default,
        isCurrency: _isCurrency2.default,
        isISO8601: _isISO2.default,
        isBase64: _isBase2.default,
        isDataURI: _isDataURI2.default,
        ltrim: _ltrim2.default,
        rtrim: _rtrim2.default,
        trim: _trim2.default,
        escape: _escape2.default,
        unescape: _unescape2.default,
        stripLow: _stripLow2.default,
        whitelist: _whitelist2.default,
        blacklist: _blacklist2.default,
        isWhitelisted: _isWhitelisted2.default,
        normalizeEmail: _normalizeEmail2.default,
        toString: _toString2.default
    };
    exports.default = validator;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bn = __webpack_require__(18);
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object") sig = parseBytes(sig);
        if (Array.isArray(sig)) {
            sig = {
                R: sig.slice(0, eddsa.encodingLength),
                S: sig.slice(eddsa.encodingLength)
            };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R)) this._R = sig.R;
        if (sig.S instanceof bn) this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, function S() {
        return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, function R() {
        return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, function Rencoded() {
        return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, function Sencoded() {
        return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub)) this._pub = params.pub; else this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair) return pub;
        return new KeyPair(eddsa, {
            pub
        });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair) return secret;
        return new KeyPair(eddsa, {
            secret
        });
    };
    KeyPair.prototype.secret = function secret() {
        return this._secret;
    };
    cachedProperty(KeyPair, function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, function pub() {
        if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
    });
    cachedProperty(KeyPair, function priv() {
        return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var hash = __webpack_require__(36);
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = __webpack_require__(328);
    var Signature = __webpack_require__(327);
    function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA)) return new EDDSA(curve);
        var curve = elliptic.curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({
            R,
            S,
            Rencoded
        });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
        var hash = this.hash();
        for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);
        return utils.intFromLE(hash.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature) return sig;
        return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bn = __webpack_require__(18);
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var assert = utils.assert;
    function Signature(options, enc) {
        if (options instanceof Signature) return options;
        if (this._importDER(options, enc)) return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new bn(options.r, 16);
        this.s = new bn(options.s, 16);
        if (options.recoveryParam !== null) this.recoveryParam = options.recoveryParam; else this.recoveryParam = null;
    }
    module.exports = Signature;
    function Position() {
        this.place = 0;
    }
    function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
            return initial;
        }
        var octetLen = initial & 15;
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
            val <<= 8;
            val |= buf[off];
        }
        p.place = off;
        return val;
    }
    function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
            i++;
        }
        if (i === 0) {
            return buf;
        }
        return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
            return false;
        }
        var len = getLength(data, p);
        if (len + p.place !== data.length) {
            return false;
        }
        if (data[p.place++] !== 2) {
            return false;
        }
        var rlen = getLength(data, p);
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
            return false;
        }
        var slen = getLength(data, p);
        if (data.length !== slen + p.place) {
            return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0 && r[1] & 128) {
            r = r.slice(1);
        }
        if (s[0] === 0 && s[1] & 128) {
            s = s.slice(1);
        }
        this.r = new bn(r);
        this.s = new bn(s);
        this.recoveryParam = null;
        return true;
    };
    function constructLength(arr, len) {
        if (len < 128) {
            arr.push(len);
            return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
            arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128) r = [ 0 ].concat(r);
        if (s[0] & 128) s = [ 0 ].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
            s = s.slice(1);
        }
        var arr = [ 2 ];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [ 48 ];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bn = __webpack_require__(18);
    function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv) this._importPrivate(options.priv, options.privEnc);
        if (options.pub) this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair) return pub;
        return new KeyPair(ec, {
            pub,
            pubEnc: enc
        });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair) return priv;
        return new KeyPair(ec, {
            priv,
            privEnc: enc
        });
    };
    KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity()) return {
            result: false,
            reason: "Invalid public key"
        };
        if (!pub.validate()) return {
            result: false,
            reason: "Public key is not a point"
        };
        if (!pub.mul(this.ec.curve.n).isInfinity()) return {
            result: false,
            reason: "Public key * N != O"
        };
        return {
            result: true,
            reason: null
        };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
            enc = compact;
            compact = null;
        }
        if (!this.pub) this.pub = this.ec.g.mul(this.priv);
        if (!enc) return this.pub;
        return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex") return this.priv.toString(16, 2); else return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new bn(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
            this.pub = this.ec.curve.point(key.x, key.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
        return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bn = __webpack_require__(18);
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var KeyPair = __webpack_require__(331);
    var Signature = __webpack_require__(330);
    function EC(options) {
        if (!(this instanceof EC)) return new EC(options);
        if (typeof options === "string") {
            assert(elliptic.curves.hasOwnProperty(options), "Unknown curve " + options);
            options = elliptic.curves[options];
        }
        if (options instanceof elliptic.curves.PresetCurve) options = {
            curve: options
        };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options) options = {};
        var drbg = new elliptic.hmacDRBG({
            hash: this.hash,
            pers: options.pers,
            entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
            nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new bn(2));
        do {
            var priv = new bn(drbg.generate(bytes));
            if (priv.cmp(ns2) > 0) continue;
            priv.iaddn(1);
            return this.keyFromPrivate(priv);
        } while (true);
    };
    EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0) msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n); else return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
            options = enc;
            enc = null;
        }
        if (!options) options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new bn(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray();
        for (var i = bkey.length; i < bytes; i++) bkey.unshift(0);
        var nonce = msg.toArray();
        for (var i = nonce.length; i < bytes; i++) nonce.unshift(0);
        var drbg = new elliptic.hmacDRBG({
            hash: this.hash,
            entropy: bkey,
            nonce
        });
        var ns1 = this.n.sub(new bn(1));
        do {
            var k = new bn(drbg.generate(this.n.byteLength()));
            k = this._truncateToN(k, true);
            if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
            var kp = this.g.mul(k);
            if (kp.isInfinity()) continue;
            var kpX = kp.getX();
            var r = kpX.umod(this.n);
            if (r.cmpn(0) === 0) continue;
            var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
            s = s.umod(this.n);
            if (s.cmpn(0) === 0) continue;
            if (options.canonical && s.cmp(this.nh) > 0) s = this.n.sub(s);
            var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
            return new Signature({
                r,
                s,
                recoveryParam
            });
        } while (true);
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new bn(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new bn(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
        r = this.curve.pointFromX(r, isYOdd);
        var eNeg = e.neg().umod(n);
        var rInv = signature.r.invm(n);
        return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null) return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
            var Qprime = this.recoverPubKey(e, signature, i);
            if (Qprime.eq(Q)) return i;
        }
        throw new Error("Unable to find valid recovery factor");
    };
}, function(module, exports) {
    module.exports = {
        doubles: {
            step: 4,
            points: [ [ "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821" ], [ "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf" ], [ "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695" ], [ "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9" ], [ "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36" ], [ "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f" ], [ "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999" ], [ "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09" ], [ "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d" ], [ "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088" ], [ "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d" ], [ "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8" ], [ "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a" ], [ "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453" ], [ "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160" ], [ "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0" ], [ "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6" ], [ "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589" ], [ "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17" ], [ "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda" ], [ "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd" ], [ "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2" ], [ "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6" ], [ "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f" ], [ "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01" ], [ "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3" ], [ "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f" ], [ "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7" ], [ "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78" ], [ "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1" ], [ "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150" ], [ "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82" ], [ "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc" ], [ "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b" ], [ "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51" ], [ "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45" ], [ "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120" ], [ "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84" ], [ "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d" ], [ "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d" ], [ "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8" ], [ "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8" ], [ "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac" ], [ "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f" ], [ "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962" ], [ "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907" ], [ "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec" ], [ "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d" ], [ "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414" ], [ "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd" ], [ "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0" ], [ "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811" ], [ "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1" ], [ "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c" ], [ "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73" ], [ "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd" ], [ "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405" ], [ "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589" ], [ "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e" ], [ "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27" ], [ "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1" ], [ "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482" ], [ "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945" ], [ "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573" ], [ "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82" ] ]
        },
        naf: {
            wnd: 7,
            points: [ [ "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672" ], [ "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6" ], [ "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da" ], [ "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37" ], [ "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b" ], [ "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81" ], [ "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58" ], [ "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77" ], [ "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a" ], [ "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c" ], [ "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67" ], [ "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402" ], [ "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55" ], [ "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482" ], [ "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82" ], [ "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396" ], [ "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49" ], [ "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf" ], [ "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a" ], [ "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7" ], [ "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933" ], [ "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a" ], [ "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6" ], [ "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37" ], [ "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e" ], [ "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6" ], [ "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476" ], [ "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40" ], [ "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61" ], [ "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683" ], [ "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5" ], [ "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b" ], [ "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417" ], [ "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868" ], [ "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a" ], [ "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6" ], [ "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996" ], [ "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e" ], [ "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d" ], [ "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2" ], [ "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e" ], [ "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437" ], [ "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311" ], [ "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4" ], [ "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575" ], [ "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d" ], [ "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d" ], [ "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629" ], [ "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06" ], [ "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374" ], [ "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee" ], [ "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1" ], [ "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b" ], [ "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661" ], [ "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6" ], [ "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e" ], [ "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d" ], [ "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc" ], [ "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4" ], [ "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c" ], [ "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b" ], [ "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913" ], [ "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154" ], [ "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865" ], [ "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc" ], [ "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224" ], [ "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e" ], [ "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6" ], [ "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511" ], [ "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b" ], [ "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2" ], [ "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c" ], [ "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3" ], [ "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d" ], [ "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700" ], [ "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4" ], [ "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196" ], [ "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4" ], [ "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257" ], [ "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13" ], [ "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096" ], [ "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38" ], [ "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f" ], [ "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448" ], [ "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a" ], [ "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4" ], [ "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437" ], [ "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7" ], [ "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d" ], [ "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a" ], [ "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54" ], [ "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77" ], [ "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517" ], [ "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10" ], [ "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125" ], [ "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e" ], [ "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1" ], [ "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2" ], [ "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423" ], [ "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8" ], [ "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758" ], [ "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375" ], [ "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d" ], [ "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec" ], [ "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0" ], [ "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c" ], [ "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4" ], [ "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f" ], [ "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649" ], [ "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826" ], [ "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5" ], [ "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87" ], [ "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b" ], [ "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc" ], [ "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c" ], [ "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f" ], [ "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a" ], [ "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46" ], [ "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f" ], [ "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03" ], [ "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08" ], [ "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8" ], [ "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373" ], [ "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3" ], [ "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8" ], [ "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1" ], [ "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9" ] ]
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curves = exports;
    var hash = __webpack_require__(36);
    var elliptic = __webpack_require__(16);
    var assert = elliptic.utils.assert;
    function PresetCurve(options) {
        if (options.type === "short") this.curve = new elliptic.curve.short(options); else if (options.type === "edwards") this.curve = new elliptic.curve.edwards(options); else this.curve = new elliptic.curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    value: curve
                });
                return curve;
            }
        });
    }
    defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: [ "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811" ]
    });
    defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: [ "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34" ]
    });
    defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: [ "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5" ]
    });
    defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f " + "5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 " + "f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: [ "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 " + "5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 " + "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f" ]
    });
    defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b " + "99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd " + "3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 " + "f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: [ "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 " + "053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 " + "a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 " + "579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 " + "3fad0761 353c7086 a272c240 88be9476 9fd16650" ]
    });
    defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "0",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [ "9" ]
    });
    defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [ "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658" ]
    });
    var pre;
    try {
        pre = __webpack_require__(333);
    } catch (e) {
        pre = undefined;
    }
    defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [ {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        } ],
        gRed: false,
        g: [ "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre ]
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = __webpack_require__(57);
    var elliptic = __webpack_require__(16);
    var bn = __webpack_require__(18);
    var inherits = __webpack_require__(3);
    var Base = curve.base;
    var assert = elliptic.utils.assert;
    function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new bn(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new bn(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new bn(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA) return num.redNeg(); else return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC) return num; else return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new bn(x, 16);
        if (!x.red) x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y = rhs.redMul(lhs.redInvm()).redSqrt();
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
        return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new bn(y, 16);
        if (!y.red) y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.one);
        var rhs = y2.redMul(this.d).redAdd(this.one);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
            if (odd) throw new Error("invalid point"); else return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
        if (x.isOdd() !== odd) x = x.redNeg();
        return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity()) return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
            this.x = this.curve.zero;
            this.y = this.curve.one;
            this.z = this.curve.one;
            this.t = this.curve.zero;
            this.zOne = true;
        } else {
            this.x = new bn(x, 16);
            this.y = new bn(y, 16);
            this.z = z ? new bn(z, 16) : this.curve.one;
            this.t = t && new bn(t, 16);
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
            this.zOne = this.z === this.curve.one;
            if (this.curve.extended && !this.t) {
                this.t = this.x.redMul(this.y);
                if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
            }
        }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
    };
    Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        if (this.curve.twisted) {
            var e = this.curve._mulA(c);
            var f = e.redAdd(d);
            if (this.zOne) {
                nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                ny = f.redMul(e.redSub(d));
                nz = f.redSqr().redSub(f).redSub(f);
            } else {
                var h = this.z.redSqr();
                var j = f.redSub(h).redISub(h);
                nx = b.redSub(c).redISub(d).redMul(j);
                ny = f.redMul(e.redSub(d));
                nz = f.redMul(j);
            }
        } else {
            var e = c.redAdd(d);
            var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
            var j = e.redSub(h).redSub(h);
            nx = this.curve._mulC(b.redISub(e)).redMul(j);
            ny = this.curve._mulC(e).redMul(c.redISub(d));
            nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
        if (this.isInfinity()) return this;
        if (this.curve.extended) return this._extDbl(); else return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
            ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
            nz = f.redMul(g);
        } else {
            ny = a.redMul(g).redMul(d.redSub(c));
            nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
        if (this.isInfinity()) return p;
        if (p.isInfinity()) return this;
        if (this.curve.extended) return this._extAdd(p); else return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k); else return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
    };
    Point.prototype.normalize = function normalize() {
        if (this.zOne) return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t) this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
    };
    Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = __webpack_require__(57);
    var bn = __webpack_require__(18);
    var inherits = __webpack_require__(3);
    var Base = curve.base;
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new bn(conf.a, 16).toRed(this.red);
        this.b = new bn(conf.b, 16).toRed(this.red);
        this.i4 = new bn(4).toRed(this.red).redInvm();
        this.two = new bn(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
            this.x = this.curve.one;
            this.z = this.curve.zero;
        } else {
            this.x = new bn(x, 16);
            this.z = new bn(z, 16);
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {};
    Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
            if (bits[i] === 0) {
                a = a.diffAdd(b, c);
                b = b.dbl();
            } else {
                b = a.diffAdd(b, c);
                a = a.dbl();
            }
        }
        return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
    };
    Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = __webpack_require__(57);
    var elliptic = __webpack_require__(16);
    var bn = __webpack_require__(18);
    var inherits = __webpack_require__(3);
    var Base = curve.base;
    var assert = elliptic.utils.assert;
    function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new bn(conf.a, 16).toRed(this.red);
        this.b = new bn(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
        var beta;
        var lambda;
        if (conf.beta) {
            beta = new bn(conf.beta, 16).toRed(this.red);
        } else {
            var betas = this._getEndoRoots(this.p);
            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
            beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
            lambda = new bn(conf.lambda, 16);
        } else {
            var lambdas = this._getEndoRoots(this.n);
            if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                lambda = lambdas[0];
            } else {
                lambda = lambdas[1];
                assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
            }
        }
        var basis;
        if (conf.basis) {
            basis = conf.basis.map(function(vec) {
                return {
                    a: new bn(vec.a, 16),
                    b: new bn(vec.b, 16)
                };
            });
        } else {
            basis = this._getEndoBasis(lambda);
        }
        return {
            beta,
            lambda,
            basis
        };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : bn.mont(num);
        var tinv = new bn(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [ l1, l2 ];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new bn(1);
        var y1 = new bn(0);
        var x2 = new bn(0);
        var y2 = new bn(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
            var q = v.div(u);
            r = v.sub(q.mul(u));
            x = x2.sub(q.mul(x1));
            var y = y2.sub(q.mul(y1));
            if (!a1 && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
            } else if (a1 && ++i === 2) {
                break;
            }
            prevR = r;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
            y2 = y1;
            y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
            a2 = a0;
            b2 = b0;
        }
        if (a1.sign) {
            a1 = a1.neg();
            b1 = b1.neg();
        }
        if (a2.sign) {
            a2 = a2.neg();
            b2 = b2.neg();
        }
        return [ {
            a: a1,
            b: b1
        }, {
            a: a2,
            b: b2
        } ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return {
            k1,
            k2
        };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new bn(x, 16);
        if (!x.red) x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
        return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
        if (point.inf) return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
            var split = this._endoSplit(coeffs[i]);
            var p = points[i];
            var beta = p._getBeta();
            if (split.k1.sign) {
                split.k1.sign = !split.k1.sign;
                p = p.neg(true);
            }
            if (split.k2.sign) {
                split.k2.sign = !split.k2.sign;
                beta = beta.neg(true);
            }
            npoints[i * 2] = p;
            npoints[i * 2 + 1] = beta;
            ncoeffs[i * 2] = split.k1;
            ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);
        for (var j = 0; j < i * 2; j++) {
            npoints[j] = null;
            ncoeffs[j] = null;
        }
        return res;
    };
    function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
            this.x = null;
            this.y = null;
            this.inf = true;
        } else {
            this.x = new bn(x, 16);
            this.y = new bn(y, 16);
            if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
            }
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            this.inf = false;
        }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo) return;
        var pre = this.precomputed;
        if (pre && pre.beta) return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
            var curve = this.curve;
            var endoMul = function(p) {
                return curve.point(p.x.redMul(curve.endo.beta), p.y);
            };
            pre.beta = beta;
            beta.precomputed = {
                beta: null,
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(endoMul)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(endoMul)
                }
            };
        }
        return beta;
    };
    Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed) return [ this.x, this.y ];
        return [ this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        } ];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string") obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2]) return res;
        function obj2point(obj) {
            return curve.point(obj[0], obj[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
            beta: null,
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: [ res ].concat(pre.doubles.points.map(obj2point))
            },
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: [ res ].concat(pre.naf.points.map(obj2point))
            }
        };
        return res;
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
    };
    Point.prototype.add = function add(p) {
        if (this.inf) return p;
        if (p.inf) return this;
        if (this.eq(p)) return this.dbl();
        if (this.neg().eq(p)) return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
        if (this.inf) return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
        return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
        return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
        k = new bn(k, 16);
        if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k); else if (this.curve.endo) return this.curve._endoWnafMulAdd([ this ], [ k ]); else return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [ this, p2 ];
        var coeffs = [ k1, k2 ];
        if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs); else return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
        if (this.inf) return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
            var pre = this.precomputed;
            var negate = function(p) {
                return p.neg();
            };
            res.precomputed = {
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(negate)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(negate)
                }
            };
        }
        return res;
    };
    Point.prototype.toJ = function toJ() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
    };
    function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
            this.x = this.curve.one;
            this.y = this.curve.one;
            this.z = new bn(0);
        } else {
            this.x = new bn(x, 16);
            this.y = new bn(y, 16);
            this.z = new bn(z, 16);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
        if (this.isInfinity()) return p;
        if (p.isInfinity()) return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null); else return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity()) return p.toJ();
        if (p.isInfinity()) return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null); else return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0) return this;
        if (this.isInfinity()) return this;
        if (!pow) return this.dbl();
        if (this.curve.zeroA || this.curve.threeA) {
            var r = this;
            for (var i = 0; i < pow; i++) r = r.dbl();
            return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (var i = 0; i < pow; i++) {
            var jx2 = jx.redSqr();
            var jyd2 = jyd.redSqr();
            var jyd4 = jyd2.redSqr();
            var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
            var t1 = jx.redMul(jyd2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);
            var dny = c.redMul(t2);
            dny = dny.redIAdd(dny).redISub(jyd4);
            var nz = jyd.redMul(jz);
            if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
            jx = nx;
            jz = nz;
            jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity()) return this;
        if (this.curve.zeroA) return this._zeroDbl(); else if (this.curve.threeA) return this._threeDbl(); else return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var yyyy = yy.redSqr();
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            var m = xx.redAdd(xx).redIAdd(xx);
            var t = m.redSqr().redISub(s).redISub(s);
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            nx = t;
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            nz = this.y.redAdd(this.y);
        } else {
            var a = this.x.redSqr();
            var b = this.y.redSqr();
            var c = b.redSqr();
            var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
            d = d.redIAdd(d);
            var e = a.redAdd(a).redIAdd(a);
            var f = e.redSqr();
            var c8 = c.redIAdd(c);
            c8 = c8.redIAdd(c8);
            c8 = c8.redIAdd(c8);
            nx = f.redISub(d).redISub(d);
            ny = e.redMul(d.redISub(nx)).redISub(c8);
            nz = this.y.redMul(this.z);
            nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var yyyy = yy.redSqr();
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
            var t = m.redSqr().redISub(s).redISub(s);
            nx = t;
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            nz = this.y.redAdd(this.y);
        } else {
            var delta = this.z.redSqr();
            var gamma = this.y.redSqr();
            var beta = this.x.redMul(gamma);
            var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
            alpha = alpha.redAdd(alpha).redIAdd(alpha);
            var beta4 = beta.redIAdd(beta);
            beta4 = beta4.redIAdd(beta4);
            var beta8 = beta4.redAdd(beta4);
            nx = alpha.redSqr().redISub(beta8);
            nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
            var ggamma8 = gamma.redSqr();
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
        k = new bn(k, kbase);
        return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine") return this.eq(p.toJ());
        if (this === p) return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bn = __webpack_require__(18);
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
        this.type = type;
        this.p = new bn(conf.p, 16);
        this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);
        this.zero = new bn(0).toRed(this.red);
        this.one = new bn(1).toRed(this.red);
        this.two = new bn(2).toRed(this.red);
        this.n = conf.n && new bn(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        for (var j = 0; j < naf.length; j += doubles.step) {
            var nafW = 0;
            for (var k = j + doubles.step - 1; k >= j; k--) nafW = (nafW << 1) + naf[k];
            repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
            for (var j = 0; j < repr.length; j++) {
                var nafW = repr[j];
                if (nafW === i) b = b.mixedAdd(doubles.points[j]); else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
            }
            a = a.add(b);
        }
        return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
            for (var k = 0; i >= 0 && naf[i] === 0; i--) k++;
            if (i >= 0) k++;
            acc = acc.dblp(k);
            if (i < 0) break;
            var z = naf[i];
            assert(z !== 0);
            if (p.type === "affine") {
                if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]); else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
            } else {
                if (z > 0) acc = acc.add(wnd[z - 1 >> 1]); else acc = acc.add(wnd[-z - 1 >> 1].neg());
            }
        }
        return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        for (var i = 0; i < len; i++) {
            var p = points[i];
            var nafPoints = p._getNAFPoints(defW);
            wndWidth[i] = nafPoints.wnd;
            wnd[i] = nafPoints.points;
        }
        for (var i = len - 1; i >= 1; i -= 2) {
            var a = i - 1;
            var b = i;
            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = getNAF(coeffs[a], wndWidth[a]);
                naf[b] = getNAF(coeffs[b], wndWidth[b]);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
            }
            var comb = [ points[a], null, null, points[b] ];
            if (points[a].y.cmp(points[b].y) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
            } else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            }
            var index = [ -3, -1, -5, -7, 0, 7, 5, 1, 3 ];
            var jsf = getJSF(coeffs[a], coeffs[b]);
            max = Math.max(jsf[0].length, max);
            naf[a] = new Array(max);
            naf[b] = new Array(max);
            for (var j = 0; j < max; j++) {
                var ja = jsf[0][j] | 0;
                var jb = jsf[1][j] | 0;
                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
            }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (var i = max; i >= 0; i--) {
            var k = 0;
            while (i >= 0) {
                var zero = true;
                for (var j = 0; j < len; j++) {
                    tmp[j] = naf[j][i] | 0;
                    if (tmp[j] !== 0) zero = false;
                }
                if (!zero) break;
                k++;
                i--;
            }
            if (i >= 0) k++;
            acc = acc.dblp(k);
            if (i < 0) break;
            for (var j = 0; j < len; j++) {
                var z = tmp[j];
                var p;
                if (z === 0) continue; else if (z > 0) p = wnd[j][z - 1 >> 1]; else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
                if (p.type === "affine") acc = acc.mixedAdd(p); else acc = acc.add(p);
            }
        }
        for (var i = 0; i < len; i++) wnd[i] = null;
        return acc.toP();
    };
    function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if (bytes[0] === 4 && bytes.length - 1 === 2 * len) {
            return this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
            return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact) return [ this.getY().isEven() ? 2 : 3 ].concat(x);
        return [ 4 ].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed) return this;
        var precomputed = {
            doubles: null,
            naf: null,
            beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed) return false;
        var doubles = this.precomputed.doubles;
        if (!doubles) return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        var doubles = [ this ];
        var acc = this;
        for (var i = 0; i < power; i += step) {
            for (var j = 0; j < step; j++) acc = acc.dbl();
            doubles.push(acc);
        }
        return {
            step,
            points: doubles
        };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        var res = [ this ];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
        return {
            wnd,
            points: res
        };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
        return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++) r = r.dbl();
        return r;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var hash = __webpack_require__(36);
    var elliptic = __webpack_require__(16);
    var utils = elliptic.utils;
    var assert = utils.assert;
    function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this.reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc);
        var nonce = utils.toArray(options.nonce, options.nonceEnc);
        var pers = utils.toArray(options.pers, options.persEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
            this.K[i] = 0;
            this.V[i] = 1;
        }
        this._update(seed);
        this.reseed = 1;
        this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([ 0 ]);
        if (seed) kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed) return;
        this.K = this._hmac().update(this.V).update([ 1 ]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
            addEnc = add;
            add = entropyEnc;
            entropyEnc = null;
        }
        entropy = utils.toBuffer(entropy, entropyEnc);
        add = utils.toBuffer(add, addEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this.reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this.reseed > this.reseedInterval) throw new Error("Reseed is required");
        if (typeof enc !== "string") {
            addEnc = add;
            add = enc;
            enc = null;
        }
        if (add) {
            add = utils.toArray(add, addEnc);
            this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
            this.V = this._hmac().update(this.V).digest();
            temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this.reseed++;
        return utils.encode(res, enc);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = exports;
    var bn = __webpack_require__(18);
    utils.assert = function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    };
    function toArray(msg, enc) {
        if (Array.isArray(msg)) return msg.slice();
        if (!msg) return [];
        var res = [];
        if (typeof msg !== "string") {
            for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
            return res;
        }
        if (!enc) {
            for (var i = 0; i < msg.length; i++) {
                var c = msg.charCodeAt(i);
                var hi = c >> 8;
                var lo = c & 255;
                if (hi) res.push(hi, lo); else res.push(lo);
            }
        } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/gi, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
        return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
        if (word.length === 1) return "0" + word; else return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
        return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
        if (enc === "hex") return toHex(arr); else return arr;
    };
    function getNAF(num, w) {
        var naf = [];
        var ws = 1 << w + 1;
        var k = num.clone();
        while (k.cmpn(1) >= 0) {
            var z;
            if (k.isOdd()) {
                var mod = k.andln(ws - 1);
                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod; else z = mod;
                k.isubn(z);
            } else {
                z = 0;
            }
            naf.push(z);
            var shift = k.cmpn(0) !== 0 && k.andln(ws - 1) === 0 ? w + 1 : 1;
            for (var i = 1; i < shift; i++) naf.push(0);
            k.iushrn(shift);
        }
        return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
        var jsf = [ [], [] ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
            var m14 = k1.andln(3) + d1 & 3;
            var m24 = k2.andln(3) + d2 & 3;
            if (m14 === 3) m14 = -1;
            if (m24 === 3) m24 = -1;
            var u1;
            if ((m14 & 1) === 0) {
                u1 = 0;
            } else {
                var m8 = k1.andln(7) + d1 & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14; else u1 = m14;
            }
            jsf[0].push(u1);
            var u2;
            if ((m24 & 1) === 0) {
                u2 = 0;
            } else {
                var m8 = k2.andln(7) + d2 & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24; else u2 = m24;
            }
            jsf[1].push(u2);
            if (2 * d1 === u1 + 1) d1 = 1 - d1;
            if (2 * d2 === u2 + 1) d2 = 1 - d2;
            k1.iushrn(1);
            k2.iushrn(1);
        }
        return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, computer) {
        var name = computer.name;
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty() {
            return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
        };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
        return new bn(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
}, function(module) {
    module.exports = {
        _from: "elliptic@^5.1.0",
        _id: "elliptic@5.2.1",
        _inBundle: false,
        _integrity: "sha1-+ilLZWPG3bybo9yFlGh66ECFjxA=",
        _location: "/key-encoder/elliptic",
        _phantomChildren: {},
        _requested: {
            type: "range",
            registry: true,
            raw: "elliptic@^5.1.0",
            name: "elliptic",
            escapedName: "elliptic",
            rawSpec: "^5.1.0",
            saveSpec: null,
            fetchSpec: "^5.1.0"
        },
        _requiredBy: [ "/key-encoder" ],
        _resolved: "http://registry.npmjs.org/elliptic/-/elliptic-5.2.1.tgz",
        _shasum: "fa294b6563c6ddbc9ba3dc8594687ae840858f10",
        _spec: "elliptic@^5.1.0",
        _where: "/Users/samuelhkim/Dropbox/school/spring2018/cs359b/India-HouseChain/node_modules/key-encoder",
        author: {
            name: "Fedor Indutny",
            email: "fedor@indutny.com"
        },
        bugs: {
            url: "https://github.com/indutny/elliptic/issues"
        },
        bundleDependencies: false,
        dependencies: {
            "bn.js": "^3.1.1",
            brorand: "^1.0.1",
            "hash.js": "^1.0.0",
            inherits: "^2.0.1"
        },
        deprecated: false,
        description: "EC cryptography",
        devDependencies: {
            browserify: "^3.44.2",
            coveralls: "^2.11.3",
            istanbul: "^0.3.17",
            jscs: "^1.11.3",
            jshint: "^2.6.0",
            mocha: "^2.1.0",
            "uglify-js": "^2.4.13"
        },
        homepage: "https://github.com/indutny/elliptic",
        keywords: [ "EC", "Elliptic", "curve", "Cryptography" ],
        license: "MIT",
        main: "lib/elliptic.js",
        name: "elliptic",
        repository: {
            type: "git",
            url: "git+ssh://git@github.com/indutny/elliptic.git"
        },
        scripts: {
            coveralls: "cat ./coverage/lcov.info | coveralls",
            test: "make lint && istanbul test _mocha --reporter=spec test/*-test.js"
        },
        version: "5.2.1"
    };
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Buffer = __webpack_require__(4).Buffer;
    var asn1 = __webpack_require__(32);
    var DEREncoder = __webpack_require__(121);
    function PEMEncoder(entity) {
        DEREncoder.call(this, entity);
        this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
        var buf = DEREncoder.prototype.encode.call(this, data);
        var p = buf.toString("base64");
        var out = [ "-----BEGIN " + options.label + "-----" ];
        for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));
        out.push("-----END " + options.label + "-----");
        return out.join("\n");
    };
}, function(module, exports, __webpack_require__) {
    var encoders = exports;
    encoders.der = __webpack_require__(121);
    encoders.pem = __webpack_require__(342);
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Buffer = __webpack_require__(4).Buffer;
    var asn1 = __webpack_require__(32);
    var DERDecoder = __webpack_require__(122);
    function PEMDecoder(entity) {
        DERDecoder.call(this, entity);
        this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
        var lines = data.toString().split(/[\r\n]+/g);
        var label = options.label.toUpperCase();
        var re = /^-----(BEGIN|END) ([^-]+)-----$/;
        var start = -1;
        var end = -1;
        for (var i = 0; i < lines.length; i++) {
            var match = lines[i].match(re);
            if (match === null) continue;
            if (match[2] !== label) continue;
            if (start === -1) {
                if (match[1] !== "BEGIN") break;
                start = i;
            } else {
                if (match[1] !== "END") break;
                end = i;
                break;
            }
        }
        if (start === -1 || end === -1) throw new Error("PEM section not found for: " + label);
        var base64 = lines.slice(start + 1, end).join("");
        base64.replace(/[^a-z0-9\+\/=]+/gi, "");
        var input = new Buffer(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
    };
}, function(module, exports, __webpack_require__) {
    var decoders = exports;
    decoders.der = __webpack_require__(122);
    decoders.pem = __webpack_require__(344);
}, function(module, exports, __webpack_require__) {
    var constants = __webpack_require__(123);
    exports.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
    };
    exports.tagClassByName = constants._reverse(exports.tagClass);
    exports.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
    };
    exports.tagByName = constants._reverse(exports.tag);
}, function(module, exports, __webpack_require__) {
    var Reporter = __webpack_require__(58).Reporter;
    var EncoderBuffer = __webpack_require__(58).EncoderBuffer;
    var assert = __webpack_require__(15);
    var tags = [ "seq", "seqof", "set", "setof", "octstr", "bitstr", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "ia5str", "utf8str" ];
    var methods = [ "key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any" ].concat(tags);
    var overrided = [ "_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool" ];
    function Node(enc, parent) {
        var state = {};
        this._baseState = state;
        state.enc = enc;
        state.parent = parent || null;
        state.children = null;
        state.tag = null;
        state.args = null;
        state.reverseArgs = null;
        state.choice = null;
        state.optional = false;
        state.any = false;
        state.obj = false;
        state.use = null;
        state.useDecoder = null;
        state.key = null;
        state["default"] = null;
        state.explicit = null;
        state.implicit = null;
        if (!state.parent) {
            state.children = [];
            this._wrap();
        }
    }
    module.exports = Node;
    var stateProps = [ "enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit" ];
    Node.prototype.clone = function clone() {
        var state = this._baseState;
        var cstate = {};
        stateProps.forEach(function(prop) {
            cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
    };
    Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
            this[method] = function _wrappedMethod() {
                var clone = new this.constructor(this);
                state.children.push(clone);
                return clone[method].apply(clone, arguments);
            };
        }, this);
    };
    Node.prototype._init = function init(body) {
        var state = this._baseState;
        assert(state.parent === null);
        body.call(this);
        state.children = state.children.filter(function(child) {
            return child._baseState.parent === this;
        }, this);
        assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
        var state = this._baseState;
        var children = args.filter(function(arg) {
            return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
            return !(arg instanceof this.constructor);
        }, this);
        if (children.length !== 0) {
            assert(state.children === null);
            state.children = children;
            children.forEach(function(child) {
                child._baseState.parent = this;
            }, this);
        }
        if (args.length !== 0) {
            assert(state.args === null);
            state.args = args;
            state.reverseArgs = args.map(function(arg) {
                if (typeof arg !== "object" || arg.constructor !== Object) return arg;
                var res = {};
                Object.keys(arg).forEach(function(key) {
                    if (key == (key | 0)) key |= 0;
                    var value = arg[key];
                    res[value] = key;
                });
                return res;
            });
        }
    };
    overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
            var state = this._baseState;
            throw new Error(method + " not implemented for encoding: " + state.enc);
        };
    });
    tags.forEach(function(tag) {
        Node.prototype[tag] = function _tagMethod() {
            var state = this._baseState;
            var args = Array.prototype.slice.call(arguments);
            assert(state.tag === null);
            state.tag = tag;
            this._useArgs(args);
            return this;
        };
    });
    Node.prototype.use = function use(item) {
        var state = this._baseState;
        assert(state.use === null);
        state.use = item;
        return this;
    };
    Node.prototype.optional = function optional() {
        var state = this._baseState;
        state.optional = true;
        return this;
    };
    Node.prototype.def = function def(val) {
        var state = this._baseState;
        assert(state["default"] === null);
        state["default"] = val;
        state.optional = true;
        return this;
    };
    Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.explicit = num;
        return this;
    };
    Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.implicit = num;
        return this;
    };
    Node.prototype.obj = function obj() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        state.obj = true;
        if (args.length !== 0) this._useArgs(args);
        return this;
    };
    Node.prototype.key = function key(newKey) {
        var state = this._baseState;
        assert(state.key === null);
        state.key = newKey;
        return this;
    };
    Node.prototype.any = function any() {
        var state = this._baseState;
        state.any = true;
        return this;
    };
    Node.prototype.choice = function choice(obj) {
        var state = this._baseState;
        assert(state.choice === null);
        state.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key) {
            return obj[key];
        }));
        return this;
    };
    Node.prototype._decode = function decode(input) {
        var state = this._baseState;
        if (state.parent === null) return input.wrapResult(state.children[0]._decode(input));
        var result = state["default"];
        var present = true;
        var prevKey;
        if (state.key !== null) prevKey = input.enterKey(state.key);
        if (state.optional) {
            var tag = null;
            if (state.explicit !== null) tag = state.explicit; else if (state.implicit !== null) tag = state.implicit; else if (state.tag !== null) tag = state.tag;
            if (tag === null && !state.any) {
                var save = input.save();
                try {
                    if (state.choice === null) this._decodeGeneric(state.tag, input); else this._decodeChoice(input);
                    present = true;
                } catch (e) {
                    present = false;
                }
                input.restore(save);
            } else {
                present = this._peekTag(input, tag, state.any);
                if (input.isError(present)) return present;
            }
        }
        var prevObj;
        if (state.obj && present) prevObj = input.enterObject();
        if (present) {
            if (state.explicit !== null) {
                var explicit = this._decodeTag(input, state.explicit);
                if (input.isError(explicit)) return explicit;
                input = explicit;
            }
            if (state.use === null && state.choice === null) {
                if (state.any) var save = input.save();
                var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
                if (input.isError(body)) return body;
                if (state.any) result = input.raw(save); else input = body;
            }
            if (state.any) result = result; else if (state.choice === null) result = this._decodeGeneric(state.tag, input); else result = this._decodeChoice(input);
            if (input.isError(result)) return result;
            if (!state.any && state.choice === null && state.children !== null) {
                var fail = state.children.some(function decodeChildren(child) {
                    child._decode(input);
                });
                if (fail) return err;
            }
        }
        if (state.obj && present) result = input.leaveObject(prevObj);
        if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result);
        return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
        var state = this._baseState;
        if (tag === "seq" || tag === "set") return null;
        if (tag === "seqof" || tag === "setof") return this._decodeList(input, tag, state.args[0]); else if (tag === "octstr" || tag === "bitstr") return this._decodeStr(input, tag); else if (tag === "ia5str" || tag === "utf8str") return this._decodeStr(input, tag); else if (tag === "objid" && state.args) return this._decodeObjid(input, state.args[0], state.args[1]); else if (tag === "objid") return this._decodeObjid(input, null, null); else if (tag === "gentime" || tag === "utctime") return this._decodeTime(input, tag); else if (tag === "null_") return this._decodeNull(input); else if (tag === "bool") return this._decodeBool(input); else if (tag === "int" || tag === "enum") return this._decodeInt(input, state.args && state.args[0]); else if (state.use !== null) return this._getUse(state.use, input._reporterState.obj)._decode(input); else return input.error("unknown tag: " + tag);
        return null;
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
        var state = this._baseState;
        state.useDecoder = this._use(entity, obj);
        assert(state.useDecoder._baseState.parent === null);
        state.useDecoder = state.useDecoder._baseState.children[0];
        if (state.implicit !== state.useDecoder._baseState.implicit) {
            state.useDecoder = state.useDecoder.clone();
            state.useDecoder._baseState.implicit = state.implicit;
        }
        return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input) {
        var state = this._baseState;
        var result = null;
        var match = false;
        Object.keys(state.choice).some(function(key) {
            var save = input.save();
            var node = state.choice[key];
            try {
                var value = node._decode(input);
                if (input.isError(value)) return false;
                result = {
                    type: key,
                    value
                };
                match = true;
            } catch (e) {
                input.restore(save);
                return false;
            }
            return true;
        }, this);
        if (!match) return input.error("Choice not matched");
        return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state["default"] !== null && state["default"] === data) return;
        var result = this._encodeValue(data, reporter, parent);
        if (result === undefined) return;
        if (this._skipDefault(result, reporter, parent)) return;
        return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
        var result = null;
        var present = true;
        this.reporter = reporter;
        if (state.optional && data === undefined) {
            if (state["default"] !== null) data = state["default"]; else return;
        }
        var prevKey;
        var content = null;
        var primitive = false;
        if (state.any) {
            result = this._createEncoderBuffer(data);
        } else if (state.choice) {
            result = this._encodeChoice(data, reporter);
        } else if (state.children) {
            content = state.children.map(function(child) {
                if (child._baseState.tag === "null_") return child._encode(null, reporter, data);
                if (child._baseState.key === null) return reporter.error("Child should have a key");
                var prevKey = reporter.enterKey(child._baseState.key);
                if (typeof data !== "object") return reporter.error("Child expected, but input is not object");
                var res = child._encode(data[child._baseState.key], reporter, data);
                reporter.leaveKey(prevKey);
                return res;
            }, this).filter(function(child) {
                return child;
            });
            content = this._createEncoderBuffer(content);
        } else {
            if (state.tag === "seqof" || state.tag === "setof") {
                if (!(state.args && state.args.length === 1)) return reporter.error("Too many args for : " + state.tag);
                if (!Array.isArray(data)) return reporter.error("seqof/setof, but data is not Array");
                var child = this.clone();
                child._baseState.implicit = null;
                content = this._createEncoderBuffer(data.map(function(item) {
                    var state = this._baseState;
                    return this._getUse(state.args[0], data)._encode(item, reporter);
                }, child));
            } else if (state.use !== null) {
                result = this._getUse(state.use, parent)._encode(data, reporter);
            } else {
                content = this._encodePrimitive(state.tag, data);
                primitive = true;
            }
        }
        var result;
        if (!state.any && state.choice === null) {
            var tag = state.implicit !== null ? state.implicit : state.tag;
            var cls = state.implicit === null ? "universal" : "context";
            if (tag === null) {
                if (state.use === null) reporter.error("Tag could be ommited only for .use()");
            } else {
                if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
            }
        }
        if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, "context", result);
        return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState;
        var node = state.choice[data.type];
        if (!node) {
            assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
        }
        return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        var state = this._baseState;
        if (tag === "octstr" || tag === "bitstr" || tag === "ia5str") return this._encodeStr(data, tag); else if (tag === "utf8str") return this._encodeStr(data, tag); else if (tag === "objid" && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]); else if (tag === "objid") return this._encodeObjid(data, null, null); else if (tag === "gentime" || tag === "utctime") return this._encodeTime(data, tag); else if (tag === "null_") return this._encodeNull(); else if (tag === "int" || tag === "enum") return this._encodeInt(data, state.args && state.reverseArgs[0]); else if (tag === "bool") return this._encodeBool(data); else throw new Error("Unsupported tag: " + tag);
    };
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    function Reporter(options) {
        this._reporterState = {
            obj: null,
            path: [],
            options: options || {},
            errors: []
        };
    }
    exports.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
        var state = this._reporterState;
        return {
            obj: state.obj,
            pathLen: state.path.length
        };
    };
    Reporter.prototype.restore = function restore(data) {
        var state = this._reporterState;
        state.obj = data.obj;
        state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
        var state = this._reporterState;
        state.path = state.path.slice(0, index - 1);
        if (state.obj !== null) state.obj[key] = value;
    };
    Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState;
        var prev = state.obj;
        state.obj = {};
        return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState;
        var now = state.obj;
        state.obj = prev;
        return now;
    };
    Reporter.prototype.error = function error(msg) {
        var err;
        var state = this._reporterState;
        var inherited = msg instanceof ReporterError;
        if (inherited) {
            err = msg;
        } else {
            err = new ReporterError(state.path.map(function(elem) {
                return "[" + JSON.stringify(elem) + "]";
            }).join(""), msg.message || msg, msg.stack);
        }
        if (!state.options.partial) throw err;
        if (!inherited) state.errors.push(err);
        return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial) return result;
        return {
            result: this.isError(result) ? null : result,
            errors: state.errors
        };
    };
    function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + " at: " + (this.path || "(shallow)");
        Error.captureStackTrace(this, ReporterError);
        return this;
    };
}, function(module, exports, __webpack_require__) {
    var asn1 = __webpack_require__(32);
    var inherits = __webpack_require__(3);
    var api = exports;
    api.define = function define(name, body) {
        return new Entity(name, body);
    };
    function Entity(name, body) {
        this.name = name;
        this.body = body;
        this.decoders = {};
        this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base) {
        var named;
        try {
            named = __webpack_require__(133).runInThisContext("(function " + this.name + "(entity) {\n" + "  this._initNamed(entity);\n" + "})");
        } catch (e) {
            named = function(entity) {
                this._initNamed(entity);
            };
        }
        inherits(named, base);
        named.prototype._initNamed = function initnamed(entity) {
            base.call(this, entity);
        };
        return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
        if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
        return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
        if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
        return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
        return this._getEncoder(enc).encode(data, reporter);
    };
}, function(module, exports, __webpack_require__) {
    (function(module) {
        (function(module, exports) {
            "use strict";
            function assert(val, msg) {
                if (!val) throw new Error(msg || "Assertion failed");
            }
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
                if (number !== null && typeof number === "object" && Array.isArray(number.words)) {
                    return number;
                }
                this.sign = false;
                this.words = null;
                this.length = 0;
                this.red = null;
                if (base === "le" || base === "be") {
                    endian = base;
                    base = 10;
                }
                if (number !== null) this._init(number || 0, base || 10, endian || "be");
            }
            if (typeof module === "object") module.exports = BN; else exports.BN = BN;
            BN.BN = BN;
            BN.wordSize = 26;
            BN.prototype._init = function init(number, base, endian) {
                if (typeof number === "number") {
                    return this._initNumber(number, base, endian);
                } else if (typeof number === "object") {
                    return this._initArray(number, base, endian);
                }
                if (base === "hex") base = 16;
                assert(base === (base | 0) && base >= 2 && base <= 36);
                number = number.toString().replace(/\s+/g, "");
                var start = 0;
                if (number[0] === "-") start++;
                if (base === 16) this._parseHex(number, start); else this._parseBase(number, base, start);
                if (number[0] === "-") this.sign = true;
                this.strip();
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initNumber = function _initNumber(number, base, endian) {
                if (number < 0) {
                    this.sign = true;
                    number = -number;
                }
                if (number < 67108864) {
                    this.words = [ number & 67108863 ];
                    this.length = 1;
                } else if (number < 4503599627370496) {
                    this.words = [ number & 67108863, number / 67108864 & 67108863 ];
                    this.length = 2;
                } else {
                    assert(number < 9007199254740992);
                    this.words = [ number & 67108863, number / 67108864 & 67108863, 1 ];
                    this.length = 3;
                }
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(number, base, endian) {
                assert(typeof number.length === "number");
                if (number.length <= 0) {
                    this.words = [ 0 ];
                    this.length = 1;
                    return this;
                }
                this.length = Math.ceil(number.length / 3);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) this.words[i] = 0;
                var off = 0;
                if (endian === "be") {
                    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                        var w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                } else if (endian === "le") {
                    for (var i = 0, j = 0; i < number.length; i += 3) {
                        var w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                }
                return this.strip();
            };
            function parseHex(str, start, end) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r <<= 4;
                    if (c >= 49 && c <= 54) r |= c - 49 + 10; else if (c >= 17 && c <= 22) r |= c - 17 + 10; else r |= c & 15;
                }
                return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start) {
                this.length = Math.ceil((number.length - start) / 6);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) this.words[i] = 0;
                var off = 0;
                for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
                    var w = parseHex(number, i, i + 6);
                    this.words[j] |= w << off & 67108863;
                    this.words[j + 1] |= w >>> 26 - off & 4194303;
                    off += 24;
                    if (off >= 26) {
                        off -= 26;
                        j++;
                    }
                }
                if (i + 6 !== start) {
                    var w = parseHex(number, start, i + 6);
                    this.words[j] |= w << off & 67108863;
                    this.words[j + 1] |= w >>> 26 - off & 4194303;
                }
                this.strip();
            };
            function parseBase(str, start, end, mul) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r *= mul;
                    if (c >= 49) r += c - 49 + 10; else if (c >= 17) r += c - 17 + 10; else r += c;
                }
                return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
                this.words = [ 0 ];
                this.length = 1;
                for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) limbLen++;
                limbLen--;
                limbPow = limbPow / base | 0;
                var total = number.length - start;
                var mod = total % limbLen;
                var end = Math.min(total, total - mod) + start;
                var word = 0;
                for (var i = start; i < end; i += limbLen) {
                    word = parseBase(number, i, i + limbLen, base);
                    this.imuln(limbPow);
                    if (this.words[0] + word < 67108864) this.words[0] += word; else this._iaddn(word);
                }
                if (mod !== 0) {
                    var pow = 1;
                    var word = parseBase(number, i, number.length, base);
                    for (var i = 0; i < mod; i++) pow *= base;
                    this.imuln(pow);
                    if (this.words[0] + word < 67108864) this.words[0] += word; else this._iaddn(word);
                }
            };
            BN.prototype.copy = function copy(dest) {
                dest.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) dest.words[i] = this.words[i];
                dest.length = this.length;
                dest.sign = this.sign;
                dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
                var r = new BN(null);
                this.copy(r);
                return r;
            };
            BN.prototype.strip = function strip() {
                while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
                return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
                if (this.length === 1 && this.words[0] === 0) this.sign = false;
                return this;
            };
            BN.prototype.inspect = function inspect() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var zeros = [ "", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000" ];
            var groupSizes = [ 0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ];
            var groupBases = [ 0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176 ];
            BN.prototype.toString = function toString(base, padding) {
                base = base || 10;
                if (base === 16 || base === "hex") {
                    var out = "";
                    var off = 0;
                    var padding = padding | 0 || 1;
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = this.words[i];
                        var word = ((w << off | carry) & 16777215).toString(16);
                        carry = w >>> 24 - off & 16777215;
                        if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out; else out = word + out;
                        off += 2;
                        if (off >= 26) {
                            off -= 26;
                            i--;
                        }
                    }
                    if (carry !== 0) out = carry.toString(16) + out;
                    while (out.length % padding !== 0) out = "0" + out;
                    if (this.sign) out = "-" + out;
                    return out;
                } else if (base === (base | 0) && base >= 2 && base <= 36) {
                    var groupSize = groupSizes[base];
                    var groupBase = groupBases[base];
                    var out = "";
                    var c = this.clone();
                    c.sign = false;
                    while (c.cmpn(0) !== 0) {
                        var r = c.modn(groupBase).toString(base);
                        c = c.idivn(groupBase);
                        if (c.cmpn(0) !== 0) out = zeros[groupSize - r.length] + r + out; else out = r + out;
                    }
                    if (this.cmpn(0) === 0) out = "0" + out;
                    if (this.sign) out = "-" + out;
                    return out;
                } else {
                    assert(false, "Base should be between 2 and 36");
                }
            };
            BN.prototype.toJSON = function toJSON() {
                return this.toString(16);
            };
            BN.prototype.toArray = function toArray(endian) {
                this.strip();
                var res = new Array(this.byteLength());
                res[0] = 0;
                var q = this.clone();
                if (endian !== "le") {
                    for (var i = 0; q.cmpn(0) !== 0; i++) {
                        var b = q.andln(255);
                        q.ishrn(8);
                        res[res.length - i - 1] = b;
                    }
                } else {
                    for (var i = 0; q.cmpn(0) !== 0; i++) {
                        var b = q.andln(255);
                        q.ishrn(8);
                        res[i] = b;
                    }
                }
                return res;
            };
            if (Math.clz32) {
                BN.prototype._countBits = function _countBits(w) {
                    return 32 - Math.clz32(w);
                };
            } else {
                BN.prototype._countBits = function _countBits(w) {
                    var t = w;
                    var r = 0;
                    if (t >= 4096) {
                        r += 13;
                        t >>>= 13;
                    }
                    if (t >= 64) {
                        r += 7;
                        t >>>= 7;
                    }
                    if (t >= 8) {
                        r += 4;
                        t >>>= 4;
                    }
                    if (t >= 2) {
                        r += 2;
                        t >>>= 2;
                    }
                    return r + t;
                };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
                if (w === 0) return 26;
                var t = w;
                var r = 0;
                if ((t & 8191) === 0) {
                    r += 13;
                    t >>>= 13;
                }
                if ((t & 127) === 0) {
                    r += 7;
                    t >>>= 7;
                }
                if ((t & 15) === 0) {
                    r += 4;
                    t >>>= 4;
                }
                if ((t & 3) === 0) {
                    r += 2;
                    t >>>= 2;
                }
                if ((t & 1) === 0) r++;
                return r;
            };
            BN.prototype.bitLength = function bitLength() {
                var hi = 0;
                var w = this.words[this.length - 1];
                var hi = this._countBits(w);
                return (this.length - 1) * 26 + hi;
            };
            BN.prototype.zeroBits = function zeroBits() {
                if (this.cmpn(0) === 0) return 0;
                var r = 0;
                for (var i = 0; i < this.length; i++) {
                    var b = this._zeroBits(this.words[i]);
                    r += b;
                    if (b !== 26) break;
                }
                return r;
            };
            BN.prototype.byteLength = function byteLength() {
                return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.neg = function neg() {
                if (this.cmpn(0) === 0) return this.clone();
                var r = this.clone();
                r.sign = !this.sign;
                return r;
            };
            BN.prototype.ior = function ior(num) {
                this.sign = this.sign || num.sign;
                while (this.length < num.length) this.words[this.length++] = 0;
                for (var i = 0; i < num.length; i++) this.words[i] = this.words[i] | num.words[i];
                return this.strip();
            };
            BN.prototype.or = function or(num) {
                if (this.length > num.length) return this.clone().ior(num); else return num.clone().ior(this);
            };
            BN.prototype.iand = function iand(num) {
                this.sign = this.sign && num.sign;
                var b;
                if (this.length > num.length) b = num; else b = this;
                for (var i = 0; i < b.length; i++) this.words[i] = this.words[i] & num.words[i];
                this.length = b.length;
                return this.strip();
            };
            BN.prototype.and = function and(num) {
                if (this.length > num.length) return this.clone().iand(num); else return num.clone().iand(this);
            };
            BN.prototype.ixor = function ixor(num) {
                this.sign = this.sign || num.sign;
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                for (var i = 0; i < b.length; i++) this.words[i] = a.words[i] ^ b.words[i];
                if (this !== a) for (;i < a.length; i++) this.words[i] = a.words[i];
                this.length = a.length;
                return this.strip();
            };
            BN.prototype.xor = function xor(num) {
                if (this.length > num.length) return this.clone().ixor(num); else return num.clone().ixor(this);
            };
            BN.prototype.setn = function setn(bit, val) {
                assert(typeof bit === "number" && bit >= 0);
                var off = bit / 26 | 0;
                var wbit = bit % 26;
                while (this.length <= off) this.words[this.length++] = 0;
                if (val) this.words[off] = this.words[off] | 1 << wbit; else this.words[off] = this.words[off] & ~(1 << wbit);
                return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
                if (this.sign && !num.sign) {
                    this.sign = false;
                    var r = this.isub(num);
                    this.sign = !this.sign;
                    return this._normSign();
                } else if (!this.sign && num.sign) {
                    num.sign = false;
                    var r = this.isub(num);
                    num.sign = true;
                    return r._normSign();
                }
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    var r = a.words[i] + b.words[i] + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    var r = a.words[i] + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                this.length = a.length;
                if (carry !== 0) {
                    this.words[this.length] = carry;
                    this.length++;
                } else if (a !== this) {
                    for (;i < a.length; i++) this.words[i] = a.words[i];
                }
                return this;
            };
            BN.prototype.add = function add(num) {
                if (num.sign && !this.sign) {
                    num.sign = false;
                    var res = this.sub(num);
                    num.sign = true;
                    return res;
                } else if (!num.sign && this.sign) {
                    this.sign = false;
                    var res = num.sub(this);
                    this.sign = true;
                    return res;
                }
                if (this.length > num.length) return this.clone().iadd(num); else return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
                if (num.sign) {
                    num.sign = false;
                    var r = this.iadd(num);
                    num.sign = true;
                    return r._normSign();
                } else if (this.sign) {
                    this.sign = false;
                    this.iadd(num);
                    this.sign = true;
                    return this._normSign();
                }
                var cmp = this.cmp(num);
                if (cmp === 0) {
                    this.sign = false;
                    this.length = 1;
                    this.words[0] = 0;
                    return this;
                }
                var a;
                var b;
                if (cmp > 0) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    var r = a.words[i] - b.words[i] + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    var r = a.words[i] + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                if (carry === 0 && i < a.length && a !== this) for (;i < a.length; i++) this.words[i] = a.words[i];
                this.length = Math.max(this.length, i);
                if (a !== this) this.sign = true;
                return this.strip();
            };
            BN.prototype.sub = function sub(num) {
                return this.clone().isub(num);
            };
            BN.prototype._smallMulTo = function _smallMulTo(num, out) {
                out.sign = num.sign !== this.sign;
                out.length = this.length + num.length;
                var carry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    var ncarry = carry >>> 26;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = this.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }
                return out.strip();
            };
            BN.prototype._bigMulTo = function _bigMulTo(num, out) {
                out.sign = num.sign !== this.sign;
                out.length = this.length + num.length;
                var carry = 0;
                var hncarry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    var ncarry = hncarry;
                    hncarry = 0;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = this.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                        hncarry += ncarry >>> 26;
                        ncarry &= 67108863;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                    ncarry = hncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }
                return out.strip();
            };
            BN.prototype.mulTo = function mulTo(num, out) {
                var res;
                if (this.length + num.length < 63) res = this._smallMulTo(num, out); else res = this._bigMulTo(num, out);
                return res;
            };
            BN.prototype.mul = function mul(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return this.mulTo(num, out);
            };
            BN.prototype.imul = function imul(num) {
                if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                    return this;
                }
                var tlen = this.length;
                var nlen = num.length;
                this.sign = num.sign !== this.sign;
                this.length = this.length + num.length;
                this.words[this.length - 1] = 0;
                for (var k = this.length - 2; k >= 0; k--) {
                    var carry = 0;
                    var rword = 0;
                    var maxJ = Math.min(k, nlen - 1);
                    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = this.words[i];
                        var b = num.words[j];
                        var r = a * b;
                        var lo = r & 67108863;
                        carry += r / 67108864 | 0;
                        lo += rword;
                        rword = lo & 67108863;
                        carry += lo >>> 26;
                    }
                    this.words[k] = rword;
                    this.words[k + 1] += carry;
                    carry = 0;
                }
                var carry = 0;
                for (var i = 1; i < this.length; i++) {
                    var w = this.words[i] + carry;
                    this.words[i] = w & 67108863;
                    carry = w >>> 26;
                }
                return this.strip();
            };
            BN.prototype.imuln = function imuln(num) {
                assert(typeof num === "number");
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = this.words[i] * num;
                    var lo = (w & 67108863) + (carry & 67108863);
                    carry >>= 26;
                    carry += w / 67108864 | 0;
                    carry += lo >>> 26;
                    this.words[i] = lo & 67108863;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.muln = function muln(num) {
                return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
                return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
                return this.mul(this);
            };
            BN.prototype.ishln = function ishln(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                var carryMask = 67108863 >>> 26 - r << 26 - r;
                if (r !== 0) {
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var newCarry = this.words[i] & carryMask;
                        var c = this.words[i] - newCarry << r;
                        this.words[i] = c | carry;
                        carry = newCarry >>> 26 - r;
                    }
                    if (carry) {
                        this.words[i] = carry;
                        this.length++;
                    }
                }
                if (s !== 0) {
                    for (var i = this.length - 1; i >= 0; i--) this.words[i + s] = this.words[i];
                    for (var i = 0; i < s; i++) this.words[i] = 0;
                    this.length += s;
                }
                return this.strip();
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                assert(typeof bits === "number" && bits >= 0);
                var h;
                if (hint) h = (hint - hint % 26) / 26; else h = 0;
                var r = bits % 26;
                var s = Math.min((bits - r) / 26, this.length);
                var mask = 67108863 ^ 67108863 >>> r << r;
                var maskedWords = extended;
                h -= s;
                h = Math.max(0, h);
                if (maskedWords) {
                    for (var i = 0; i < s; i++) maskedWords.words[i] = this.words[i];
                    maskedWords.length = s;
                }
                if (s === 0) {} else if (this.length > s) {
                    this.length -= s;
                    for (var i = 0; i < this.length; i++) this.words[i] = this.words[i + s];
                } else {
                    this.words[0] = 0;
                    this.length = 1;
                }
                var carry = 0;
                for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                    var word = this.words[i];
                    this.words[i] = carry << 26 - r | word >>> r;
                    carry = word & mask;
                }
                if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
                if (this.length === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                }
                this.strip();
                return this;
            };
            BN.prototype.shln = function shln(bits) {
                return this.clone().ishln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
                return this.clone().ishrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
                assert(typeof bit === "number" && bit >= 0);
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) {
                    return false;
                }
                var w = this.words[s];
                return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                assert(!this.sign, "imaskn works only with positive numbers");
                if (r !== 0) s++;
                this.length = Math.min(s, this.length);
                if (r !== 0) {
                    var mask = 67108863 ^ 67108863 >>> r << r;
                    this.words[this.length - 1] &= mask;
                }
                return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
                return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
                assert(typeof num === "number");
                if (num < 0) return this.isubn(-num);
                if (this.sign) {
                    if (this.length === 1 && this.words[0] < num) {
                        this.words[0] = num - this.words[0];
                        this.sign = false;
                        return this;
                    }
                    this.sign = false;
                    this.isubn(num);
                    this.sign = true;
                    return this;
                }
                return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
                this.words[0] += num;
                for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
                    this.words[i] -= 67108864;
                    if (i === this.length - 1) this.words[i + 1] = 1; else this.words[i + 1]++;
                }
                this.length = Math.max(this.length, i + 1);
                return this;
            };
            BN.prototype.isubn = function isubn(num) {
                assert(typeof num === "number");
                if (num < 0) return this.iaddn(-num);
                if (this.sign) {
                    this.sign = false;
                    this.iaddn(num);
                    this.sign = true;
                    return this;
                }
                this.words[0] -= num;
                for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                    this.words[i] += 67108864;
                    this.words[i + 1] -= 1;
                }
                return this.strip();
            };
            BN.prototype.addn = function addn(num) {
                return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
                return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
                this.sign = false;
                return this;
            };
            BN.prototype.abs = function abs() {
                return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                var len = num.length + shift;
                var i;
                if (this.words.length < len) {
                    var t = new Array(len);
                    for (var i = 0; i < this.length; i++) t[i] = this.words[i];
                    this.words = t;
                } else {
                    i = this.length;
                }
                this.length = Math.max(this.length, len);
                for (;i < this.length; i++) this.words[i] = 0;
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = this.words[i + shift] + carry;
                    var right = num.words[i] * mul;
                    w -= right & 67108863;
                    carry = (w >> 26) - (right / 67108864 | 0);
                    this.words[i + shift] = w & 67108863;
                }
                for (;i < this.length - shift; i++) {
                    var w = this.words[i + shift] + carry;
                    carry = w >> 26;
                    this.words[i + shift] = w & 67108863;
                }
                if (carry === 0) return this.strip();
                assert(carry === -1);
                carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = -this.words[i] + carry;
                    carry = w >> 26;
                    this.words[i] = w & 67108863;
                }
                this.sign = true;
                return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
                var shift = this.length - num.length;
                var a = this.clone();
                var b = num;
                var bhi = b.words[b.length - 1];
                var bhiBits = this._countBits(bhi);
                shift = 26 - bhiBits;
                if (shift !== 0) {
                    b = b.shln(shift);
                    a.ishln(shift);
                    bhi = b.words[b.length - 1];
                }
                var m = a.length - b.length;
                var q;
                if (mode !== "mod") {
                    q = new BN(null);
                    q.length = m + 1;
                    q.words = new Array(q.length);
                    for (var i = 0; i < q.length; i++) q.words[i] = 0;
                }
                var diff = a.clone()._ishlnsubmul(b, 1, m);
                if (!diff.sign) {
                    a = diff;
                    if (q) q.words[m] = 1;
                }
                for (var j = m - 1; j >= 0; j--) {
                    var qj = a.words[b.length + j] * 67108864 + a.words[b.length + j - 1];
                    qj = Math.min(qj / bhi | 0, 67108863);
                    a._ishlnsubmul(b, qj, j);
                    while (a.sign) {
                        qj--;
                        a.sign = false;
                        a._ishlnsubmul(b, 1, j);
                        if (a.cmpn(0) !== 0) a.sign = !a.sign;
                    }
                    if (q) q.words[j] = qj;
                }
                if (q) q.strip();
                a.strip();
                if (mode !== "div" && shift !== 0) a.ishrn(shift);
                return {
                    div: q ? q : null,
                    mod: a
                };
            };
            BN.prototype.divmod = function divmod(num, mode) {
                assert(num.cmpn(0) !== 0);
                if (this.sign && !num.sign) {
                    var res = this.neg().divmod(num, mode);
                    var div;
                    var mod;
                    if (mode !== "mod") div = res.div.neg();
                    if (mode !== "div") mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
                    return {
                        div,
                        mod
                    };
                } else if (!this.sign && num.sign) {
                    var res = this.divmod(num.neg(), mode);
                    var div;
                    if (mode !== "mod") div = res.div.neg();
                    return {
                        div,
                        mod: res.mod
                    };
                } else if (this.sign && num.sign) {
                    return this.neg().divmod(num.neg(), mode);
                }
                if (num.length > this.length || this.cmp(num) < 0) return {
                    div: new BN(0),
                    mod: this
                };
                if (num.length === 1) {
                    if (mode === "div") return {
                        div: this.divn(num.words[0]),
                        mod: null
                    }; else if (mode === "mod") return {
                        div: null,
                        mod: new BN(this.modn(num.words[0]))
                    };
                    return {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    };
                }
                return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
                return this.divmod(num, "div").div;
            };
            BN.prototype.mod = function mod(num) {
                return this.divmod(num, "mod").mod;
            };
            BN.prototype.divRound = function divRound(num) {
                var dm = this.divmod(num);
                if (dm.mod.cmpn(0) === 0) return dm.div;
                var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
                var half = num.shrn(1);
                var r2 = num.andln(1);
                var cmp = mod.cmp(half);
                if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
                return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
                assert(num <= 67108863);
                var p = (1 << 26) % num;
                var acc = 0;
                for (var i = this.length - 1; i >= 0; i--) acc = (p * acc + this.words[i]) % num;
                return acc;
            };
            BN.prototype.idivn = function idivn(num) {
                assert(num <= 67108863);
                var carry = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var w = this.words[i] + carry * 67108864;
                    this.words[i] = w / num | 0;
                    carry = w % num;
                }
                return this.strip();
            };
            BN.prototype.divn = function divn(num) {
                return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
                assert(!p.sign);
                assert(p.cmpn(0) !== 0);
                var x = this;
                var y = p.clone();
                if (x.sign) x = x.mod(p); else x = x.clone();
                var A = new BN(1);
                var B = new BN(0);
                var C = new BN(0);
                var D = new BN(1);
                var g = 0;
                while (x.isEven() && y.isEven()) {
                    x.ishrn(1);
                    y.ishrn(1);
                    ++g;
                }
                var yp = y.clone();
                var xp = x.clone();
                while (x.cmpn(0) !== 0) {
                    while (x.isEven()) {
                        x.ishrn(1);
                        if (A.isEven() && B.isEven()) {
                            A.ishrn(1);
                            B.ishrn(1);
                        } else {
                            A.iadd(yp).ishrn(1);
                            B.isub(xp).ishrn(1);
                        }
                    }
                    while (y.isEven()) {
                        y.ishrn(1);
                        if (C.isEven() && D.isEven()) {
                            C.ishrn(1);
                            D.ishrn(1);
                        } else {
                            C.iadd(yp).ishrn(1);
                            D.isub(xp).ishrn(1);
                        }
                    }
                    if (x.cmp(y) >= 0) {
                        x.isub(y);
                        A.isub(C);
                        B.isub(D);
                    } else {
                        y.isub(x);
                        C.isub(A);
                        D.isub(B);
                    }
                }
                return {
                    a: C,
                    b: D,
                    gcd: y.ishln(g)
                };
            };
            BN.prototype._invmp = function _invmp(p) {
                assert(!p.sign);
                assert(p.cmpn(0) !== 0);
                var a = this;
                var b = p.clone();
                if (a.sign) a = a.mod(p); else a = a.clone();
                var x1 = new BN(1);
                var x2 = new BN(0);
                var delta = b.clone();
                while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                    while (a.isEven()) {
                        a.ishrn(1);
                        if (x1.isEven()) x1.ishrn(1); else x1.iadd(delta).ishrn(1);
                    }
                    while (b.isEven()) {
                        b.ishrn(1);
                        if (x2.isEven()) x2.ishrn(1); else x2.iadd(delta).ishrn(1);
                    }
                    if (a.cmp(b) >= 0) {
                        a.isub(b);
                        x1.isub(x2);
                    } else {
                        b.isub(a);
                        x2.isub(x1);
                    }
                }
                if (a.cmpn(1) === 0) return x1; else return x2;
            };
            BN.prototype.gcd = function gcd(num) {
                if (this.cmpn(0) === 0) return num.clone();
                if (num.cmpn(0) === 0) return this.clone();
                var a = this.clone();
                var b = num.clone();
                a.sign = false;
                b.sign = false;
                for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                    a.ishrn(1);
                    b.ishrn(1);
                }
                do {
                    while (a.isEven()) a.ishrn(1);
                    while (b.isEven()) b.ishrn(1);
                    var r = a.cmp(b);
                    if (r < 0) {
                        var t = a;
                        a = b;
                        b = t;
                    } else if (r === 0 || b.cmpn(1) === 0) {
                        break;
                    }
                    a.isub(b);
                } while (true);
                return b.ishln(shift);
            };
            BN.prototype.invm = function invm(num) {
                return this.egcd(num).a.mod(num);
            };
            BN.prototype.isEven = function isEven() {
                return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
                return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
                return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
                assert(typeof bit === "number");
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) {
                    for (var i = this.length; i < s + 1; i++) this.words[i] = 0;
                    this.words[s] |= q;
                    this.length = s + 1;
                    return this;
                }
                var carry = q;
                for (var i = s; carry !== 0 && i < this.length; i++) {
                    var w = this.words[i];
                    w += carry;
                    carry = w >>> 26;
                    w &= 67108863;
                    this.words[i] = w;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.cmpn = function cmpn(num) {
                var sign = num < 0;
                if (sign) num = -num;
                if (this.sign && !sign) return -1; else if (!this.sign && sign) return 1;
                num &= 67108863;
                this.strip();
                var res;
                if (this.length > 1) {
                    res = 1;
                } else {
                    var w = this.words[0];
                    res = w === num ? 0 : w < num ? -1 : 1;
                }
                if (this.sign) res = -res;
                return res;
            };
            BN.prototype.cmp = function cmp(num) {
                if (this.sign && !num.sign) return -1; else if (!this.sign && num.sign) return 1;
                var res = this.ucmp(num);
                if (this.sign) return -res; else return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
                if (this.length > num.length) return 1; else if (this.length < num.length) return -1;
                var res = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var a = this.words[i];
                    var b = num.words[i];
                    if (a === b) continue;
                    if (a < b) res = -1; else if (a > b) res = 1;
                    break;
                }
                return res;
            };
            BN.red = function red(num) {
                return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                assert(!this.sign, "red works only with positives");
                return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
                assert(this.red, "fromRed works only with numbers in reduction context");
                return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
                this.red = ctx;
                return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
                assert(this.red, "redAdd works only with red numbers");
                return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
                assert(this.red, "redIAdd works only with red numbers");
                return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
                assert(this.red, "redSub works only with red numbers");
                return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
                assert(this.red, "redISub works only with red numbers");
                return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
                assert(this.red, "redShl works only with red numbers");
                return this.red.shl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
                assert(this.red, "redSqr works only with red numbers");
                this.red._verify1(this);
                return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
                assert(this.red, "redISqr works only with red numbers");
                this.red._verify1(this);
                return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
                assert(this.red, "redSqrt works only with red numbers");
                this.red._verify1(this);
                return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
                assert(this.red, "redInvm works only with red numbers");
                this.red._verify1(this);
                return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
                assert(this.red, "redNeg works only with red numbers");
                this.red._verify1(this);
                return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
                assert(this.red && !num.red, "redPow(normalNum)");
                this.red._verify1(this);
                return this.red.pow(this, num);
            };
            var primes = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function MPrime(name, p) {
                this.name = name;
                this.p = new BN(p, 16);
                this.n = this.p.bitLength();
                this.k = new BN(1).ishln(this.n).isub(this.p);
                this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
                var tmp = new BN(null);
                tmp.words = new Array(Math.ceil(this.n / 13));
                return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
                var r = num;
                var rlen;
                do {
                    this.split(r, this.tmp);
                    r = this.imulK(r);
                    r = r.iadd(this.tmp);
                    rlen = r.bitLength();
                } while (rlen > this.n);
                var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                if (cmp === 0) {
                    r.words[0] = 0;
                    r.length = 1;
                } else if (cmp > 0) {
                    r.isub(this.p);
                } else {
                    r.strip();
                }
                return r;
            };
            MPrime.prototype.split = function split(input, out) {
                input.ishrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
                return num.imul(this.k);
            };
            function K256() {
                MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
                var mask = 4194303;
                var outLen = Math.min(input.length, 9);
                for (var i = 0; i < outLen; i++) output.words[i] = input.words[i];
                output.length = outLen;
                if (input.length <= 9) {
                    input.words[0] = 0;
                    input.length = 1;
                    return;
                }
                var prev = input.words[9];
                output.words[output.length++] = prev & mask;
                for (var i = 10; i < input.length; i++) {
                    var next = input.words[i];
                    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
                    prev = next;
                }
                input.words[i - 10] = prev >>> 22;
                input.length -= 9;
            };
            K256.prototype.imulK = function imulK(num) {
                num.words[num.length] = 0;
                num.words[num.length + 1] = 0;
                num.length += 2;
                var hi;
                var lo = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = num.words[i];
                    hi = w * 64;
                    lo += w * 977;
                    hi += lo / 67108864 | 0;
                    lo &= 67108863;
                    num.words[i] = lo;
                    lo = hi;
                }
                if (num.words[num.length - 1] === 0) {
                    num.length--;
                    if (num.words[num.length - 1] === 0) num.length--;
                }
                return num;
            };
            function P224() {
                MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            inherits(P224, MPrime);
            function P192() {
                MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            inherits(P192, MPrime);
            function P25519() {
                MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var hi = num.words[i] * 19 + carry;
                    var lo = hi & 67108863;
                    hi >>>= 26;
                    num.words[i] = lo;
                    carry = hi;
                }
                if (carry !== 0) num.words[num.length++] = carry;
                return num;
            };
            BN._prime = function prime(name) {
                if (primes[name]) return primes[name];
                var prime;
                if (name === "k256") prime = new K256(); else if (name === "p224") prime = new P224(); else if (name === "p192") prime = new P192(); else if (name === "p25519") prime = new P25519(); else throw new Error("Unknown prime " + name);
                primes[name] = prime;
                return prime;
            };
            function Red(m) {
                if (typeof m === "string") {
                    var prime = BN._prime(m);
                    this.m = prime.p;
                    this.prime = prime;
                } else {
                    this.m = m;
                    this.prime = null;
                }
            }
            Red.prototype._verify1 = function _verify1(a) {
                assert(!a.sign, "red works only with positives");
                assert(a.red, "red works only with red numbers");
            };
            Red.prototype._verify2 = function _verify2(a, b) {
                assert(!a.sign && !b.sign, "red works only with positives");
                assert(a.red && a.red === b.red, "red works only with red numbers");
            };
            Red.prototype.imod = function imod(a) {
                if (this.prime) return this.prime.ireduce(a)._forceRed(this);
                return a.mod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
                var r = a.clone();
                r.sign = !r.sign;
                return r.iadd(this.m)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
                this._verify2(a, b);
                var res = a.add(b);
                if (res.cmp(this.m) >= 0) res.isub(this.m);
                return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
                this._verify2(a, b);
                var res = a.iadd(b);
                if (res.cmp(this.m) >= 0) res.isub(this.m);
                return res;
            };
            Red.prototype.sub = function sub(a, b) {
                this._verify2(a, b);
                var res = a.sub(b);
                if (res.cmpn(0) < 0) res.iadd(this.m);
                return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
                this._verify2(a, b);
                var res = a.isub(b);
                if (res.cmpn(0) < 0) res.iadd(this.m);
                return res;
            };
            Red.prototype.shl = function shl(a, num) {
                this._verify1(a);
                return this.imod(a.shln(num));
            };
            Red.prototype.imul = function imul(a, b) {
                this._verify2(a, b);
                return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
                this._verify2(a, b);
                return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
                return this.imul(a, a);
            };
            Red.prototype.sqr = function sqr(a) {
                return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
                if (a.cmpn(0) === 0) return a.clone();
                var mod3 = this.m.andln(3);
                assert(mod3 % 2 === 1);
                if (mod3 === 3) {
                    var pow = this.m.add(new BN(1)).ishrn(2);
                    var r = this.pow(a, pow);
                    return r;
                }
                var q = this.m.subn(1);
                var s = 0;
                while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
                    s++;
                    q.ishrn(1);
                }
                assert(q.cmpn(0) !== 0);
                var one = new BN(1).toRed(this);
                var nOne = one.redNeg();
                var lpow = this.m.subn(1).ishrn(1);
                var z = this.m.bitLength();
                z = new BN(2 * z * z).toRed(this);
                while (this.pow(z, lpow).cmp(nOne) !== 0) z.redIAdd(nOne);
                var c = this.pow(z, q);
                var r = this.pow(a, q.addn(1).ishrn(1));
                var t = this.pow(a, q);
                var m = s;
                while (t.cmp(one) !== 0) {
                    var tmp = t;
                    for (var i = 0; tmp.cmp(one) !== 0; i++) tmp = tmp.redSqr();
                    assert(i < m);
                    var b = this.pow(c, new BN(1).ishln(m - i - 1));
                    r = r.redMul(b);
                    c = b.redSqr();
                    t = t.redMul(c);
                    m = i;
                }
                return r;
            };
            Red.prototype.invm = function invm(a) {
                var inv = a._invmp(this.m);
                if (inv.sign) {
                    inv.sign = false;
                    return this.imod(inv).redNeg();
                } else {
                    return this.imod(inv);
                }
            };
            Red.prototype.pow = function pow(a, num) {
                var w = [];
                if (num.cmpn(0) === 0) return new BN(1);
                var q = num.clone();
                while (q.cmpn(0) !== 0) {
                    w.push(q.andln(1));
                    q.ishrn(1);
                }
                var res = a;
                for (var i = 0; i < w.length; i++, res = this.sqr(res)) if (w[i] !== 0) break;
                if (++i < w.length) {
                    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
                        if (w[i] === 0) continue;
                        res = this.mul(res, q);
                    }
                }
                return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
                var r = num.mod(this.m);
                if (r === num) return r.clone(); else return r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
                var res = num.clone();
                res.red = null;
                return res;
            };
            BN.mont = function mont(num) {
                return new Mont(num);
            };
            function Mont(m) {
                Red.call(this, m);
                this.shift = this.m.bitLength();
                if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
                this.r = new BN(1).ishln(this.shift);
                this.r2 = this.imod(this.r.sqr());
                this.rinv = this.r._invmp(this.m);
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                this.minv.sign = true;
                this.minv = this.minv.mod(this.r);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
                return this.imod(num.shln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
                var r = this.imod(num.mul(this.rinv));
                r.red = null;
                return r;
            };
            Mont.prototype.imul = function imul(a, b) {
                if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
                    a.words[0] = 0;
                    a.length = 1;
                    return a;
                }
                var t = a.imul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).ishrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) res = u.isub(this.m); else if (u.cmpn(0) < 0) res = u.iadd(this.m);
                return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
                if (a.cmpn(0) === 0 || b.cmpn(0) === 0) return new BN(0)._forceRed(this);
                var t = a.mul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).ishrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) res = u.isub(this.m); else if (u.cmpn(0) < 0) res = u.iadd(this.m);
                return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
                var res = this.imod(a._invmp(this.m).mul(this.r2));
                return res._forceRed(this);
            };
        })(typeof module === "undefined" || module, this);
    }).call(this, __webpack_require__(46)(module));
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var asn1 = __webpack_require__(32), BN = __webpack_require__(18), EC = __webpack_require__(16).ec;
        var ECPrivateKeyASN = asn1.define("ECPrivateKey", function() {
            this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").explicit(0).objid().optional(), this.key("publicKey").explicit(1).bitstr().optional());
        });
        var SubjectPublicKeyInfoASN = asn1.define("SubjectPublicKeyInfo", function() {
            this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("curve").objid()), this.key("pub").bitstr());
        });
        var curves = {
            secp256k1: {
                curveParameters: [ 1, 3, 132, 0, 10 ],
                privatePEMOptions: {
                    label: "EC PRIVATE KEY"
                },
                publicPEMOptions: {
                    label: "PUBLIC KEY"
                },
                curve: new EC("secp256k1")
            }
        };
        function assert(val, msg) {
            if (!val) {
                throw new Error(msg || "Assertion failed");
            }
        }
        function KeyEncoder(options) {
            if (typeof options === "string") {
                assert(curves.hasOwnProperty(options), "Unknown curve " + options);
                options = curves[options];
            }
            this.options = options;
            this.algorithmID = [ 1, 2, 840, 10045, 2, 1 ];
        }
        KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
        KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;
        KeyEncoder.prototype.privateKeyObject = function(rawPrivateKey, rawPublicKey) {
            var privateKeyObject = {
                version: new BN(1),
                privateKey: new Buffer(rawPrivateKey, "hex"),
                parameters: this.options.curveParameters
            };
            if (rawPublicKey) {
                privateKeyObject.publicKey = {
                    unused: 0,
                    data: new Buffer(rawPublicKey, "hex")
                };
            }
            return privateKeyObject;
        };
        KeyEncoder.prototype.publicKeyObject = function(rawPublicKey) {
            return {
                algorithm: {
                    id: this.algorithmID,
                    curve: this.options.curveParameters
                },
                pub: {
                    unused: 0,
                    data: new Buffer(rawPublicKey, "hex")
                }
            };
        };
        KeyEncoder.prototype.encodePrivate = function(privateKey, originalFormat, destinationFormat) {
            var privateKeyObject;
            if (originalFormat === "raw") {
                if (!typeof privateKey === "string") {
                    throw "private key must be a string";
                }
                var privateKeyObject = this.options.curve.keyFromPrivate(privateKey, "hex"), rawPublicKey = privateKeyObject.getPublic("hex");
                privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);
            } else if (originalFormat === "der") {
                if (typeof privateKey === "buffer") {} else if (typeof privateKey === "string") {
                    privateKey = new Buffer(privateKey, "hex");
                } else {
                    throw "private key must be a buffer or a string";
                }
                privateKeyObject = ECPrivateKeyASN.decode(privateKey, "der");
            } else if (originalFormat === "pem") {
                if (!typeof privateKey === "string") {
                    throw "private key must be a string";
                }
                privateKeyObject = ECPrivateKeyASN.decode(privateKey, "pem", this.options.privatePEMOptions);
            } else {
                throw "invalid private key format";
            }
            if (destinationFormat === "raw") {
                return privateKeyObject.privateKey.toString("hex");
            } else if (destinationFormat === "der") {
                return ECPrivateKeyASN.encode(privateKeyObject, "der").toString("hex");
            } else if (destinationFormat === "pem") {
                return ECPrivateKeyASN.encode(privateKeyObject, "pem", this.options.privatePEMOptions);
            } else {
                throw "invalid destination format for private key";
            }
        };
        KeyEncoder.prototype.encodePublic = function(publicKey, originalFormat, destinationFormat) {
            var publicKeyObject;
            if (originalFormat === "raw") {
                if (!typeof publicKey === "string") {
                    throw "public key must be a string";
                }
                publicKeyObject = this.publicKeyObject(publicKey);
            } else if (originalFormat === "der") {
                if (typeof publicKey === "buffer") {} else if (typeof publicKey === "string") {
                    publicKey = new Buffer(publicKey, "hex");
                } else {
                    throw "public key must be a buffer or a string";
                }
                publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, "der");
            } else if (originalFormat === "pem") {
                if (!typeof publicKey === "string") {
                    throw "public key must be a string";
                }
                publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, "pem", this.options.publicPEMOptions);
            } else {
                throw "invalid public key format";
            }
            if (destinationFormat === "raw") {
                return publicKeyObject.pub.data.toString("hex");
            } else if (destinationFormat === "der") {
                return SubjectPublicKeyInfoASN.encode(publicKeyObject, "der").toString("hex");
            } else if (destinationFormat === "pem") {
                return SubjectPublicKeyInfoASN.encode(publicKeyObject, "pem", this.options.publicPEMOptions);
            } else {
                throw "invalid destination format for public key";
            }
        };
        module.exports = KeyEncoder;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = __webpack_require__(351);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(global, process) {
        function oldBrowser() {
            throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
        }
        var safeBuffer = __webpack_require__(7);
        var randombytes = __webpack_require__(35);
        var Buffer = safeBuffer.Buffer;
        var kBufferMaxLength = safeBuffer.kMaxLength;
        var crypto = global.crypto || global.msCrypto;
        var kMaxUint32 = Math.pow(2, 32) - 1;
        function assertOffset(offset, length) {
            if (typeof offset !== "number" || offset !== offset) {
                throw new TypeError("offset must be a number");
            }
            if (offset > kMaxUint32 || offset < 0) {
                throw new TypeError("offset must be a uint32");
            }
            if (offset > kBufferMaxLength || offset > length) {
                throw new RangeError("offset out of range");
            }
        }
        function assertSize(size, offset, length) {
            if (typeof size !== "number" || size !== size) {
                throw new TypeError("size must be a number");
            }
            if (size > kMaxUint32 || size < 0) {
                throw new TypeError("size must be a uint32");
            }
            if (size + offset > length || size > kBufferMaxLength) {
                throw new RangeError("buffer too small");
            }
        }
        if (crypto && crypto.getRandomValues || !process.browser) {
            exports.randomFill = randomFill;
            exports.randomFillSync = randomFillSync;
        } else {
            exports.randomFill = oldBrowser;
            exports.randomFillSync = oldBrowser;
        }
        function randomFill(buf, offset, size, cb) {
            if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
                throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
            }
            if (typeof offset === "function") {
                cb = offset;
                offset = 0;
                size = buf.length;
            } else if (typeof size === "function") {
                cb = size;
                size = buf.length - offset;
            } else if (typeof cb !== "function") {
                throw new TypeError('"cb" argument must be a function');
            }
            assertOffset(offset, buf.length);
            assertSize(size, offset, buf.length);
            return actualFill(buf, offset, size, cb);
        }
        function actualFill(buf, offset, size, cb) {
            if (process.browser) {
                var ourBuf = buf.buffer;
                var uint = new Uint8Array(ourBuf, offset, size);
                crypto.getRandomValues(uint);
                if (cb) {
                    process.nextTick(function() {
                        cb(null, buf);
                    });
                    return;
                }
                return buf;
            }
            if (cb) {
                randombytes(size, function(err, bytes) {
                    if (err) {
                        return cb(err);
                    }
                    bytes.copy(buf, offset);
                    cb(null, buf);
                });
                return;
            }
            var bytes = randombytes(size);
            bytes.copy(buf, offset);
            return buf;
        }
        function randomFillSync(buf, offset, size) {
            if (typeof offset === "undefined") {
                offset = 0;
            }
            if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
                throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
            }
            assertOffset(offset, buf.length);
            if (size === undefined) size = buf.length - offset;
            assertSize(size, offset, buf.length);
            return actualFill(buf, offset, size);
        }
    }).call(this, __webpack_require__(12), __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var parseKeys = __webpack_require__(59);
        var mgf = __webpack_require__(127);
        var xor = __webpack_require__(126);
        var bn = __webpack_require__(9);
        var crt = __webpack_require__(73);
        var createHash = __webpack_require__(44);
        var withPublic = __webpack_require__(125);
        module.exports = function privateDecrypt(private_key, enc, reverse) {
            var padding;
            if (private_key.padding) {
                padding = private_key.padding;
            } else if (reverse) {
                padding = 1;
            } else {
                padding = 4;
            }
            var key = parseKeys(private_key);
            var k = key.modulus.byteLength();
            if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
                throw new Error("decryption error");
            }
            var msg;
            if (reverse) {
                msg = withPublic(new bn(enc), key);
            } else {
                msg = crt(enc, key);
            }
            var zBuffer = new Buffer(k - msg.length);
            zBuffer.fill(0);
            msg = Buffer.concat([ zBuffer, msg ], k);
            if (padding === 4) {
                return oaep(key, msg);
            } else if (padding === 1) {
                return pkcs1(key, msg, reverse);
            } else if (padding === 3) {
                return msg;
            } else {
                throw new Error("unknown padding");
            }
        };
        function oaep(key, msg) {
            var n = key.modulus;
            var k = key.modulus.byteLength();
            var mLen = msg.length;
            var iHash = createHash("sha1").update(new Buffer("")).digest();
            var hLen = iHash.length;
            var hLen2 = 2 * hLen;
            if (msg[0] !== 0) {
                throw new Error("decryption error");
            }
            var maskedSeed = msg.slice(1, hLen + 1);
            var maskedDb = msg.slice(hLen + 1);
            var seed = xor(maskedSeed, mgf(maskedDb, hLen));
            var db = xor(maskedDb, mgf(seed, k - hLen - 1));
            if (compare(iHash, db.slice(0, hLen))) {
                throw new Error("decryption error");
            }
            var i = hLen;
            while (db[i] === 0) {
                i++;
            }
            if (db[i++] !== 1) {
                throw new Error("decryption error");
            }
            return db.slice(i);
        }
        function pkcs1(key, msg, reverse) {
            var p1 = msg.slice(0, 2);
            var i = 2;
            var status = 0;
            while (msg[i++] !== 0) {
                if (i >= msg.length) {
                    status++;
                    break;
                }
            }
            var ps = msg.slice(2, i - 1);
            var p2 = msg.slice(i - 1, i);
            if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
                status++;
            }
            if (ps.length < 8) {
                status++;
            }
            if (status) {
                throw new Error("decryption error");
            }
            return msg.slice(i);
        }
        function compare(a, b) {
            a = new Buffer(a);
            b = new Buffer(b);
            var dif = 0;
            var len = a.length;
            if (a.length !== b.length) {
                dif++;
                len = Math.min(a.length, b.length);
            }
            var i = -1;
            while (++i < len) {
                dif += a[i] ^ b[i];
            }
            return dif;
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var parseKeys = __webpack_require__(59);
        var randomBytes = __webpack_require__(35);
        var createHash = __webpack_require__(44);
        var mgf = __webpack_require__(127);
        var xor = __webpack_require__(126);
        var bn = __webpack_require__(9);
        var withPublic = __webpack_require__(125);
        var crt = __webpack_require__(73);
        var constants = {
            RSA_PKCS1_OAEP_PADDING: 4,
            RSA_PKCS1_PADDIN: 1,
            RSA_NO_PADDING: 3
        };
        module.exports = function publicEncrypt(public_key, msg, reverse) {
            var padding;
            if (public_key.padding) {
                padding = public_key.padding;
            } else if (reverse) {
                padding = 1;
            } else {
                padding = 4;
            }
            var key = parseKeys(public_key);
            var paddedMsg;
            if (padding === 4) {
                paddedMsg = oaep(key, msg);
            } else if (padding === 1) {
                paddedMsg = pkcs1(key, msg, reverse);
            } else if (padding === 3) {
                paddedMsg = new bn(msg);
                if (paddedMsg.cmp(key.modulus) >= 0) {
                    throw new Error("data too long for modulus");
                }
            } else {
                throw new Error("unknown padding");
            }
            if (reverse) {
                return crt(paddedMsg, key);
            } else {
                return withPublic(paddedMsg, key);
            }
        };
        function oaep(key, msg) {
            var k = key.modulus.byteLength();
            var mLen = msg.length;
            var iHash = createHash("sha1").update(new Buffer("")).digest();
            var hLen = iHash.length;
            var hLen2 = 2 * hLen;
            if (mLen > k - hLen2 - 2) {
                throw new Error("message too long");
            }
            var ps = new Buffer(k - mLen - hLen2 - 2);
            ps.fill(0);
            var dblen = k - hLen - 1;
            var seed = randomBytes(hLen);
            var maskedDb = xor(Buffer.concat([ iHash, ps, new Buffer([ 1 ]), msg ], dblen), mgf(seed, dblen));
            var maskedSeed = xor(seed, mgf(maskedDb, hLen));
            return new bn(Buffer.concat([ new Buffer([ 0 ]), maskedSeed, maskedDb ], k));
        }
        function pkcs1(key, msg, reverse) {
            var mLen = msg.length;
            var k = key.modulus.byteLength();
            if (mLen > k - 11) {
                throw new Error("message too long");
            }
            var ps;
            if (reverse) {
                ps = new Buffer(k - mLen - 3);
                ps.fill(255);
            } else {
                ps = nonZero(k - mLen - 3);
            }
            return new bn(Buffer.concat([ new Buffer([ 0, reverse ? 1 : 2 ]), ps, new Buffer([ 0 ]), msg ], k));
        }
        function nonZero(len, crypto) {
            var out = new Buffer(len);
            var i = 0;
            var cache = randomBytes(len * 2);
            var cur = 0;
            var num;
            while (i < len) {
                if (cur === cache.length) {
                    cache = randomBytes(len * 2);
                    cur = 0;
                }
                num = cache[cur++];
                if (num) {
                    out[i++] = num;
                }
            }
            return out;
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    exports.publicEncrypt = __webpack_require__(355);
    exports.privateDecrypt = __webpack_require__(354);
    exports.privateEncrypt = function privateEncrypt(key, buf) {
        return exports.publicEncrypt(key, buf, true);
    };
    exports.publicDecrypt = function publicDecrypt(key, buf) {
        return exports.privateDecrypt(key, buf, true);
    };
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var elliptic = __webpack_require__(14);
        var BN = __webpack_require__(9);
        module.exports = function createECDH(curve) {
            return new ECDH(curve);
        };
        var aliases = {
            secp256k1: {
                name: "secp256k1",
                byteLength: 32
            },
            secp224r1: {
                name: "p224",
                byteLength: 28
            },
            prime256v1: {
                name: "p256",
                byteLength: 32
            },
            prime192v1: {
                name: "p192",
                byteLength: 24
            },
            ed25519: {
                name: "ed25519",
                byteLength: 32
            },
            secp384r1: {
                name: "p384",
                byteLength: 48
            },
            secp521r1: {
                name: "p521",
                byteLength: 66
            }
        };
        aliases.p224 = aliases.secp224r1;
        aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
        aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
        aliases.p384 = aliases.secp384r1;
        aliases.p521 = aliases.secp521r1;
        function ECDH(curve) {
            this.curveType = aliases[curve];
            if (!this.curveType) {
                this.curveType = {
                    name: curve
                };
            }
            this.curve = new elliptic.ec(this.curveType.name);
            this.keys = void 0;
        }
        ECDH.prototype.generateKeys = function(enc, format) {
            this.keys = this.curve.genKeyPair();
            return this.getPublicKey(enc, format);
        };
        ECDH.prototype.computeSecret = function(other, inenc, enc) {
            inenc = inenc || "utf8";
            if (!Buffer.isBuffer(other)) {
                other = new Buffer(other, inenc);
            }
            var otherPub = this.curve.keyFromPublic(other).getPublic();
            var out = otherPub.mul(this.keys.getPrivate()).getX();
            return formatReturnValue(out, enc, this.curveType.byteLength);
        };
        ECDH.prototype.getPublicKey = function(enc, format) {
            var key = this.keys.getPublic(format === "compressed", true);
            if (format === "hybrid") {
                if (key[key.length - 1] % 2) {
                    key[0] = 7;
                } else {
                    key[0] = 6;
                }
            }
            return formatReturnValue(key, enc);
        };
        ECDH.prototype.getPrivateKey = function(enc) {
            return formatReturnValue(this.keys.getPrivate(), enc);
        };
        ECDH.prototype.setPublicKey = function(pub, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(pub)) {
                pub = new Buffer(pub, enc);
            }
            this.keys._importPublic(pub);
            return this;
        };
        ECDH.prototype.setPrivateKey = function(priv, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(priv)) {
                priv = new Buffer(priv, enc);
            }
            var _priv = new BN(priv);
            _priv = _priv.toString(16);
            this.keys._importPrivate(_priv);
            return this;
        };
        function formatReturnValue(bn, enc, len) {
            if (!Array.isArray(bn)) {
                bn = bn.toArray();
            }
            var buf = new Buffer(bn);
            if (len && buf.length < len) {
                var zeros = new Buffer(len - buf.length);
                zeros.fill(0);
                buf = Buffer.concat([ zeros, buf ]);
            }
            if (!enc) {
                return buf;
            } else {
                return buf.toString(enc);
            }
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var BN = __webpack_require__(9);
        var EC = __webpack_require__(14).ec;
        var parseKeys = __webpack_require__(59);
        var curves = __webpack_require__(128);
        function verify(sig, hash, key, signType, tag) {
            var pub = parseKeys(key);
            if (pub.type === "ec") {
                if (signType !== "ecdsa" && signType !== "ecdsa/rsa") throw new Error("wrong public key type");
                return ecVerify(sig, hash, pub);
            } else if (pub.type === "dsa") {
                if (signType !== "dsa") throw new Error("wrong public key type");
                return dsaVerify(sig, hash, pub);
            } else {
                if (signType !== "rsa" && signType !== "ecdsa/rsa") throw new Error("wrong public key type");
            }
            hash = Buffer.concat([ tag, hash ]);
            var len = pub.modulus.byteLength();
            var pad = [ 1 ];
            var padNum = 0;
            while (hash.length + pad.length + 2 < len) {
                pad.push(255);
                padNum++;
            }
            pad.push(0);
            var i = -1;
            while (++i < hash.length) {
                pad.push(hash[i]);
            }
            pad = new Buffer(pad);
            var red = BN.mont(pub.modulus);
            sig = new BN(sig).toRed(red);
            sig = sig.redPow(new BN(pub.publicExponent));
            sig = new Buffer(sig.fromRed().toArray());
            var out = padNum < 8 ? 1 : 0;
            len = Math.min(sig.length, pad.length);
            if (sig.length !== pad.length) out = 1;
            i = -1;
            while (++i < len) out |= sig[i] ^ pad[i];
            return out === 0;
        }
        function ecVerify(sig, hash, pub) {
            var curveId = curves[pub.data.algorithm.curve.join(".")];
            if (!curveId) throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
            var curve = new EC(curveId);
            var pubkey = pub.data.subjectPrivateKey.data;
            return curve.verify(hash, sig, pubkey);
        }
        function dsaVerify(sig, hash, pub) {
            var p = pub.data.p;
            var q = pub.data.q;
            var g = pub.data.g;
            var y = pub.data.pub_key;
            var unpacked = parseKeys.signature.decode(sig, "der");
            var s = unpacked.s;
            var r = unpacked.r;
            checkValue(s, q);
            checkValue(r, q);
            var montp = BN.mont(p);
            var w = s.invm(q);
            var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
            return v.cmp(r) === 0;
        }
        function checkValue(b, q) {
            if (b.cmpn(0) <= 0) throw new Error("invalid sig");
            if (b.cmp(q) >= q) throw new Error("invalid sig");
        }
        module.exports = verify;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m;
        var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m;
        var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m;
        var evp = __webpack_require__(60);
        var ciphers = __webpack_require__(75);
        module.exports = function(okey, password) {
            var key = okey.toString();
            var match = key.match(findProc);
            var decrypted;
            if (!match) {
                var match2 = key.match(fullRegex);
                decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ""), "base64");
            } else {
                var suite = "aes" + match[1];
                var iv = new Buffer(match[2], "hex");
                var cipherText = new Buffer(match[3].replace(/[\r\n]/g, ""), "base64");
                var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
                var out = [];
                var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
                out.push(cipher.update(cipherText));
                out.push(cipher.final());
                decrypted = Buffer.concat(out);
            }
            var tag = key.match(startRegex)[1];
            return {
                tag,
                data: decrypted
            };
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module) {
    module.exports = {
        "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
        "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
        "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
        "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
        "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
        "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
        "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
        "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
        "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
        "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
        "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
        "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asn = __webpack_require__(33);
    var Time = asn.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        });
    });
    var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
    });
    var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional());
    });
    var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
    });
    var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
        this.setof(AttributeTypeValue);
    });
    var RDNSequence = asn.define("RDNSequence", function() {
        this.seqof(RelativeDistinguishedName);
    });
    var Name = asn.define("Name", function() {
        this.choice({
            rdnSequence: this.use(RDNSequence)
        });
    });
    var Validity = asn.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
    });
    var Extension = asn.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    });
    var TBSCertificate = asn.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
    });
    var X509Certificate = asn.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
    });
    module.exports = X509Certificate;
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var DEREncoder = __webpack_require__(129);
    function PEMEncoder(entity) {
        DEREncoder.call(this, entity);
        this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
        var buf = DEREncoder.prototype.encode.call(this, data);
        var p = buf.toString("base64");
        var out = [ "-----BEGIN " + options.label + "-----" ];
        for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));
        out.push("-----END " + options.label + "-----");
        return out.join("\n");
    };
}, function(module, exports, __webpack_require__) {
    var encoders = exports;
    encoders.der = __webpack_require__(129);
    encoders.pem = __webpack_require__(362);
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Buffer = __webpack_require__(4).Buffer;
    var DERDecoder = __webpack_require__(130);
    function PEMDecoder(entity) {
        DERDecoder.call(this, entity);
        this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
        var lines = data.toString().split(/[\r\n]+/g);
        var label = options.label.toUpperCase();
        var re = /^-----(BEGIN|END) ([^-]+)-----$/;
        var start = -1;
        var end = -1;
        for (var i = 0; i < lines.length; i++) {
            var match = lines[i].match(re);
            if (match === null) continue;
            if (match[2] !== label) continue;
            if (start === -1) {
                if (match[1] !== "BEGIN") break;
                start = i;
            } else {
                if (match[1] !== "END") break;
                end = i;
                break;
            }
        }
        if (start === -1 || end === -1) throw new Error("PEM section not found for: " + label);
        var base64 = lines.slice(start + 1, end).join("");
        base64.replace(/[^a-z0-9\+\/=]+/gi, "");
        var input = new Buffer(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
    };
}, function(module, exports, __webpack_require__) {
    var decoders = exports;
    decoders.der = __webpack_require__(130);
    decoders.pem = __webpack_require__(364);
}, function(module, exports, __webpack_require__) {
    var constants = __webpack_require__(131);
    exports.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
    };
    exports.tagClassByName = constants._reverse(exports.tagClass);
    exports.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
    };
    exports.tagByName = constants._reverse(exports.tag);
}, function(module, exports, __webpack_require__) {
    var Reporter = __webpack_require__(40).Reporter;
    var EncoderBuffer = __webpack_require__(40).EncoderBuffer;
    var DecoderBuffer = __webpack_require__(40).DecoderBuffer;
    var assert = __webpack_require__(15);
    var tags = [ "seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr" ];
    var methods = [ "key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains" ].concat(tags);
    var overrided = [ "_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool" ];
    function Node(enc, parent) {
        var state = {};
        this._baseState = state;
        state.enc = enc;
        state.parent = parent || null;
        state.children = null;
        state.tag = null;
        state.args = null;
        state.reverseArgs = null;
        state.choice = null;
        state.optional = false;
        state.any = false;
        state.obj = false;
        state.use = null;
        state.useDecoder = null;
        state.key = null;
        state["default"] = null;
        state.explicit = null;
        state.implicit = null;
        state.contains = null;
        if (!state.parent) {
            state.children = [];
            this._wrap();
        }
    }
    module.exports = Node;
    var stateProps = [ "enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains" ];
    Node.prototype.clone = function clone() {
        var state = this._baseState;
        var cstate = {};
        stateProps.forEach(function(prop) {
            cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
    };
    Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
            this[method] = function _wrappedMethod() {
                var clone = new this.constructor(this);
                state.children.push(clone);
                return clone[method].apply(clone, arguments);
            };
        }, this);
    };
    Node.prototype._init = function init(body) {
        var state = this._baseState;
        assert(state.parent === null);
        body.call(this);
        state.children = state.children.filter(function(child) {
            return child._baseState.parent === this;
        }, this);
        assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
        var state = this._baseState;
        var children = args.filter(function(arg) {
            return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
            return !(arg instanceof this.constructor);
        }, this);
        if (children.length !== 0) {
            assert(state.children === null);
            state.children = children;
            children.forEach(function(child) {
                child._baseState.parent = this;
            }, this);
        }
        if (args.length !== 0) {
            assert(state.args === null);
            state.args = args;
            state.reverseArgs = args.map(function(arg) {
                if (typeof arg !== "object" || arg.constructor !== Object) return arg;
                var res = {};
                Object.keys(arg).forEach(function(key) {
                    if (key == (key | 0)) key |= 0;
                    var value = arg[key];
                    res[value] = key;
                });
                return res;
            });
        }
    };
    overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
            var state = this._baseState;
            throw new Error(method + " not implemented for encoding: " + state.enc);
        };
    });
    tags.forEach(function(tag) {
        Node.prototype[tag] = function _tagMethod() {
            var state = this._baseState;
            var args = Array.prototype.slice.call(arguments);
            assert(state.tag === null);
            state.tag = tag;
            this._useArgs(args);
            return this;
        };
    });
    Node.prototype.use = function use(item) {
        assert(item);
        var state = this._baseState;
        assert(state.use === null);
        state.use = item;
        return this;
    };
    Node.prototype.optional = function optional() {
        var state = this._baseState;
        state.optional = true;
        return this;
    };
    Node.prototype.def = function def(val) {
        var state = this._baseState;
        assert(state["default"] === null);
        state["default"] = val;
        state.optional = true;
        return this;
    };
    Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.explicit = num;
        return this;
    };
    Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.implicit = num;
        return this;
    };
    Node.prototype.obj = function obj() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        state.obj = true;
        if (args.length !== 0) this._useArgs(args);
        return this;
    };
    Node.prototype.key = function key(newKey) {
        var state = this._baseState;
        assert(state.key === null);
        state.key = newKey;
        return this;
    };
    Node.prototype.any = function any() {
        var state = this._baseState;
        state.any = true;
        return this;
    };
    Node.prototype.choice = function choice(obj) {
        var state = this._baseState;
        assert(state.choice === null);
        state.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key) {
            return obj[key];
        }));
        return this;
    };
    Node.prototype.contains = function contains(item) {
        var state = this._baseState;
        assert(state.use === null);
        state.contains = item;
        return this;
    };
    Node.prototype._decode = function decode(input, options) {
        var state = this._baseState;
        if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options));
        var result = state["default"];
        var present = true;
        var prevKey = null;
        if (state.key !== null) prevKey = input.enterKey(state.key);
        if (state.optional) {
            var tag = null;
            if (state.explicit !== null) tag = state.explicit; else if (state.implicit !== null) tag = state.implicit; else if (state.tag !== null) tag = state.tag;
            if (tag === null && !state.any) {
                var save = input.save();
                try {
                    if (state.choice === null) this._decodeGeneric(state.tag, input, options); else this._decodeChoice(input, options);
                    present = true;
                } catch (e) {
                    present = false;
                }
                input.restore(save);
            } else {
                present = this._peekTag(input, tag, state.any);
                if (input.isError(present)) return present;
            }
        }
        var prevObj;
        if (state.obj && present) prevObj = input.enterObject();
        if (present) {
            if (state.explicit !== null) {
                var explicit = this._decodeTag(input, state.explicit);
                if (input.isError(explicit)) return explicit;
                input = explicit;
            }
            var start = input.offset;
            if (state.use === null && state.choice === null) {
                if (state.any) var save = input.save();
                var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
                if (input.isError(body)) return body;
                if (state.any) result = input.raw(save); else input = body;
            }
            if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, "tagged");
            if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, "content");
            if (state.any) result = result; else if (state.choice === null) result = this._decodeGeneric(state.tag, input, options); else result = this._decodeChoice(input, options);
            if (input.isError(result)) return result;
            if (!state.any && state.choice === null && state.children !== null) {
                state.children.forEach(function decodeChildren(child) {
                    child._decode(input, options);
                });
            }
            if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
                var data = new DecoderBuffer(result);
                result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
            }
        }
        if (state.obj && present) result = input.leaveObject(prevObj);
        if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result); else if (prevKey !== null) input.exitKey(prevKey);
        return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
        var state = this._baseState;
        if (tag === "seq" || tag === "set") return null;
        if (tag === "seqof" || tag === "setof") return this._decodeList(input, tag, state.args[0], options); else if (/str$/.test(tag)) return this._decodeStr(input, tag, options); else if (tag === "objid" && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options); else if (tag === "objid") return this._decodeObjid(input, null, null, options); else if (tag === "gentime" || tag === "utctime") return this._decodeTime(input, tag, options); else if (tag === "null_") return this._decodeNull(input, options); else if (tag === "bool") return this._decodeBool(input, options); else if (tag === "objDesc") return this._decodeStr(input, tag, options); else if (tag === "int" || tag === "enum") return this._decodeInt(input, state.args && state.args[0], options);
        if (state.use !== null) {
            return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
        } else {
            return input.error("unknown tag: " + tag);
        }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
        var state = this._baseState;
        state.useDecoder = this._use(entity, obj);
        assert(state.useDecoder._baseState.parent === null);
        state.useDecoder = state.useDecoder._baseState.children[0];
        if (state.implicit !== state.useDecoder._baseState.implicit) {
            state.useDecoder = state.useDecoder.clone();
            state.useDecoder._baseState.implicit = state.implicit;
        }
        return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
        var state = this._baseState;
        var result = null;
        var match = false;
        Object.keys(state.choice).some(function(key) {
            var save = input.save();
            var node = state.choice[key];
            try {
                var value = node._decode(input, options);
                if (input.isError(value)) return false;
                result = {
                    type: key,
                    value
                };
                match = true;
            } catch (e) {
                input.restore(save);
                return false;
            }
            return true;
        }, this);
        if (!match) return input.error("Choice not matched");
        return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state["default"] !== null && state["default"] === data) return;
        var result = this._encodeValue(data, reporter, parent);
        if (result === undefined) return;
        if (this._skipDefault(result, reporter, parent)) return;
        return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
        var result = null;
        this.reporter = reporter;
        if (state.optional && data === undefined) {
            if (state["default"] !== null) data = state["default"]; else return;
        }
        var content = null;
        var primitive = false;
        if (state.any) {
            result = this._createEncoderBuffer(data);
        } else if (state.choice) {
            result = this._encodeChoice(data, reporter);
        } else if (state.contains) {
            content = this._getUse(state.contains, parent)._encode(data, reporter);
            primitive = true;
        } else if (state.children) {
            content = state.children.map(function(child) {
                if (child._baseState.tag === "null_") return child._encode(null, reporter, data);
                if (child._baseState.key === null) return reporter.error("Child should have a key");
                var prevKey = reporter.enterKey(child._baseState.key);
                if (typeof data !== "object") return reporter.error("Child expected, but input is not object");
                var res = child._encode(data[child._baseState.key], reporter, data);
                reporter.leaveKey(prevKey);
                return res;
            }, this).filter(function(child) {
                return child;
            });
            content = this._createEncoderBuffer(content);
        } else {
            if (state.tag === "seqof" || state.tag === "setof") {
                if (!(state.args && state.args.length === 1)) return reporter.error("Too many args for : " + state.tag);
                if (!Array.isArray(data)) return reporter.error("seqof/setof, but data is not Array");
                var child = this.clone();
                child._baseState.implicit = null;
                content = this._createEncoderBuffer(data.map(function(item) {
                    var state = this._baseState;
                    return this._getUse(state.args[0], data)._encode(item, reporter);
                }, child));
            } else if (state.use !== null) {
                result = this._getUse(state.use, parent)._encode(data, reporter);
            } else {
                content = this._encodePrimitive(state.tag, data);
                primitive = true;
            }
        }
        var result;
        if (!state.any && state.choice === null) {
            var tag = state.implicit !== null ? state.implicit : state.tag;
            var cls = state.implicit === null ? "universal" : "context";
            if (tag === null) {
                if (state.use === null) reporter.error("Tag could be omitted only for .use()");
            } else {
                if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
            }
        }
        if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, "context", result);
        return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState;
        var node = state.choice[data.type];
        if (!node) {
            assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
        }
        return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        var state = this._baseState;
        if (/str$/.test(tag)) return this._encodeStr(data, tag); else if (tag === "objid" && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]); else if (tag === "objid") return this._encodeObjid(data, null, null); else if (tag === "gentime" || tag === "utctime") return this._encodeTime(data, tag); else if (tag === "null_") return this._encodeNull(); else if (tag === "int" || tag === "enum") return this._encodeInt(data, state.args && state.reverseArgs[0]); else if (tag === "bool") return this._encodeBool(data); else if (tag === "objDesc") return this._encodeStr(data, tag); else throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
        return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
    };
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    function Reporter(options) {
        this._reporterState = {
            obj: null,
            path: [],
            options: options || {},
            errors: []
        };
    }
    exports.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
        var state = this._reporterState;
        return {
            obj: state.obj,
            pathLen: state.path.length
        };
    };
    Reporter.prototype.restore = function restore(data) {
        var state = this._reporterState;
        state.obj = data.obj;
        state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
        var state = this._reporterState;
        state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
        var state = this._reporterState;
        this.exitKey(index);
        if (state.obj !== null) state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
        return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState;
        var prev = state.obj;
        state.obj = {};
        return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState;
        var now = state.obj;
        state.obj = prev;
        return now;
    };
    Reporter.prototype.error = function error(msg) {
        var err;
        var state = this._reporterState;
        var inherited = msg instanceof ReporterError;
        if (inherited) {
            err = msg;
        } else {
            err = new ReporterError(state.path.map(function(elem) {
                return "[" + JSON.stringify(elem) + "]";
            }).join(""), msg.message || msg, msg.stack);
        }
        if (!state.options.partial) throw err;
        if (!inherited) state.errors.push(err);
        return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial) return result;
        return {
            result: this.isError(result) ? null : result,
            errors: state.errors
        };
    };
    function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + " at: " + (this.path || "(shallow)");
        if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);
        if (!this.stack) {
            try {
                throw new Error(this.message);
            } catch (e) {
                this.stack = e.stack;
            }
        }
        return this;
    };
}, function(module, exports) {
    var indexOf = [].indexOf;
    module.exports = function(arr, obj) {
        if (indexOf) return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
            if (arr[i] === obj) return i;
        }
        return -1;
    };
}, function(module, exports, __webpack_require__) {
    var asn1 = __webpack_require__(33);
    var inherits = __webpack_require__(3);
    var api = exports;
    api.define = function define(name, body) {
        return new Entity(name, body);
    };
    function Entity(name, body) {
        this.name = name;
        this.body = body;
        this.decoders = {};
        this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base) {
        var named;
        try {
            named = __webpack_require__(133).runInThisContext("(function " + this.name + "(entity) {\n" + "  this._initNamed(entity);\n" + "})");
        } catch (e) {
            named = function(entity) {
                this._initNamed(entity);
            };
        }
        inherits(named, base);
        named.prototype._initNamed = function initnamed(entity) {
            base.call(this, entity);
        };
        return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
        enc = enc || "der";
        if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
        return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
        enc = enc || "der";
        if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
        return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
        return this._getEncoder(enc).encode(data, reporter);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asn1 = __webpack_require__(33);
    exports.certificate = __webpack_require__(361);
    var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    exports.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn1.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    exports.RSAPublicKey = RSAPublicKey;
    var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
    });
    exports.PublicKey = PublicKey;
    var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    });
    var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
    });
    exports.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    exports.DSAPrivateKey = DSAPrivateKey;
    exports.DSAparam = asn1.define("DSAparam", function() {
        this.int();
    });
    var ECPrivateKey = asn1.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
    });
    exports.ECPrivateKey = ECPrivateKey;
    var ECParameters = asn1.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        });
    });
    exports.signature = asn1.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
    });
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var createHmac = __webpack_require__(147);
        var crt = __webpack_require__(73);
        var EC = __webpack_require__(14).ec;
        var BN = __webpack_require__(9);
        var parseKeys = __webpack_require__(59);
        var curves = __webpack_require__(128);
        function sign(hash, key, hashType, signType, tag) {
            var priv = parseKeys(key);
            if (priv.curve) {
                if (signType !== "ecdsa" && signType !== "ecdsa/rsa") throw new Error("wrong private key type");
                return ecSign(hash, priv);
            } else if (priv.type === "dsa") {
                if (signType !== "dsa") throw new Error("wrong private key type");
                return dsaSign(hash, priv, hashType);
            } else {
                if (signType !== "rsa" && signType !== "ecdsa/rsa") throw new Error("wrong private key type");
            }
            hash = Buffer.concat([ tag, hash ]);
            var len = priv.modulus.byteLength();
            var pad = [ 0, 1 ];
            while (hash.length + pad.length + 1 < len) pad.push(255);
            pad.push(0);
            var i = -1;
            while (++i < hash.length) pad.push(hash[i]);
            var out = crt(pad, priv);
            return out;
        }
        function ecSign(hash, priv) {
            var curveId = curves[priv.curve.join(".")];
            if (!curveId) throw new Error("unknown curve " + priv.curve.join("."));
            var curve = new EC(curveId);
            var key = curve.keyFromPrivate(priv.privateKey);
            var out = key.sign(hash);
            return new Buffer(out.toDER());
        }
        function dsaSign(hash, priv, algo) {
            var x = priv.params.priv_key;
            var p = priv.params.p;
            var q = priv.params.q;
            var g = priv.params.g;
            var r = new BN(0);
            var k;
            var H = bits2int(hash, q).mod(q);
            var s = false;
            var kv = getKey(x, q, hash, algo);
            while (s === false) {
                k = makeKey(q, kv, algo);
                r = makeR(g, k, p, q);
                s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
                if (s.cmpn(0) === 0) {
                    s = false;
                    r = new BN(0);
                }
            }
            return toDER(r, s);
        }
        function toDER(r, s) {
            r = r.toArray();
            s = s.toArray();
            if (r[0] & 128) r = [ 0 ].concat(r);
            if (s[0] & 128) s = [ 0 ].concat(s);
            var total = r.length + s.length + 4;
            var res = [ 48, total, 2, r.length ];
            res = res.concat(r, [ 2, s.length ], s);
            return new Buffer(res);
        }
        function getKey(x, q, hash, algo) {
            x = new Buffer(x.toArray());
            if (x.length < q.byteLength()) {
                var zeros = new Buffer(q.byteLength() - x.length);
                zeros.fill(0);
                x = Buffer.concat([ zeros, x ]);
            }
            var hlen = hash.length;
            var hbits = bits2octets(hash, q);
            var v = new Buffer(hlen);
            v.fill(1);
            var k = new Buffer(hlen);
            k.fill(0);
            k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest();
            v = createHmac(algo, k).update(v).digest();
            k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest();
            v = createHmac(algo, k).update(v).digest();
            return {
                k,
                v
            };
        }
        function bits2int(obits, q) {
            var bits = new BN(obits);
            var shift = (obits.length << 3) - q.bitLength();
            if (shift > 0) bits.ishrn(shift);
            return bits;
        }
        function bits2octets(bits, q) {
            bits = bits2int(bits, q);
            bits = bits.mod(q);
            var out = new Buffer(bits.toArray());
            if (out.length < q.byteLength()) {
                var zeros = new Buffer(q.byteLength() - out.length);
                zeros.fill(0);
                out = Buffer.concat([ zeros, out ]);
            }
            return out;
        }
        function makeKey(q, kv, algo) {
            var t;
            var k;
            do {
                t = new Buffer(0);
                while (t.length * 8 < q.bitLength()) {
                    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
                    t = Buffer.concat([ t, kv.v ]);
                }
                k = bits2int(t, q);
                kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest();
                kv.v = createHmac(algo, kv.k).update(kv.v).digest();
            } while (k.cmp(q) !== -1);
            return k;
        }
        function makeR(g, k, p, q) {
            return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
        }
        module.exports = sign;
        module.exports.getKey = getKey;
        module.exports.makeKey = makeKey;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var createHash = __webpack_require__(44);
        var stream = __webpack_require__(43);
        var inherits = __webpack_require__(3);
        var sign = __webpack_require__(372);
        var verify = __webpack_require__(358);
        var algorithms = __webpack_require__(145);
        Object.keys(algorithms).forEach(function(key) {
            algorithms[key].id = new Buffer(algorithms[key].id, "hex");
            algorithms[key.toLowerCase()] = algorithms[key];
        });
        function Sign(algorithm) {
            stream.Writable.call(this);
            var data = algorithms[algorithm];
            if (!data) throw new Error("Unknown message digest");
            this._hashType = data.hash;
            this._hash = createHash(data.hash);
            this._tag = data.id;
            this._signType = data.sign;
        }
        inherits(Sign, stream.Writable);
        Sign.prototype._write = function _write(data, _, done) {
            this._hash.update(data);
            done();
        };
        Sign.prototype.update = function update(data, enc) {
            if (typeof data === "string") data = new Buffer(data, enc);
            this._hash.update(data);
            return this;
        };
        Sign.prototype.sign = function signMethod(key, enc) {
            this.end();
            var hash = this._hash.digest();
            var sig = sign(hash, key, this._hashType, this._signType, this._tag);
            return enc ? sig.toString(enc) : sig;
        };
        function Verify(algorithm) {
            stream.Writable.call(this);
            var data = algorithms[algorithm];
            if (!data) throw new Error("Unknown message digest");
            this._hash = createHash(data.hash);
            this._tag = data.id;
            this._signType = data.sign;
        }
        inherits(Verify, stream.Writable);
        Verify.prototype._write = function _write(data, _, done) {
            this._hash.update(data);
            done();
        };
        Verify.prototype.update = function update(data, enc) {
            if (typeof data === "string") data = new Buffer(data, enc);
            this._hash.update(data);
            return this;
        };
        Verify.prototype.verify = function verifyMethod(key, sig, enc) {
            if (typeof sig === "string") sig = new Buffer(sig, enc);
            this.end();
            var hash = this._hash.digest();
            return verify(sig, hash, key, this._signType, this._tag);
        };
        function createSign(algorithm) {
            return new Sign(algorithm);
        }
        function createVerify(algorithm) {
            return new Verify(algorithm);
        }
        module.exports = {
            Sign: createSign,
            Verify: createVerify,
            createSign,
            createVerify
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var BN = __webpack_require__(9);
        var MillerRabin = __webpack_require__(134);
        var millerRabin = new MillerRabin();
        var TWENTYFOUR = new BN(24);
        var ELEVEN = new BN(11);
        var TEN = new BN(10);
        var THREE = new BN(3);
        var SEVEN = new BN(7);
        var primes = __webpack_require__(135);
        var randomBytes = __webpack_require__(35);
        module.exports = DH;
        function setPublicKey(pub, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(pub)) {
                pub = new Buffer(pub, enc);
            }
            this._pub = new BN(pub);
            return this;
        }
        function setPrivateKey(priv, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(priv)) {
                priv = new Buffer(priv, enc);
            }
            this._priv = new BN(priv);
            return this;
        }
        var primeCache = {};
        function checkPrime(prime, generator) {
            var gen = generator.toString("hex");
            var hex = [ gen, prime.toString(16) ].join("_");
            if (hex in primeCache) {
                return primeCache[hex];
            }
            var error = 0;
            if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
                error += 1;
                if (gen === "02" || gen === "05") {
                    error += 8;
                } else {
                    error += 4;
                }
                primeCache[hex] = error;
                return error;
            }
            if (!millerRabin.test(prime.shrn(1))) {
                error += 2;
            }
            var rem;
            switch (gen) {
              case "02":
                if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                    error += 8;
                }
                break;

              case "05":
                rem = prime.mod(TEN);
                if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                    error += 8;
                }
                break;

              default:
                error += 4;
            }
            primeCache[hex] = error;
            return error;
        }
        function DH(prime, generator, malleable) {
            this.setGenerator(generator);
            this.__prime = new BN(prime);
            this._prime = BN.mont(this.__prime);
            this._primeLen = prime.length;
            this._pub = undefined;
            this._priv = undefined;
            this._primeCode = undefined;
            if (malleable) {
                this.setPublicKey = setPublicKey;
                this.setPrivateKey = setPrivateKey;
            } else {
                this._primeCode = 8;
            }
        }
        Object.defineProperty(DH.prototype, "verifyError", {
            enumerable: true,
            get: function() {
                if (typeof this._primeCode !== "number") {
                    this._primeCode = checkPrime(this.__prime, this.__gen);
                }
                return this._primeCode;
            }
        });
        DH.prototype.generateKeys = function() {
            if (!this._priv) {
                this._priv = new BN(randomBytes(this._primeLen));
            }
            this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
            return this.getPublicKey();
        };
        DH.prototype.computeSecret = function(other) {
            other = new BN(other);
            other = other.toRed(this._prime);
            var secret = other.redPow(this._priv).fromRed();
            var out = new Buffer(secret.toArray());
            var prime = this.getPrime();
            if (out.length < prime.length) {
                var front = new Buffer(prime.length - out.length);
                front.fill(0);
                out = Buffer.concat([ front, out ]);
            }
            return out;
        };
        DH.prototype.getPublicKey = function getPublicKey(enc) {
            return formatReturnValue(this._pub, enc);
        };
        DH.prototype.getPrivateKey = function getPrivateKey(enc) {
            return formatReturnValue(this._priv, enc);
        };
        DH.prototype.getPrime = function(enc) {
            return formatReturnValue(this.__prime, enc);
        };
        DH.prototype.getGenerator = function(enc) {
            return formatReturnValue(this._gen, enc);
        };
        DH.prototype.setGenerator = function(gen, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(gen)) {
                gen = new Buffer(gen, enc);
            }
            this.__gen = gen;
            this._gen = new BN(gen);
            return this;
        };
        function formatReturnValue(bn, enc) {
            var buf = new Buffer(bn.toArray());
            if (!enc) {
                return buf;
            } else {
                return buf.toString(enc);
            }
        }
    }).call(this, __webpack_require__(4).Buffer);
}, function(module) {
    module.exports = {
        modp1: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
        },
        modp2: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
        },
        modp5: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
        },
        modp14: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
        },
        modp15: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
        },
        modp16: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
        },
        modp17: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
        },
        modp18: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
        }
    };
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var generatePrime = __webpack_require__(135);
        var primes = __webpack_require__(375);
        var DH = __webpack_require__(374);
        function getDiffieHellman(mod) {
            var prime = new Buffer(primes[mod].prime, "hex");
            var gen = new Buffer(primes[mod].gen, "hex");
            return new DH(prime, gen);
        }
        var ENCODINGS = {
            binary: true,
            hex: true,
            base64: true
        };
        function createDiffieHellman(prime, enc, generator, genc) {
            if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
                return createDiffieHellman(prime, "binary", enc, generator);
            }
            enc = enc || "binary";
            genc = genc || "binary";
            generator = generator || new Buffer([ 2 ]);
            if (!Buffer.isBuffer(generator)) {
                generator = new Buffer(generator, genc);
            }
            if (typeof prime === "number") {
                return new DH(generatePrime(prime, generator), generator, true);
            }
            if (!Buffer.isBuffer(prime)) {
                prime = new Buffer(prime, enc);
            }
            return new DH(prime, generator, true);
        }
        exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
        exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports) {
    exports["des-ecb"] = {
        key: 8,
        iv: 0
    };
    exports["des-cbc"] = exports.des = {
        key: 8,
        iv: 8
    };
    exports["des-ede3-cbc"] = exports.des3 = {
        key: 24,
        iv: 8
    };
    exports["des-ede3"] = {
        key: 24,
        iv: 0
    };
    exports["des-ede-cbc"] = {
        key: 16,
        iv: 8
    };
    exports["des-ede"] = {
        key: 16,
        iv: 0
    };
}, function(module, exports, __webpack_require__) {
    var AuthCipher = __webpack_require__(137);
    var Buffer = __webpack_require__(7).Buffer;
    var MODES = __webpack_require__(74);
    var StreamCipher = __webpack_require__(136);
    var Transform = __webpack_require__(23);
    var aes = __webpack_require__(61);
    var ebtk = __webpack_require__(60);
    var inherits = __webpack_require__(3);
    function Decipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._last = void 0;
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._mode = mode;
        this._autopadding = true;
    }
    inherits(Decipher, Transform);
    Decipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get(this._autopadding)) {
            thing = this._mode.decrypt(this, chunk);
            out.push(thing);
        }
        return Buffer.concat(out);
    };
    Decipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
            return unpad(this._mode.decrypt(this, chunk));
        } else if (chunk) {
            throw new Error("data not multiple of block length");
        }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
    };
    function Splitter() {
        this.cache = Buffer.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
        this.cache = Buffer.concat([ this.cache, data ]);
    };
    Splitter.prototype.get = function(autoPadding) {
        var out;
        if (autoPadding) {
            if (this.cache.length > 16) {
                out = this.cache.slice(0, 16);
                this.cache = this.cache.slice(16);
                return out;
            }
        } else {
            if (this.cache.length >= 16) {
                out = this.cache.slice(0, 16);
                this.cache = this.cache.slice(16);
                return out;
            }
        }
        return null;
    };
    Splitter.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function unpad(last) {
        var padded = last[15];
        if (padded < 1 || padded > 16) {
            throw new Error("unable to decrypt data");
        }
        var i = -1;
        while (++i < padded) {
            if (last[i + (16 - padded)] !== padded) {
                throw new Error("unable to decrypt data");
            }
        }
        if (padded === 16) return;
        return last.slice(0, 16 - padded);
    }
    function createDecipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config) throw new TypeError("invalid suite type");
        if (typeof iv === "string") iv = Buffer.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
        if (typeof password === "string") password = Buffer.from(password);
        if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
        if (config.type === "stream") {
            return new StreamCipher(config.module, password, iv, true);
        } else if (config.type === "auth") {
            return new AuthCipher(config.module, password, iv, true);
        }
        return new Decipher(config.module, password, iv);
    }
    function createDecipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config) throw new TypeError("invalid suite type");
        var keys = ebtk(password, false, config.key, config.iv);
        return createDecipheriv(suite, keys.key, keys.iv);
    }
    exports.createDecipher = createDecipher;
    exports.createDecipheriv = createDecipheriv;
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    var ZEROES = Buffer.alloc(16, 0);
    function toArray(buf) {
        return [ buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12) ];
    }
    function fromArray(out) {
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0] >>> 0, 0);
        buf.writeUInt32BE(out[1] >>> 0, 4);
        buf.writeUInt32BE(out[2] >>> 0, 8);
        buf.writeUInt32BE(out[3] >>> 0, 12);
        return buf;
    }
    function GHASH(key) {
        this.h = key;
        this.state = Buffer.alloc(16, 0);
        this.cache = Buffer.allocUnsafe(0);
    }
    GHASH.prototype.ghash = function(block) {
        var i = -1;
        while (++i < block.length) {
            this.state[i] ^= block[i];
        }
        this._multiply();
    };
    GHASH.prototype._multiply = function() {
        var Vi = toArray(this.h);
        var Zi = [ 0, 0, 0, 0 ];
        var j, xi, lsbVi;
        var i = -1;
        while (++i < 128) {
            xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
            if (xi) {
                Zi[0] ^= Vi[0];
                Zi[1] ^= Vi[1];
                Zi[2] ^= Vi[2];
                Zi[3] ^= Vi[3];
            }
            lsbVi = (Vi[3] & 1) !== 0;
            for (j = 3; j > 0; j--) {
                Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
            }
            Vi[0] = Vi[0] >>> 1;
            if (lsbVi) {
                Vi[0] = Vi[0] ^ 225 << 24;
            }
        }
        this.state = fromArray(Zi);
    };
    GHASH.prototype.update = function(buf) {
        this.cache = Buffer.concat([ this.cache, buf ]);
        var chunk;
        while (this.cache.length >= 16) {
            chunk = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            this.ghash(chunk);
        }
    };
    GHASH.prototype.final = function(abl, bl) {
        if (this.cache.length) {
            this.ghash(Buffer.concat([ this.cache, ZEROES ], 16));
        }
        this.ghash(fromArray([ 0, abl, 0, bl ]));
        return this.state;
    };
    module.exports = GHASH;
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var xor = __webpack_require__(41);
        function getBlock(self) {
            self._prev = self._cipher.encryptBlock(self._prev);
            return self._prev;
        }
        exports.encrypt = function(self, chunk) {
            while (self._cache.length < chunk.length) {
                self._cache = Buffer.concat([ self._cache, getBlock(self) ]);
            }
            var pad = self._cache.slice(0, chunk.length);
            self._cache = self._cache.slice(chunk.length);
            return xor(chunk, pad);
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    function encryptByte(self, byteParam, decrypt) {
        var pad;
        var i = -1;
        var len = 8;
        var out = 0;
        var bit, value;
        while (++i < len) {
            pad = self._cipher.encryptBlock(self._prev);
            bit = byteParam & 1 << 7 - i ? 128 : 0;
            value = pad[0] ^ bit;
            out += (value & 128) >> i % 8;
            self._prev = shiftIn(self._prev, decrypt ? bit : value);
        }
        return out;
    }
    function shiftIn(buffer, value) {
        var len = buffer.length;
        var i = -1;
        var out = Buffer.allocUnsafe(buffer.length);
        buffer = Buffer.concat([ buffer, Buffer.from([ value ]) ]);
        while (++i < len) {
            out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
        }
        return out;
    }
    exports.encrypt = function(self, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
            out[i] = encryptByte(self, chunk[i], decrypt);
        }
        return out;
    };
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    function encryptByte(self, byteParam, decrypt) {
        var pad = self._cipher.encryptBlock(self._prev);
        var out = pad[0] ^ byteParam;
        self._prev = Buffer.concat([ self._prev.slice(1), Buffer.from([ decrypt ? byteParam : out ]) ]);
        return out;
    }
    exports.encrypt = function(self, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
            out[i] = encryptByte(self, chunk[i], decrypt);
        }
        return out;
    };
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(7).Buffer;
    var xor = __webpack_require__(41);
    function encryptStart(self, data, decrypt) {
        var len = data.length;
        var out = xor(data, self._cache);
        self._cache = self._cache.slice(len);
        self._prev = Buffer.concat([ self._prev, decrypt ? data : out ]);
        return out;
    }
    exports.encrypt = function(self, data, decrypt) {
        var out = Buffer.allocUnsafe(0);
        var len;
        while (data.length) {
            if (self._cache.length === 0) {
                self._cache = self._cipher.encryptBlock(self._prev);
                self._prev = Buffer.allocUnsafe(0);
            }
            if (self._cache.length <= data.length) {
                len = self._cache.length;
                out = Buffer.concat([ out, encryptStart(self, data.slice(0, len), decrypt) ]);
                data = data.slice(len);
            } else {
                out = Buffer.concat([ out, encryptStart(self, data, decrypt) ]);
                break;
            }
        }
        return out;
    };
}, function(module, exports, __webpack_require__) {
    var xor = __webpack_require__(41);
    exports.encrypt = function(self, block) {
        var data = xor(block, self._prev);
        self._prev = self._cipher.encryptBlock(data);
        return self._prev;
    };
    exports.decrypt = function(self, block) {
        var pad = self._prev;
        self._prev = block;
        var out = self._cipher.decryptBlock(block);
        return xor(out, pad);
    };
}, function(module, exports) {
    exports.encrypt = function(self, block) {
        return self._cipher.encryptBlock(block);
    };
    exports.decrypt = function(self, block) {
        return self._cipher.decryptBlock(block);
    };
}, function(module, exports, __webpack_require__) {
    var MODES = __webpack_require__(74);
    var AuthCipher = __webpack_require__(137);
    var Buffer = __webpack_require__(7).Buffer;
    var StreamCipher = __webpack_require__(136);
    var Transform = __webpack_require__(23);
    var aes = __webpack_require__(61);
    var ebtk = __webpack_require__(60);
    var inherits = __webpack_require__(3);
    function Cipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._mode = mode;
        this._autopadding = true;
    }
    inherits(Cipher, Transform);
    Cipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get()) {
            thing = this._mode.encrypt(this, chunk);
            out.push(thing);
        }
        return Buffer.concat(out);
    };
    var PADDING = Buffer.alloc(16, 16);
    Cipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
            chunk = this._mode.encrypt(this, chunk);
            this._cipher.scrub();
            return chunk;
        }
        if (!chunk.equals(PADDING)) {
            this._cipher.scrub();
            throw new Error("data not multiple of block length");
        }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
    };
    function Splitter() {
        this.cache = Buffer.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
        this.cache = Buffer.concat([ this.cache, data ]);
    };
    Splitter.prototype.get = function() {
        if (this.cache.length > 15) {
            var out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
        return null;
    };
    Splitter.prototype.flush = function() {
        var len = 16 - this.cache.length;
        var padBuff = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
            padBuff.writeUInt8(len, i);
        }
        return Buffer.concat([ this.cache, padBuff ]);
    };
    function createCipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config) throw new TypeError("invalid suite type");
        if (typeof password === "string") password = Buffer.from(password);
        if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
        if (typeof iv === "string") iv = Buffer.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
        if (config.type === "stream") {
            return new StreamCipher(config.module, password, iv);
        } else if (config.type === "auth") {
            return new AuthCipher(config.module, password, iv);
        }
        return new Cipher(config.module, password, iv);
    }
    function createCipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config) throw new TypeError("invalid suite type");
        var keys = ebtk(password, false, config.key, config.iv);
        return createCipheriv(suite, keys.key, keys.iv);
    }
    exports.createCipheriv = createCipheriv;
    exports.createCipher = createCipher;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assert = __webpack_require__(15);
    var inherits = __webpack_require__(3);
    var des = __webpack_require__(76);
    var Cipher = des.Cipher;
    var DES = des.DES;
    function EDEState(type, key) {
        assert.equal(key.length, 24, "Invalid key length");
        var k1 = key.slice(0, 8);
        var k2 = key.slice(8, 16);
        var k3 = key.slice(16, 24);
        if (type === "encrypt") {
            this.ciphers = [ DES.create({
                type: "encrypt",
                key: k1
            }), DES.create({
                type: "decrypt",
                key: k2
            }), DES.create({
                type: "encrypt",
                key: k3
            }) ];
        } else {
            this.ciphers = [ DES.create({
                type: "decrypt",
                key: k3
            }), DES.create({
                type: "encrypt",
                key: k2
            }), DES.create({
                type: "decrypt",
                key: k1
            }) ];
        }
    }
    function EDE(options) {
        Cipher.call(this, options);
        var state = new EDEState(this.type, this.options.key);
        this._edeState = state;
    }
    inherits(EDE, Cipher);
    module.exports = EDE;
    EDE.create = function create(options) {
        return new EDE(options);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._edeState;
        state.ciphers[0]._update(inp, inOff, out, outOff);
        state.ciphers[1]._update(out, outOff, out, outOff);
        state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assert = __webpack_require__(15);
    var inherits = __webpack_require__(3);
    var proto = {};
    function CBCState(iv) {
        assert.equal(iv.length, 8, "Invalid IV length");
        this.iv = new Array(8);
        for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
    }
    function instantiate(Base) {
        function CBC(options) {
            Base.call(this, options);
            this._cbcInit();
        }
        inherits(CBC, Base);
        var keys = Object.keys(proto);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            CBC.prototype[key] = proto[key];
        }
        CBC.create = function create(options) {
            return new CBC(options);
        };
        return CBC;
    }
    exports.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
        var state = new CBCState(this.options.iv);
        this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
        var state = this._cbcState;
        var superProto = this.constructor.super_.prototype;
        var iv = state.iv;
        if (this.type === "encrypt") {
            for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];
            superProto._update.call(this, iv, 0, out, outOff);
            for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
        } else {
            superProto._update.call(this, inp, inOff, out, outOff);
            for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];
            for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assert = __webpack_require__(15);
    var inherits = __webpack_require__(3);
    var des = __webpack_require__(76);
    var utils = des.utils;
    var Cipher = des.Cipher;
    function DESState() {
        this.tmp = new Array(2);
        this.keys = null;
    }
    function DES(options) {
        Cipher.call(this, options);
        var state = new DESState();
        this._desState = state;
        this.deriveKeys(state, options.key);
    }
    inherits(DES, Cipher);
    module.exports = DES;
    DES.create = function create(options) {
        return new DES(options);
    };
    var shiftTable = [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
        state.keys = new Array(16 * 2);
        assert.equal(key.length, this.blockSize, "Invalid key length");
        var kL = utils.readUInt32BE(key, 0);
        var kR = utils.readUInt32BE(key, 4);
        utils.pc1(kL, kR, state.tmp, 0);
        kL = state.tmp[0];
        kR = state.tmp[1];
        for (var i = 0; i < state.keys.length; i += 2) {
            var shift = shiftTable[i >>> 1];
            kL = utils.r28shl(kL, shift);
            kR = utils.r28shl(kR, shift);
            utils.pc2(kL, kR, state.keys, i);
        }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._desState;
        var l = utils.readUInt32BE(inp, inOff);
        var r = utils.readUInt32BE(inp, inOff + 4);
        utils.ip(l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        if (this.type === "encrypt") this._encrypt(state, l, r, state.tmp, 0); else this._decrypt(state, l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        utils.writeUInt32BE(out, l, outOff);
        utils.writeUInt32BE(out, r, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer, off) {
        var value = buffer.length - off;
        for (var i = off; i < buffer.length; i++) buffer[i] = value;
        return true;
    };
    DES.prototype._unpad = function _unpad(buffer) {
        var pad = buffer[buffer.length - 1];
        for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad);
        return buffer.slice(0, buffer.length - pad);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
        var l = lStart;
        var r = rStart;
        for (var i = 0; i < state.keys.length; i += 2) {
            var keyL = state.keys[i];
            var keyR = state.keys[i + 1];
            utils.expand(r, state.tmp, 0);
            keyL ^= state.tmp[0];
            keyR ^= state.tmp[1];
            var s = utils.substitute(keyL, keyR);
            var f = utils.permute(s);
            var t = r;
            r = (l ^ f) >>> 0;
            l = t;
        }
        utils.rip(r, l, out, off);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
        var l = rStart;
        var r = lStart;
        for (var i = state.keys.length - 2; i >= 0; i -= 2) {
            var keyL = state.keys[i];
            var keyR = state.keys[i + 1];
            utils.expand(l, state.tmp, 0);
            keyL ^= state.tmp[0];
            keyR ^= state.tmp[1];
            var s = utils.substitute(keyL, keyR);
            var f = utils.permute(s);
            var t = l;
            l = (r ^ f) >>> 0;
            r = t;
        }
        utils.rip(l, r, out, off);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assert = __webpack_require__(15);
    function Cipher(options) {
        this.options = options;
        this.type = this.options.type;
        this.blockSize = 8;
        this._init();
        this.buffer = new Array(this.blockSize);
        this.bufferOff = 0;
    }
    module.exports = Cipher;
    Cipher.prototype._init = function _init() {};
    Cipher.prototype.update = function update(data) {
        if (data.length === 0) return [];
        if (this.type === "decrypt") return this._updateDecrypt(data); else return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
        var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
        for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];
        this.bufferOff += min;
        return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
        this._update(this.buffer, 0, out, off);
        this.bufferOff = 0;
        return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = (this.bufferOff + data.length) / this.blockSize | 0;
        var out = new Array(count * this.blockSize);
        if (this.bufferOff !== 0) {
            inputOff += this._buffer(data, inputOff);
            if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
        }
        var max = data.length - (data.length - inputOff) % this.blockSize;
        for (;inputOff < max; inputOff += this.blockSize) {
            this._update(data, inputOff, out, outputOff);
            outputOff += this.blockSize;
        }
        for (;inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];
        return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
        var out = new Array(count * this.blockSize);
        for (;count > 0; count--) {
            inputOff += this._buffer(data, inputOff);
            outputOff += this._flushBuffer(out, outputOff);
        }
        inputOff += this._buffer(data, inputOff);
        return out;
    };
    Cipher.prototype.final = function final(buffer) {
        var first;
        if (buffer) first = this.update(buffer);
        var last;
        if (this.type === "encrypt") last = this._finalEncrypt(); else last = this._finalDecrypt();
        if (first) return first.concat(last); else return last;
    };
    Cipher.prototype._pad = function _pad(buffer, off) {
        if (off === 0) return false;
        while (off < buffer.length) buffer[off++] = 0;
        return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
        if (!this._pad(this.buffer, this.bufferOff)) return [];
        var out = new Array(this.blockSize);
        this._update(this.buffer, 0, out, 0);
        return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
        return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
        assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var out = new Array(this.blockSize);
        this._flushBuffer(out, 0);
        return this._unpad(out);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.readUInt32BE = function readUInt32BE(bytes, off) {
        var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
        return res >>> 0;
    };
    exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
        bytes[0 + off] = value >>> 24;
        bytes[1 + off] = value >>> 16 & 255;
        bytes[2 + off] = value >>> 8 & 255;
        bytes[3 + off] = value & 255;
    };
    exports.ip = function ip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 6; i >= 0; i -= 2) {
            for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= inR >>> j + i & 1;
            }
            for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= inL >>> j + i & 1;
            }
        }
        for (var i = 6; i >= 0; i -= 2) {
            for (var j = 1; j <= 25; j += 8) {
                outR <<= 1;
                outR |= inR >>> j + i & 1;
            }
            for (var j = 1; j <= 25; j += 8) {
                outR <<= 1;
                outR |= inL >>> j + i & 1;
            }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
    };
    exports.rip = function rip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 0; i < 4; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                outL <<= 1;
                outL |= inR >>> j + i & 1;
                outL <<= 1;
                outL |= inL >>> j + i & 1;
            }
        }
        for (var i = 4; i < 8; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                outR <<= 1;
                outR |= inR >>> j + i & 1;
                outR <<= 1;
                outR |= inL >>> j + i & 1;
            }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
    };
    exports.pc1 = function pc1(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 7; i >= 5; i--) {
            for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= inR >> j + i & 1;
            }
            for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= inL >> j + i & 1;
            }
        }
        for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >> j + i & 1;
        }
        for (var i = 1; i <= 3; i++) {
            for (var j = 0; j <= 24; j += 8) {
                outR <<= 1;
                outR |= inR >> j + i & 1;
            }
            for (var j = 0; j <= 24; j += 8) {
                outR <<= 1;
                outR |= inL >> j + i & 1;
            }
        }
        for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inL >> j + i & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
    };
    exports.r28shl = function r28shl(num, shift) {
        return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [ 14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24 ];
    exports.pc2 = function pc2(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        var len = pc2table.length >>> 1;
        for (var i = 0; i < len; i++) {
            outL <<= 1;
            outL |= inL >>> pc2table[i] & 1;
        }
        for (var i = len; i < pc2table.length; i++) {
            outR <<= 1;
            outR |= inR >>> pc2table[i] & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
    };
    exports.expand = function expand(r, out, off) {
        var outL = 0;
        var outR = 0;
        outL = (r & 1) << 5 | r >>> 27;
        for (var i = 23; i >= 15; i -= 4) {
            outL <<= 6;
            outL |= r >>> i & 63;
        }
        for (var i = 11; i >= 3; i -= 4) {
            outR |= r >>> i & 63;
            outR <<= 6;
        }
        outR |= (r & 31) << 1 | r >>> 31;
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
    };
    var sTable = [ 14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11 ];
    exports.substitute = function substitute(inL, inR) {
        var out = 0;
        for (var i = 0; i < 4; i++) {
            var b = inL >>> 18 - i * 6 & 63;
            var sb = sTable[i * 64 + b];
            out <<= 4;
            out |= sb;
        }
        for (var i = 0; i < 4; i++) {
            var b = inR >>> 18 - i * 6 & 63;
            var sb = sTable[4 * 64 + i * 64 + b];
            out <<= 4;
            out |= sb;
        }
        return out >>> 0;
    };
    var permuteTable = [ 16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7 ];
    exports.permute = function permute(num) {
        var out = 0;
        for (var i = 0; i < permuteTable.length; i++) {
            out <<= 1;
            out |= num >>> permuteTable[i] & 1;
        }
        return out >>> 0;
    };
    exports.padSplit = function padSplit(num, size, group) {
        var str = num.toString(2);
        while (str.length < size) str = "0" + str;
        var out = [];
        for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group));
        return out.join(" ");
    };
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        var CipherBase = __webpack_require__(23);
        var des = __webpack_require__(76);
        var inherits = __webpack_require__(3);
        var modes = {
            "des-ede3-cbc": des.CBC.instantiate(des.EDE),
            "des-ede3": des.EDE,
            "des-ede-cbc": des.CBC.instantiate(des.EDE),
            "des-ede": des.EDE,
            "des-cbc": des.CBC.instantiate(des.DES),
            "des-ecb": des.DES
        };
        modes.des = modes["des-cbc"];
        modes.des3 = modes["des-ede3-cbc"];
        module.exports = DES;
        inherits(DES, CipherBase);
        function DES(opts) {
            CipherBase.call(this);
            var modeName = opts.mode.toLowerCase();
            var mode = modes[modeName];
            var type;
            if (opts.decrypt) {
                type = "decrypt";
            } else {
                type = "encrypt";
            }
            var key = opts.key;
            if (modeName === "des-ede" || modeName === "des-ede-cbc") {
                key = Buffer.concat([ key, key.slice(0, 8) ]);
            }
            var iv = opts.iv;
            this._des = mode.create({
                key,
                iv,
                type
            });
        }
        DES.prototype._update = function(data) {
            return new Buffer(this._des.update(data));
        };
        DES.prototype._final = function() {
            return new Buffer(this._des.final());
        };
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    var DES = __webpack_require__(392);
    var aes = __webpack_require__(75);
    var aesModes = __webpack_require__(74);
    var desModes = __webpack_require__(377);
    var ebtk = __webpack_require__(60);
    function createCipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
            keyLen = aesModes[suite].key;
            ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
            keyLen = desModes[suite].key * 8;
            ivLen = desModes[suite].iv;
        } else {
            throw new TypeError("invalid suite type");
        }
        var keys = ebtk(password, false, keyLen, ivLen);
        return createCipheriv(suite, keys.key, keys.iv);
    }
    function createDecipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
            keyLen = aesModes[suite].key;
            ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
            keyLen = desModes[suite].key * 8;
            ivLen = desModes[suite].iv;
        } else {
            throw new TypeError("invalid suite type");
        }
        var keys = ebtk(password, false, keyLen, ivLen);
        return createDecipheriv(suite, keys.key, keys.iv);
    }
    function createCipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
        if (desModes[suite]) return new DES({
            key,
            iv,
            mode: suite
        });
        throw new TypeError("invalid suite type");
    }
    function createDecipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
        if (desModes[suite]) return new DES({
            key,
            iv,
            mode: suite,
            decrypt: true
        });
        throw new TypeError("invalid suite type");
    }
    function getCiphers() {
        return Object.keys(desModes).concat(aes.getCiphers());
    }
    exports.createCipher = exports.Cipher = createCipher;
    exports.createCipheriv = exports.Cipheriv = createCipheriv;
    exports.createDecipher = exports.Decipher = createDecipher;
    exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
    exports.listCiphers = exports.getCiphers = getCiphers;
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        var checkParameters = __webpack_require__(143);
        var defaultEncoding = __webpack_require__(142);
        var sync = __webpack_require__(141);
        var Buffer = __webpack_require__(7).Buffer;
        var ZERO_BUF;
        var subtle = global.crypto && global.crypto.subtle;
        var toBrowser = {
            sha: "SHA-1",
            "sha-1": "SHA-1",
            sha1: "SHA-1",
            sha256: "SHA-256",
            "sha-256": "SHA-256",
            sha384: "SHA-384",
            "sha-384": "SHA-384",
            "sha-512": "SHA-512",
            sha512: "SHA-512"
        };
        var checks = [];
        function checkNative(algo) {
            if (global.process && !global.process.browser) {
                return Promise.resolve(false);
            }
            if (!subtle || !subtle.importKey || !subtle.deriveBits) {
                return Promise.resolve(false);
            }
            if (checks[algo] !== undefined) {
                return checks[algo];
            }
            ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
            var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
                return true;
            }).catch(function() {
                return false;
            });
            checks[algo] = prom;
            return prom;
        }
        function browserPbkdf2(password, salt, iterations, length, algo) {
            return subtle.importKey("raw", password, {
                name: "PBKDF2"
            }, false, [ "deriveBits" ]).then(function(key) {
                return subtle.deriveBits({
                    name: "PBKDF2",
                    salt,
                    iterations,
                    hash: {
                        name: algo
                    }
                }, key, length << 3);
            }).then(function(res) {
                return Buffer.from(res);
            });
        }
        function resolvePromise(promise, callback) {
            promise.then(function(out) {
                process.nextTick(function() {
                    callback(null, out);
                });
            }, function(e) {
                process.nextTick(function() {
                    callback(e);
                });
            });
        }
        module.exports = function(password, salt, iterations, keylen, digest, callback) {
            if (typeof digest === "function") {
                callback = digest;
                digest = undefined;
            }
            digest = digest || "sha1";
            var algo = toBrowser[digest.toLowerCase()];
            if (!algo || typeof global.Promise !== "function") {
                return process.nextTick(function() {
                    var out;
                    try {
                        out = sync(password, salt, iterations, keylen, digest);
                    } catch (e) {
                        return callback(e);
                    }
                    callback(null, out);
                });
            }
            checkParameters(password, salt, iterations, keylen);
            if (typeof callback !== "function") throw new Error("No callback provided to pbkdf2");
            if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding);
            if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding);
            resolvePromise(checkNative(algo).then(function(resp) {
                if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
                return sync(password, salt, iterations, keylen, digest);
            }), callback);
        };
    }).call(this, __webpack_require__(12), __webpack_require__(13));
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(145);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var inherits = __webpack_require__(3);
    var Buffer = __webpack_require__(7).Buffer;
    var Base = __webpack_require__(23);
    var ZEROS = Buffer.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
            key = Buffer.from(key);
        }
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
            key = alg(key);
        } else if (key.length < blocksize) {
            key = Buffer.concat([ key, ZEROS ], blocksize);
        }
        var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
        var opad = this._opad = Buffer.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
            ipad[i] = key[i] ^ 54;
            opad[i] = key[i] ^ 92;
        }
        this._hash = [ ipad ];
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
        this._hash.push(data);
    };
    Hmac.prototype._final = function() {
        var h = this._alg(Buffer.concat(this._hash));
        return this._alg(Buffer.concat([ this._opad, h ]));
    };
    module.exports = Hmac;
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var SHA512 = __webpack_require__(148);
    var Hash = __webpack_require__(34);
    var Buffer = __webpack_require__(7).Buffer;
    var W = new Array(160);
    function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
    };
    Sha384.prototype._hash = function() {
        var H = Buffer.allocUnsafe(48);
        function writeInt64BE(h, l, offset) {
            H.writeInt32BE(h, offset);
            H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
    };
    module.exports = Sha384;
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Sha256 = __webpack_require__(149);
    var Hash = __webpack_require__(34);
    var Buffer = __webpack_require__(7).Buffer;
    var W = new Array(64);
    function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
    };
    Sha224.prototype._hash = function() {
        var H = Buffer.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
    };
    module.exports = Sha224;
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Hash = __webpack_require__(34);
    var Buffer = __webpack_require__(7).Buffer;
    var K = [ 1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0 ];
    var W = new Array(80);
    function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
    };
    function rotl1(num) {
        return num << 1 | num >>> 31;
    }
    function rotl5(num) {
        return num << 5 | num >>> 27;
    }
    function rotl30(num) {
        return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
        if (s === 0) return b & c | ~b & d;
        if (s === 2) return b & c | b & d | c & d;
        return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
        var W = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
        for (;i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
        for (var j = 0; j < 80; ++j) {
            var s = ~~(j / 20);
            var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
            e = d;
            d = c;
            c = rotl30(b);
            b = a;
            a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
        var H = Buffer.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
    };
    module.exports = Sha1;
}, function(module, exports, __webpack_require__) {
    var inherits = __webpack_require__(3);
    var Hash = __webpack_require__(34);
    var Buffer = __webpack_require__(7).Buffer;
    var K = [ 1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0 ];
    var W = new Array(80);
    function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
    };
    function rotl5(num) {
        return num << 5 | num >>> 27;
    }
    function rotl30(num) {
        return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
        if (s === 0) return b & c | ~b & d;
        if (s === 2) return b & c | b & d | c & d;
        return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
        var W = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
        for (;i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
        for (var j = 0; j < 80; ++j) {
            var s = ~~(j / 20);
            var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
            e = d;
            d = c;
            c = rotl30(b);
            b = a;
            a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
        var H = Buffer.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
    };
    module.exports = Sha;
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(81).PassThrough;
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(81).Transform;
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(26);
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(80);
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = PassThrough;
    var Transform = __webpack_require__(150);
    var util = __webpack_require__(42);
    util.inherits = __webpack_require__(3);
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
    };
}, function(module, exports, __webpack_require__) {
    (function(global) {
        module.exports = deprecate;
        function deprecate(fn, msg) {
            if (config("noDeprecation")) {
                return fn;
            }
            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (config("throwDeprecation")) {
                        throw new Error(msg);
                    } else if (config("traceDeprecation")) {
                        console.trace(msg);
                    } else {
                        console.warn(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }
            return deprecated;
        }
        function config(name) {
            try {
                if (!global.localStorage) return false;
            } catch (_) {
                return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === "true";
        }
    }).call(this, __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        (function(global, undefined) {
            "use strict";
            if (global.setImmediate) {
                return;
            }
            var nextHandle = 1;
            var tasksByHandle = {};
            var currentlyRunningATask = false;
            var doc = global.document;
            var registerImmediate;
            function setImmediate(callback) {
                if (typeof callback !== "function") {
                    callback = new Function("" + callback);
                }
                var args = new Array(arguments.length - 1);
                for (var i = 0; i < args.length; i++) {
                    args[i] = arguments[i + 1];
                }
                var task = {
                    callback,
                    args
                };
                tasksByHandle[nextHandle] = task;
                registerImmediate(nextHandle);
                return nextHandle++;
            }
            function clearImmediate(handle) {
                delete tasksByHandle[handle];
            }
            function run(task) {
                var callback = task.callback;
                var args = task.args;
                switch (args.length) {
                  case 0:
                    callback();
                    break;

                  case 1:
                    callback(args[0]);
                    break;

                  case 2:
                    callback(args[0], args[1]);
                    break;

                  case 3:
                    callback(args[0], args[1], args[2]);
                    break;

                  default:
                    callback.apply(undefined, args);
                    break;
                }
            }
            function runIfPresent(handle) {
                if (currentlyRunningATask) {
                    setTimeout(runIfPresent, 0, handle);
                } else {
                    var task = tasksByHandle[handle];
                    if (task) {
                        currentlyRunningATask = true;
                        try {
                            run(task);
                        } finally {
                            clearImmediate(handle);
                            currentlyRunningATask = false;
                        }
                    }
                }
            }
            function installNextTickImplementation() {
                registerImmediate = function(handle) {
                    process.nextTick(function() {
                        runIfPresent(handle);
                    });
                };
            }
            function canUsePostMessage() {
                if (global.postMessage && !global.importScripts) {
                    var postMessageIsAsynchronous = true;
                    var oldOnMessage = global.onmessage;
                    global.onmessage = function() {
                        postMessageIsAsynchronous = false;
                    };
                    global.postMessage("", "*");
                    global.onmessage = oldOnMessage;
                    return postMessageIsAsynchronous;
                }
            }
            function installPostMessageImplementation() {
                var messagePrefix = "setImmediate$" + Math.random() + "$";
                var onGlobalMessage = function(event) {
                    if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                        runIfPresent(+event.data.slice(messagePrefix.length));
                    }
                };
                if (global.addEventListener) {
                    global.addEventListener("message", onGlobalMessage, false);
                } else {
                    global.attachEvent("onmessage", onGlobalMessage);
                }
                registerImmediate = function(handle) {
                    global.postMessage(messagePrefix + handle, "*");
                };
            }
            function installMessageChannelImplementation() {
                var channel = new MessageChannel();
                channel.port1.onmessage = function(event) {
                    var handle = event.data;
                    runIfPresent(handle);
                };
                registerImmediate = function(handle) {
                    channel.port2.postMessage(handle);
                };
            }
            function installReadyStateChangeImplementation() {
                var html = doc.documentElement;
                registerImmediate = function(handle) {
                    var script = doc.createElement("script");
                    script.onreadystatechange = function() {
                        runIfPresent(handle);
                        script.onreadystatechange = null;
                        html.removeChild(script);
                        script = null;
                    };
                    html.appendChild(script);
                };
            }
            function installSetTimeoutImplementation() {
                registerImmediate = function(handle) {
                    setTimeout(runIfPresent, 0, handle);
                };
            }
            var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
            attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
            if ({}.toString.call(global.process) === "[object process]") {
                installNextTickImplementation();
            } else if (canUsePostMessage()) {
                installPostMessageImplementation();
            } else if (global.MessageChannel) {
                installMessageChannelImplementation();
            } else if (doc && "onreadystatechange" in doc.createElement("script")) {
                installReadyStateChangeImplementation();
            } else {
                installSetTimeoutImplementation();
            }
            attachTo.setImmediate = setImmediate;
            attachTo.clearImmediate = clearImmediate;
        })(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
    }).call(this, __webpack_require__(12), __webpack_require__(13));
}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Buffer = __webpack_require__(7).Buffer;
    var util = __webpack_require__(408);
    function copyBuffer(src, target, offset) {
        src.copy(target, offset);
    }
    module.exports = function() {
        function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
        }
        BufferList.prototype.push = function push(v) {
            var entry = {
                data: v,
                next: null
            };
            if (this.length > 0) this.tail.next = entry; else this.head = entry;
            this.tail = entry;
            ++this.length;
        };
        BufferList.prototype.unshift = function unshift(v) {
            var entry = {
                data: v,
                next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
        };
        BufferList.prototype.shift = function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next;
            --this.length;
            return ret;
        };
        BufferList.prototype.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
        };
        BufferList.prototype.join = function join(s) {
            if (this.length === 0) return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
                ret += s + p.data;
            }
            return ret;
        };
        BufferList.prototype.concat = function concat(n) {
            if (this.length === 0) return Buffer.alloc(0);
            if (this.length === 1) return this.head.data;
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
                copyBuffer(p.data, ret, i);
                i += p.data.length;
                p = p.next;
            }
            return ret;
        };
        return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
        module.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({
                length: this.length
            });
            return this.constructor.name + " " + obj;
        };
    }
}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(35);
    exports.createHash = exports.Hash = __webpack_require__(44);
    exports.createHmac = exports.Hmac = __webpack_require__(147);
    var algos = __webpack_require__(395);
    var algoKeys = Object.keys(algos);
    var hashes = [ "sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160" ].concat(algoKeys);
    exports.getHashes = function() {
        return hashes;
    };
    var p = __webpack_require__(144);
    exports.pbkdf2 = p.pbkdf2;
    exports.pbkdf2Sync = p.pbkdf2Sync;
    var aes = __webpack_require__(393);
    exports.Cipher = aes.Cipher;
    exports.createCipher = aes.createCipher;
    exports.Cipheriv = aes.Cipheriv;
    exports.createCipheriv = aes.createCipheriv;
    exports.Decipher = aes.Decipher;
    exports.createDecipher = aes.createDecipher;
    exports.Decipheriv = aes.Decipheriv;
    exports.createDecipheriv = aes.createDecipheriv;
    exports.getCiphers = aes.getCiphers;
    exports.listCiphers = aes.listCiphers;
    var dh = __webpack_require__(376);
    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
    exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
    exports.getDiffieHellman = dh.getDiffieHellman;
    exports.createDiffieHellman = dh.createDiffieHellman;
    exports.DiffieHellman = dh.DiffieHellman;
    var sign = __webpack_require__(373);
    exports.createSign = sign.createSign;
    exports.Sign = sign.Sign;
    exports.createVerify = sign.createVerify;
    exports.Verify = sign.Verify;
    exports.createECDH = __webpack_require__(357);
    var publicEncrypt = __webpack_require__(356);
    exports.publicEncrypt = publicEncrypt.publicEncrypt;
    exports.privateEncrypt = publicEncrypt.privateEncrypt;
    exports.publicDecrypt = publicEncrypt.publicDecrypt;
    exports.privateDecrypt = publicEncrypt.privateDecrypt;
    var rf = __webpack_require__(353);
    exports.randomFill = rf.randomFill;
    exports.randomFillSync = rf.randomFillSync;
    exports.createCredentials = function() {
        throw new Error([ "sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify" ].join("\n"));
    };
    exports.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var BN = __webpack_require__(9);
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object") sig = parseBytes(sig);
        if (Array.isArray(sig)) {
            sig = {
                R: sig.slice(0, eddsa.encodingLength),
                S: sig.slice(eddsa.encodingLength)
            };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R)) this._R = sig.R;
        if (sig.S instanceof BN) this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub)) this._pub = params.pub; else this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair) return pub;
        return new KeyPair(eddsa, {
            pub
        });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair) return secret;
        return new KeyPair(eddsa, {
            secret
        });
    };
    KeyPair.prototype.secret = function secret() {
        return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var hash = __webpack_require__(36);
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = __webpack_require__(413);
    var Signature = __webpack_require__(412);
    function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA)) return new EDDSA(curve);
        var curve = elliptic.curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({
            R,
            S,
            Rencoded
        });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
        var hash = this.hash();
        for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);
        return utils.intFromLE(hash.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature) return sig;
        return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var BN = __webpack_require__(9);
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var assert = utils.assert;
    function Signature(options, enc) {
        if (options instanceof Signature) return options;
        if (this._importDER(options, enc)) return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === undefined) this.recoveryParam = null; else this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
        this.place = 0;
    }
    function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
            return initial;
        }
        var octetLen = initial & 15;
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
            val <<= 8;
            val |= buf[off];
        }
        p.place = off;
        return val;
    }
    function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
            i++;
        }
        if (i === 0) {
            return buf;
        }
        return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
            return false;
        }
        var len = getLength(data, p);
        if (len + p.place !== data.length) {
            return false;
        }
        if (data[p.place++] !== 2) {
            return false;
        }
        var rlen = getLength(data, p);
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
            return false;
        }
        var slen = getLength(data, p);
        if (data.length !== slen + p.place) {
            return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0 && r[1] & 128) {
            r = r.slice(1);
        }
        if (s[0] === 0 && s[1] & 128) {
            s = s.slice(1);
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
    };
    function constructLength(arr, len) {
        if (len < 128) {
            arr.push(len);
            return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
            arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128) r = [ 0 ].concat(r);
        if (s[0] & 128) s = [ 0 ].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
            s = s.slice(1);
        }
        var arr = [ 2 ];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [ 48 ];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var BN = __webpack_require__(9);
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var assert = utils.assert;
    function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv) this._importPrivate(options.priv, options.privEnc);
        if (options.pub) this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair) return pub;
        return new KeyPair(ec, {
            pub,
            pubEnc: enc
        });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair) return priv;
        return new KeyPair(ec, {
            priv,
            privEnc: enc
        });
    };
    KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity()) return {
            result: false,
            reason: "Invalid public key"
        };
        if (!pub.validate()) return {
            result: false,
            reason: "Public key is not a point"
        };
        if (!pub.mul(this.ec.curve.n).isInfinity()) return {
            result: false,
            reason: "Public key * N != O"
        };
        return {
            result: true,
            reason: null
        };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
            enc = compact;
            compact = null;
        }
        if (!this.pub) this.pub = this.ec.g.mul(this.priv);
        if (!enc) return this.pub;
        return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex") return this.priv.toString(16, 2); else return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
            if (this.ec.curve.type === "mont") {
                assert(key.x, "Need x coordinate");
            } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
                assert(key.x && key.y, "Need both x and y coordinate");
            }
            this.pub = this.ec.curve.point(key.x, key.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
        return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var hash = __webpack_require__(36);
    var utils = __webpack_require__(159);
    var assert = __webpack_require__(15);
    function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
            this.K[i] = 0;
            this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([ 0 ]);
        if (seed) kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed) return;
        this.K = this._hmac().update(this.V).update([ 1 ]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
            addEnc = add;
            add = entropyEnc;
            entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add = utils.toArray(add, addEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        if (typeof enc !== "string") {
            addEnc = add;
            add = enc;
            enc = null;
        }
        if (add) {
            add = utils.toArray(add, addEnc || "hex");
            this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
            this.V = this._hmac().update(this.V).digest();
            temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils.encode(res, enc);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var BN = __webpack_require__(9);
    var HmacDRBG = __webpack_require__(417);
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var assert = utils.assert;
    var KeyPair = __webpack_require__(416);
    var Signature = __webpack_require__(415);
    function EC(options) {
        if (!(this instanceof EC)) return new EC(options);
        if (typeof options === "string") {
            assert(elliptic.curves.hasOwnProperty(options), "Unknown curve " + options);
            options = elliptic.curves[options];
        }
        if (options instanceof elliptic.curves.PresetCurve) options = {
            curve: options
        };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options) options = {};
        var drbg = new HmacDRBG({
            hash: this.hash,
            pers: options.pers,
            persEnc: options.persEnc || "utf8",
            entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
            entropyEnc: options.entropy && options.entropyEnc || "utf8",
            nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        do {
            var priv = new BN(drbg.generate(bytes));
            if (priv.cmp(ns2) > 0) continue;
            priv.iaddn(1);
            return this.keyFromPrivate(priv);
        } while (true);
    };
    EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0) msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n); else return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
            options = enc;
            enc = null;
        }
        if (!options) options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({
            hash: this.hash,
            entropy: bkey,
            nonce,
            pers: options.pers,
            persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; true; iter++) {
            var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
            k = this._truncateToN(k, true);
            if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
            var kp = this.g.mul(k);
            if (kp.isInfinity()) continue;
            var kpX = kp.getX();
            var r = kpX.umod(this.n);
            if (r.cmpn(0) === 0) continue;
            var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
            s = s.umod(this.n);
            if (s.cmpn(0) === 0) continue;
            var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
            if (options.canonical && s.cmp(this.nh) > 0) {
                s = this.n.sub(s);
                recoveryParam ^= 1;
            }
            return new Signature({
                r,
                s,
                recoveryParam
            });
        }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        if (!this.curve._maxwellTrick) {
            var p = this.g.mulAdd(u1, key.getPublic(), u2);
            if (p.isInfinity()) return false;
            return p.getX().umod(this.n).cmp(r) === 0;
        }
        var p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
        if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd); else r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null) return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
            var Qprime;
            try {
                Qprime = this.recoverPubKey(e, signature, i);
            } catch (e) {
                continue;
            }
            if (Qprime.eq(Q)) return i;
        }
        throw new Error("Unable to find valid recovery factor");
    };
}, function(module, exports) {
    module.exports = {
        doubles: {
            step: 4,
            points: [ [ "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821" ], [ "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf" ], [ "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695" ], [ "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9" ], [ "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36" ], [ "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f" ], [ "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999" ], [ "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09" ], [ "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d" ], [ "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088" ], [ "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d" ], [ "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8" ], [ "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a" ], [ "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453" ], [ "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160" ], [ "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0" ], [ "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6" ], [ "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589" ], [ "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17" ], [ "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda" ], [ "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd" ], [ "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2" ], [ "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6" ], [ "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f" ], [ "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01" ], [ "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3" ], [ "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f" ], [ "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7" ], [ "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78" ], [ "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1" ], [ "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150" ], [ "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82" ], [ "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc" ], [ "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b" ], [ "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51" ], [ "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45" ], [ "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120" ], [ "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84" ], [ "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d" ], [ "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d" ], [ "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8" ], [ "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8" ], [ "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac" ], [ "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f" ], [ "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962" ], [ "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907" ], [ "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec" ], [ "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d" ], [ "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414" ], [ "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd" ], [ "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0" ], [ "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811" ], [ "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1" ], [ "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c" ], [ "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73" ], [ "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd" ], [ "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405" ], [ "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589" ], [ "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e" ], [ "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27" ], [ "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1" ], [ "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482" ], [ "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945" ], [ "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573" ], [ "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82" ] ]
        },
        naf: {
            wnd: 7,
            points: [ [ "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672" ], [ "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6" ], [ "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da" ], [ "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37" ], [ "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b" ], [ "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81" ], [ "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58" ], [ "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77" ], [ "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a" ], [ "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c" ], [ "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67" ], [ "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402" ], [ "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55" ], [ "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482" ], [ "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82" ], [ "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396" ], [ "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49" ], [ "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf" ], [ "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a" ], [ "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7" ], [ "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933" ], [ "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a" ], [ "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6" ], [ "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37" ], [ "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e" ], [ "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6" ], [ "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476" ], [ "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40" ], [ "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61" ], [ "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683" ], [ "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5" ], [ "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b" ], [ "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417" ], [ "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868" ], [ "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a" ], [ "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6" ], [ "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996" ], [ "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e" ], [ "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d" ], [ "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2" ], [ "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e" ], [ "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437" ], [ "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311" ], [ "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4" ], [ "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575" ], [ "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d" ], [ "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d" ], [ "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629" ], [ "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06" ], [ "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374" ], [ "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee" ], [ "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1" ], [ "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b" ], [ "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661" ], [ "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6" ], [ "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e" ], [ "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d" ], [ "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc" ], [ "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4" ], [ "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c" ], [ "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b" ], [ "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913" ], [ "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154" ], [ "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865" ], [ "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc" ], [ "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224" ], [ "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e" ], [ "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6" ], [ "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511" ], [ "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b" ], [ "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2" ], [ "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c" ], [ "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3" ], [ "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d" ], [ "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700" ], [ "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4" ], [ "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196" ], [ "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4" ], [ "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257" ], [ "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13" ], [ "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096" ], [ "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38" ], [ "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f" ], [ "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448" ], [ "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a" ], [ "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4" ], [ "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437" ], [ "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7" ], [ "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d" ], [ "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a" ], [ "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54" ], [ "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77" ], [ "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517" ], [ "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10" ], [ "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125" ], [ "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e" ], [ "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1" ], [ "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2" ], [ "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423" ], [ "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8" ], [ "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758" ], [ "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375" ], [ "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d" ], [ "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec" ], [ "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0" ], [ "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c" ], [ "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4" ], [ "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f" ], [ "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649" ], [ "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826" ], [ "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5" ], [ "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87" ], [ "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b" ], [ "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc" ], [ "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c" ], [ "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f" ], [ "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a" ], [ "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46" ], [ "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f" ], [ "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03" ], [ "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08" ], [ "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8" ], [ "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373" ], [ "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3" ], [ "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8" ], [ "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1" ], [ "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9" ] ]
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var assert = __webpack_require__(15);
    function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++) key.push(0);
        for (i = 0; i < key.length; i++) key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++) key[i] ^= 106;
        this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
    };
    Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var common = __webpack_require__(45);
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
        if (!(this instanceof RIPEMD160)) return new RIPEMD160();
        BlockHash.call(this);
        this.h = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];
        this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
            var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
            A = E;
            E = D;
            D = rotl32(C, 10);
            C = B;
            B = T;
            T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
            Ah = Eh;
            Eh = Dh;
            Dh = rotl32(Ch, 10);
            Ch = Bh;
            Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils.toHex32(this.h, "little"); else return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
        if (j <= 15) return x ^ y ^ z; else if (j <= 31) return x & y | ~x & z; else if (j <= 47) return (x | ~y) ^ z; else if (j <= 63) return x & z | y & ~z; else return x ^ (y | ~z);
    }
    function K(j) {
        if (j <= 15) return 0; else if (j <= 31) return 1518500249; else if (j <= 47) return 1859775393; else if (j <= 63) return 2400959708; else return 2840853838;
    }
    function Kh(j) {
        if (j <= 15) return 1352829926; else if (j <= 31) return 1548603684; else if (j <= 47) return 1836072691; else if (j <= 63) return 2053994217; else return 0;
    }
    var r = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ];
    var rh = [ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ];
    var s = [ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ];
    var sh = [ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var SHA512 = __webpack_require__(156);
    function SHA384() {
        if (!(this instanceof SHA384)) return new SHA384();
        SHA512.call(this);
        this.h = [ 3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428 ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils.toHex32(this.h.slice(0, 12), "big"); else return utils.split32(this.h.slice(0, 12), "big");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var SHA256 = __webpack_require__(157);
    function SHA224() {
        if (!(this instanceof SHA224)) return new SHA224();
        SHA256.call(this);
        this.h = [ 3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428 ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils.toHex32(this.h.slice(0, 7), "big"); else return utils.split32(this.h.slice(0, 7), "big");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(19);
    var common = __webpack_require__(45);
    var shaCommon = __webpack_require__(158);
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];
    function SHA1() {
        if (!(this instanceof SHA1)) return new SHA1();
        BlockHash.call(this);
        this.h = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];
        this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) W[i] = msg[start + i];
        for (;i < W.length; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
            var s = ~~(i / 20);
            var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
            e = d;
            d = c;
            c = rotl32(b, 30);
            b = a;
            a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils.toHex32(this.h, "big"); else return utils.split32(this.h, "big");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.sha1 = __webpack_require__(424);
    exports.sha224 = __webpack_require__(423);
    exports.sha256 = __webpack_require__(157);
    exports.sha384 = __webpack_require__(422);
    exports.sha512 = __webpack_require__(156);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curves = exports;
    var hash = __webpack_require__(36);
    var elliptic = __webpack_require__(14);
    var assert = elliptic.utils.assert;
    function PresetCurve(options) {
        if (options.type === "short") this.curve = new elliptic.curve.short(options); else if (options.type === "edwards") this.curve = new elliptic.curve.edwards(options); else this.curve = new elliptic.curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    value: curve
                });
                return curve;
            }
        });
    }
    defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: [ "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811" ]
    });
    defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: [ "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34" ]
    });
    defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: [ "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5" ]
    });
    defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f " + "5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 " + "f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: [ "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 " + "5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 " + "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f" ]
    });
    defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b " + "99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd " + "3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 " + "f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: [ "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 " + "053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 " + "a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 " + "579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 " + "3fad0761 353c7086 a272c240 88be9476 9fd16650" ]
    });
    defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [ "9" ]
    });
    defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [ "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658" ]
    });
    var pre;
    try {
        pre = __webpack_require__(419);
    } catch (e) {
        pre = undefined;
    }
    defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [ {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        } ],
        gRed: false,
        g: [ "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre ]
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = __webpack_require__(63);
    var elliptic = __webpack_require__(14);
    var BN = __webpack_require__(9);
    var inherits = __webpack_require__(3);
    var Base = curve.base;
    var assert = elliptic.utils.assert;
    function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA) return num.redNeg(); else return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC) return num; else return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red) x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
        return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red) y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.one);
        var rhs = y2.redMul(this.d).redAdd(this.one);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
            if (odd) throw new Error("invalid point"); else return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
        if (x.isOdd() !== odd) x = x.redNeg();
        return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity()) return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
            this.x = this.curve.zero;
            this.y = this.curve.one;
            this.z = this.curve.one;
            this.t = this.curve.zero;
            this.zOne = true;
        } else {
            this.x = new BN(x, 16);
            this.y = new BN(y, 16);
            this.z = z ? new BN(z, 16) : this.curve.one;
            this.t = t && new BN(t, 16);
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
            this.zOne = this.z === this.curve.one;
            if (this.curve.extended && !this.t) {
                this.t = this.x.redMul(this.y);
                if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
            }
        }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
    };
    Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        if (this.curve.twisted) {
            var e = this.curve._mulA(c);
            var f = e.redAdd(d);
            if (this.zOne) {
                nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                ny = f.redMul(e.redSub(d));
                nz = f.redSqr().redSub(f).redSub(f);
            } else {
                var h = this.z.redSqr();
                var j = f.redSub(h).redISub(h);
                nx = b.redSub(c).redISub(d).redMul(j);
                ny = f.redMul(e.redSub(d));
                nz = f.redMul(j);
            }
        } else {
            var e = c.redAdd(d);
            var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
            var j = e.redSub(h).redSub(h);
            nx = this.curve._mulC(b.redISub(e)).redMul(j);
            ny = this.curve._mulC(e).redMul(c.redISub(d));
            nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
        if (this.isInfinity()) return this;
        if (this.curve.extended) return this._extDbl(); else return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
            ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
            nz = f.redMul(g);
        } else {
            ny = a.redMul(g).redMul(d.redSub(c));
            nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
        if (this.isInfinity()) return p;
        if (p.isInfinity()) return this;
        if (this.curve.extended) return this._extAdd(p); else return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k); else return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
    };
    Point.prototype.normalize = function normalize() {
        if (this.zOne) return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t) this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
    };
    Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0) return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (;;) {
            xc.iadd(this.curve.n);
            if (xc.cmp(this.curve.p) >= 0) return false;
            rx.redIAdd(t);
            if (this.x.cmp(rx) === 0) return true;
        }
        return false;
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = __webpack_require__(63);
    var BN = __webpack_require__(9);
    var inherits = __webpack_require__(3);
    var Base = curve.base;
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
            this.x = this.curve.one;
            this.z = this.curve.zero;
        } else {
            this.x = new BN(x, 16);
            this.z = new BN(z, 16);
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {};
    Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
            if (bits[i] === 0) {
                a = a.diffAdd(b, c);
                b = b.dbl();
            } else {
                b = a.diffAdd(b, c);
                a = a.dbl();
            }
        }
        return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
    };
    Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var curve = __webpack_require__(63);
    var elliptic = __webpack_require__(14);
    var BN = __webpack_require__(9);
    var inherits = __webpack_require__(3);
    var Base = curve.base;
    var assert = elliptic.utils.assert;
    function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
        var beta;
        var lambda;
        if (conf.beta) {
            beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
            var betas = this._getEndoRoots(this.p);
            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
            beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
            lambda = new BN(conf.lambda, 16);
        } else {
            var lambdas = this._getEndoRoots(this.n);
            if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                lambda = lambdas[0];
            } else {
                lambda = lambdas[1];
                assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
            }
        }
        var basis;
        if (conf.basis) {
            basis = conf.basis.map(function(vec) {
                return {
                    a: new BN(vec.a, 16),
                    b: new BN(vec.b, 16)
                };
            });
        } else {
            basis = this._getEndoBasis(lambda);
        }
        return {
            beta,
            lambda,
            basis
        };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [ l1, l2 ];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
            var q = v.div(u);
            r = v.sub(q.mul(u));
            x = x2.sub(q.mul(x1));
            var y = y2.sub(q.mul(y1));
            if (!a1 && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
            } else if (a1 && ++i === 2) {
                break;
            }
            prevR = r;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
            y2 = y1;
            y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
            a2 = a0;
            b2 = b0;
        }
        if (a1.negative) {
            a1 = a1.neg();
            b1 = b1.neg();
        }
        if (a2.negative) {
            a2 = a2.neg();
            b2 = b2.neg();
        }
        return [ {
            a: a1,
            b: b1
        }, {
            a: a2,
            b: b2
        } ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return {
            k1,
            k2
        };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red) x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
        return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
        if (point.inf) return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
            var split = this._endoSplit(coeffs[i]);
            var p = points[i];
            var beta = p._getBeta();
            if (split.k1.negative) {
                split.k1.ineg();
                p = p.neg(true);
            }
            if (split.k2.negative) {
                split.k2.ineg();
                beta = beta.neg(true);
            }
            npoints[i * 2] = p;
            npoints[i * 2 + 1] = beta;
            ncoeffs[i * 2] = split.k1;
            ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
            npoints[j] = null;
            ncoeffs[j] = null;
        }
        return res;
    };
    function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
            this.x = null;
            this.y = null;
            this.inf = true;
        } else {
            this.x = new BN(x, 16);
            this.y = new BN(y, 16);
            if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
            }
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            this.inf = false;
        }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo) return;
        var pre = this.precomputed;
        if (pre && pre.beta) return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
            var curve = this.curve;
            var endoMul = function(p) {
                return curve.point(p.x.redMul(curve.endo.beta), p.y);
            };
            pre.beta = beta;
            beta.precomputed = {
                beta: null,
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(endoMul)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(endoMul)
                }
            };
        }
        return beta;
    };
    Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed) return [ this.x, this.y ];
        return [ this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        } ];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string") obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2]) return res;
        function obj2point(obj) {
            return curve.point(obj[0], obj[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
            beta: null,
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: [ res ].concat(pre.doubles.points.map(obj2point))
            },
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: [ res ].concat(pre.naf.points.map(obj2point))
            }
        };
        return res;
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
    };
    Point.prototype.add = function add(p) {
        if (this.inf) return p;
        if (p.inf) return this;
        if (this.eq(p)) return this.dbl();
        if (this.neg().eq(p)) return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
        if (this.inf) return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
        return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
        return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k); else if (this.curve.endo) return this.curve._endoWnafMulAdd([ this ], [ k ]); else return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [ this, p2 ];
        var coeffs = [ k1, k2 ];
        if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs); else return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [ this, p2 ];
        var coeffs = [ k1, k2 ];
        if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true); else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
        if (this.inf) return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
            var pre = this.precomputed;
            var negate = function(p) {
                return p.neg();
            };
            res.precomputed = {
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(negate)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(negate)
                }
            };
        }
        return res;
    };
    Point.prototype.toJ = function toJ() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
    };
    function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
            this.x = this.curve.one;
            this.y = this.curve.one;
            this.z = new BN(0);
        } else {
            this.x = new BN(x, 16);
            this.y = new BN(y, 16);
            this.z = new BN(z, 16);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
        if (this.isInfinity()) return p;
        if (p.isInfinity()) return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null); else return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity()) return p.toJ();
        if (p.isInfinity()) return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null); else return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0) return this;
        if (this.isInfinity()) return this;
        if (!pow) return this.dbl();
        if (this.curve.zeroA || this.curve.threeA) {
            var r = this;
            for (var i = 0; i < pow; i++) r = r.dbl();
            return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (var i = 0; i < pow; i++) {
            var jx2 = jx.redSqr();
            var jyd2 = jyd.redSqr();
            var jyd4 = jyd2.redSqr();
            var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
            var t1 = jx.redMul(jyd2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);
            var dny = c.redMul(t2);
            dny = dny.redIAdd(dny).redISub(jyd4);
            var nz = jyd.redMul(jz);
            if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
            jx = nx;
            jz = nz;
            jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity()) return this;
        if (this.curve.zeroA) return this._zeroDbl(); else if (this.curve.threeA) return this._threeDbl(); else return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var yyyy = yy.redSqr();
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            var m = xx.redAdd(xx).redIAdd(xx);
            var t = m.redSqr().redISub(s).redISub(s);
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            nx = t;
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            nz = this.y.redAdd(this.y);
        } else {
            var a = this.x.redSqr();
            var b = this.y.redSqr();
            var c = b.redSqr();
            var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
            d = d.redIAdd(d);
            var e = a.redAdd(a).redIAdd(a);
            var f = e.redSqr();
            var c8 = c.redIAdd(c);
            c8 = c8.redIAdd(c8);
            c8 = c8.redIAdd(c8);
            nx = f.redISub(d).redISub(d);
            ny = e.redMul(d.redISub(nx)).redISub(c8);
            nz = this.y.redMul(this.z);
            nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var yyyy = yy.redSqr();
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
            var t = m.redSqr().redISub(s).redISub(s);
            nx = t;
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            nz = this.y.redAdd(this.y);
        } else {
            var delta = this.z.redSqr();
            var gamma = this.y.redSqr();
            var beta = this.x.redMul(gamma);
            var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
            alpha = alpha.redAdd(alpha).redIAdd(alpha);
            var beta4 = beta.redIAdd(beta);
            beta4 = beta4.redIAdd(beta4);
            var beta8 = beta4.redAdd(beta4);
            nx = alpha.redSqr().redISub(beta8);
            nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
            var ggamma8 = gamma.redSqr();
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine") return this.eq(p.toJ());
        if (this === p) return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0) return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (;;) {
            xc.iadd(this.curve.n);
            if (xc.cmp(this.curve.p) >= 0) return false;
            rx.redIAdd(t);
            if (this.x.cmp(rx) === 0) return true;
        }
        return false;
    };
    JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var BN = __webpack_require__(9);
    var elliptic = __webpack_require__(14);
    var utils = elliptic.utils;
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
            this.redN = null;
        } else {
            this._maxwellTrick = true;
            this.redN = this.n.toRed(this.red);
        }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        for (var j = 0; j < naf.length; j += doubles.step) {
            var nafW = 0;
            for (var k = j + doubles.step - 1; k >= j; k--) nafW = (nafW << 1) + naf[k];
            repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
            for (var j = 0; j < repr.length; j++) {
                var nafW = repr[j];
                if (nafW === i) b = b.mixedAdd(doubles.points[j]); else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
            }
            a = a.add(b);
        }
        return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
            for (var k = 0; i >= 0 && naf[i] === 0; i--) k++;
            if (i >= 0) k++;
            acc = acc.dblp(k);
            if (i < 0) break;
            var z = naf[i];
            assert(z !== 0);
            if (p.type === "affine") {
                if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]); else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
            } else {
                if (z > 0) acc = acc.add(wnd[z - 1 >> 1]); else acc = acc.add(wnd[-z - 1 >> 1].neg());
            }
        }
        return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        for (var i = 0; i < len; i++) {
            var p = points[i];
            var nafPoints = p._getNAFPoints(defW);
            wndWidth[i] = nafPoints.wnd;
            wnd[i] = nafPoints.points;
        }
        for (var i = len - 1; i >= 1; i -= 2) {
            var a = i - 1;
            var b = i;
            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = getNAF(coeffs[a], wndWidth[a]);
                naf[b] = getNAF(coeffs[b], wndWidth[b]);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
            }
            var comb = [ points[a], null, null, points[b] ];
            if (points[a].y.cmp(points[b].y) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
            } else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            }
            var index = [ -3, -1, -5, -7, 0, 7, 5, 1, 3 ];
            var jsf = getJSF(coeffs[a], coeffs[b]);
            max = Math.max(jsf[0].length, max);
            naf[a] = new Array(max);
            naf[b] = new Array(max);
            for (var j = 0; j < max; j++) {
                var ja = jsf[0][j] | 0;
                var jb = jsf[1][j] | 0;
                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
            }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (var i = max; i >= 0; i--) {
            var k = 0;
            while (i >= 0) {
                var zero = true;
                for (var j = 0; j < len; j++) {
                    tmp[j] = naf[j][i] | 0;
                    if (tmp[j] !== 0) zero = false;
                }
                if (!zero) break;
                k++;
                i--;
            }
            if (i >= 0) k++;
            acc = acc.dblp(k);
            if (i < 0) break;
            for (var j = 0; j < len; j++) {
                var z = tmp[j];
                var p;
                if (z === 0) continue; else if (z > 0) p = wnd[j][z - 1 >> 1]; else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
                if (p.type === "affine") acc = acc.mixedAdd(p); else acc = acc.add(p);
            }
        }
        for (var i = 0; i < len; i++) wnd[i] = null;
        if (jacobianResult) return acc; else return acc.toP();
    };
    function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
            if (bytes[0] === 6) assert(bytes[bytes.length - 1] % 2 === 0); else if (bytes[0] === 7) assert(bytes[bytes.length - 1] % 2 === 1);
            var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
            return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
            return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact) return [ this.getY().isEven() ? 2 : 3 ].concat(x);
        return [ 4 ].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed) return this;
        var precomputed = {
            doubles: null,
            naf: null,
            beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed) return false;
        var doubles = this.precomputed.doubles;
        if (!doubles) return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        var doubles = [ this ];
        var acc = this;
        for (var i = 0; i < power; i += step) {
            for (var j = 0; j < step; j++) acc = acc.dbl();
            doubles.push(acc);
        }
        return {
            step,
            points: doubles
        };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        var res = [ this ];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
        return {
            wnd,
            points: res
        };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
        return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++) r = r.dbl();
        return r;
    };
}, function(module, exports) {}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = exports;
    var BN = __webpack_require__(9);
    var minAssert = __webpack_require__(15);
    var minUtils = __webpack_require__(159);
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w) {
        var naf = [];
        var ws = 1 << w + 1;
        var k = num.clone();
        while (k.cmpn(1) >= 0) {
            var z;
            if (k.isOdd()) {
                var mod = k.andln(ws - 1);
                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod; else z = mod;
                k.isubn(z);
            } else {
                z = 0;
            }
            naf.push(z);
            var shift = k.cmpn(0) !== 0 && k.andln(ws - 1) === 0 ? w + 1 : 1;
            for (var i = 1; i < shift; i++) naf.push(0);
            k.iushrn(shift);
        }
        return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
        var jsf = [ [], [] ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
            var m14 = k1.andln(3) + d1 & 3;
            var m24 = k2.andln(3) + d2 & 3;
            if (m14 === 3) m14 = -1;
            if (m24 === 3) m24 = -1;
            var u1;
            if ((m14 & 1) === 0) {
                u1 = 0;
            } else {
                var m8 = k1.andln(7) + d1 & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14; else u1 = m14;
            }
            jsf[0].push(u1);
            var u2;
            if ((m24 & 1) === 0) {
                u2 = 0;
            } else {
                var m8 = k2.andln(7) + d2 & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24; else u2 = m24;
            }
            jsf[1].push(u2);
            if (2 * d1 === u1 + 1) d1 = 1 - d1;
            if (2 * d2 === u2 + 1) d2 = 1 - d2;
            k1.iushrn(1);
            k2.iushrn(1);
        }
        return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty() {
            return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
        };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
}, function(module) {
    module.exports = {
        _from: "elliptic@^6.0.0",
        _id: "elliptic@6.4.0",
        _inBundle: false,
        _integrity: "sha1-ysmvh2LIWDYYcAPI3+GT5eLq5d8=",
        _location: "/elliptic",
        _phantomChildren: {},
        _requested: {
            type: "range",
            registry: true,
            raw: "elliptic@^6.0.0",
            name: "elliptic",
            escapedName: "elliptic",
            rawSpec: "^6.0.0",
            saveSpec: null,
            fetchSpec: "^6.0.0"
        },
        _requiredBy: [ "/browserify-sign", "/create-ecdh" ],
        _resolved: "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz",
        _shasum: "cac9af8762c85836187003c8dfe193e5e2eae5df",
        _spec: "elliptic@^6.0.0",
        _where: "/Users/samuelhkim/Dropbox/school/spring2018/cs359b/India-HouseChain/node_modules/browserify-sign",
        author: {
            name: "Fedor Indutny",
            email: "fedor@indutny.com"
        },
        bugs: {
            url: "https://github.com/indutny/elliptic/issues"
        },
        bundleDependencies: false,
        dependencies: {
            "bn.js": "^4.4.0",
            brorand: "^1.0.1",
            "hash.js": "^1.0.0",
            "hmac-drbg": "^1.0.0",
            inherits: "^2.0.1",
            "minimalistic-assert": "^1.0.0",
            "minimalistic-crypto-utils": "^1.0.0"
        },
        deprecated: false,
        description: "EC cryptography",
        devDependencies: {
            brfs: "^1.4.3",
            coveralls: "^2.11.3",
            grunt: "^0.4.5",
            "grunt-browserify": "^5.0.0",
            "grunt-cli": "^1.2.0",
            "grunt-contrib-connect": "^1.0.0",
            "grunt-contrib-copy": "^1.0.0",
            "grunt-contrib-uglify": "^1.0.1",
            "grunt-mocha-istanbul": "^3.0.1",
            "grunt-saucelabs": "^8.6.2",
            istanbul: "^0.4.2",
            jscs: "^2.9.0",
            jshint: "^2.6.0",
            mocha: "^2.1.0"
        },
        files: [ "lib" ],
        homepage: "https://github.com/indutny/elliptic",
        keywords: [ "EC", "Elliptic", "curve", "Cryptography" ],
        license: "MIT",
        main: "lib/elliptic.js",
        name: "elliptic",
        repository: {
            type: "git",
            url: "git+ssh://git@github.com/indutny/elliptic.git"
        },
        scripts: {
            jscs: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
            jshint: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
            lint: "npm run jscs && npm run jshint",
            test: "npm run lint && npm run unit",
            unit: "istanbul test _mocha --reporter=spec test/index.js",
            version: "grunt dist && git add dist/"
        },
        version: "6.4.0"
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.SECP256K1Client = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _elliptic = __webpack_require__(14);
        var _crypto = __webpack_require__(411);
        var _keyEncoder = __webpack_require__(352);
        var _keyEncoder2 = _interopRequireDefault(_keyEncoder);
        var _validator = __webpack_require__(326);
        var _ecdsaSigFormatter = __webpack_require__(277);
        var _errors = __webpack_require__(56);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        var SECP256K1Client = exports.SECP256K1Client = function() {
            function SECP256K1Client() {
                _classCallCheck(this, SECP256K1Client);
            }
            _createClass(SECP256K1Client, null, [ {
                key: "createHash",
                value: function createHash(signingInput) {
                    return (0, _crypto.createHash)("sha256").update(signingInput).digest();
                }
            }, {
                key: "loadPrivateKey",
                value: function loadPrivateKey(rawPrivateKey) {
                    if (rawPrivateKey.length === 66) {
                        rawPrivateKey = rawPrivateKey.slice(0, 64);
                    }
                    return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);
                }
            }, {
                key: "loadPublicKey",
                value: function loadPublicKey(rawPublicKey) {
                    return SECP256K1Client.ec.keyFromPublic(rawPublicKey, "hex");
                }
            }, {
                key: "encodePublicKey",
                value: function encodePublicKey(publicKey, originalFormat, destinationFormat) {
                    return SECP256K1Client.keyEncoder.encodePublic(publicKey, originalFormat, destinationFormat);
                }
            }, {
                key: "derivePublicKey",
                value: function derivePublicKey(privateKey, compressed) {
                    if (typeof privateKey !== "string") {
                        throw Error("private key must be a string");
                    }
                    if (!(0, _validator.isHexadecimal)(privateKey)) {
                        throw Error("private key must be a hex string");
                    }
                    if (privateKey.length == 66) {
                        privateKey = privateKey.slice(0, 64);
                    } else if (privateKey.length <= 64) {} else {
                        throw Error("private key must be 66 characters or less");
                    }
                    if (compressed === undefined) {
                        compressed = true;
                    }
                    var keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);
                    return keypair.getPublic(compressed, "hex");
                }
            }, {
                key: "signHash",
                value: function signHash(signingInputHash, rawPrivateKey) {
                    var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "jose";
                    if (!(signingInputHash && rawPrivateKey)) {
                        throw new _errors.MissingParametersError("a signing input hash and private key are all required");
                    }
                    var privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey);
                    var signatureObject = privateKeyObject.sign(signingInputHash);
                    var derSignature = new Buffer(signatureObject.toDER());
                    if (format === "der") {
                        return derSignature.toString("hex");
                    } else if (format === "jose") {
                        return (0, _ecdsaSigFormatter.derToJose)(derSignature, "ES256");
                    } else {
                        throw Error("Invalid signature format");
                    }
                }
            }, {
                key: "loadSignature",
                value: function loadSignature(joseSignature) {
                    return (0, _ecdsaSigFormatter.joseToDer)(joseSignature, "ES256");
                }
            }, {
                key: "verifyHash",
                value: function verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {
                    if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {
                        throw new _errors.MissingParametersError("a signing input hash, der signature, and public key are all required");
                    }
                    var publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey);
                    return publicKeyObject.verify(signingInputHash, derSignatureBuffer);
                }
            } ]);
            return SECP256K1Client;
        }();
        SECP256K1Client.algorithmName = "ES256K";
        SECP256K1Client.ec = new _elliptic.ec("secp256k1");
        SECP256K1Client.keyEncoder = new _keyEncoder2.default({
            curveParameters: [ 1, 3, 132, 0, 10 ],
            privatePEMOptions: {
                label: "EC PRIVATE KEY"
            },
            publicPEMOptions: {
                label: "PUBLIC KEY"
            },
            curve: SECP256K1Client.ec
        });
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        function padString(input) {
            var segmentLength = 4;
            var stringLength = input.length;
            var diff = stringLength % segmentLength;
            if (!diff) {
                return input;
            }
            var position = stringLength;
            var padLength = segmentLength - diff;
            var paddedStringLength = stringLength + padLength;
            var buffer = new Buffer(paddedStringLength);
            buffer.write(input);
            while (padLength--) {
                buffer.write("=", position++);
            }
            return buffer.toString();
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = padString;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(Buffer) {
        var pad_string_1 = __webpack_require__(436);
        function encode(input, encoding) {
            if (encoding === void 0) {
                encoding = "utf8";
            }
            if (Buffer.isBuffer(input)) {
                return fromBase64(input.toString("base64"));
            }
            return fromBase64(new Buffer(input, encoding).toString("base64"));
        }
        function decode(base64url, encoding) {
            if (encoding === void 0) {
                encoding = "utf8";
            }
            return new Buffer(toBase64(base64url), "base64").toString(encoding);
        }
        function toBase64(base64url) {
            base64url = base64url.toString();
            return pad_string_1.default(base64url).replace(/\-/g, "+").replace(/_/g, "/");
        }
        function fromBase64(base64) {
            return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function toBuffer(base64url) {
            return new Buffer(toBase64(base64url), "base64");
        }
        var base64url = encode;
        base64url.encode = encode;
        base64url.decode = decode;
        base64url.toBase64 = toBase64;
        base64url.fromBase64 = fromBase64;
        base64url.toBuffer = toBuffer;
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = base64url;
    }).call(this, __webpack_require__(4).Buffer);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.TokenSigner = undefined;
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    exports.createUnsecuredToken = createUnsecuredToken;
    var _base64url = __webpack_require__(64);
    var _base64url2 = _interopRequireDefault(_base64url);
    var _cryptoClients = __webpack_require__(85);
    var _decode = __webpack_require__(69);
    var _decode2 = _interopRequireDefault(_decode);
    var _errors = __webpack_require__(56);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function createSigningInput(payload, header) {
        var tokenParts = [];
        var encodedHeader = _base64url2.default.encode(JSON.stringify(header));
        tokenParts.push(encodedHeader);
        var encodedPayload = _base64url2.default.encode(JSON.stringify(payload));
        tokenParts.push(encodedPayload);
        var signingInput = tokenParts.join(".");
        return signingInput;
    }
    function createUnsecuredToken(payload) {
        var header = {
            typ: "JWT",
            alg: "none"
        };
        return createSigningInput(payload, header) + ".";
    }
    var TokenSigner = exports.TokenSigner = function() {
        function TokenSigner(signingAlgorithm, rawPrivateKey) {
            _classCallCheck(this, TokenSigner);
            if (!(signingAlgorithm && rawPrivateKey)) {
                throw new _errors.MissingParametersError("a signing algorithm and private key are required");
            }
            if (typeof signingAlgorithm !== "string") {
                throw "signing algorithm parameter must be a string";
            }
            signingAlgorithm = signingAlgorithm.toUpperCase();
            if (!_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm)) {
                throw "invalid signing algorithm";
            }
            this.tokenType = "JWT";
            this.cryptoClient = _cryptoClients.cryptoClients[signingAlgorithm];
            this.rawPrivateKey = rawPrivateKey;
        }
        _createClass(TokenSigner, [ {
            key: "header",
            value: function header() {
                return {
                    typ: this.tokenType,
                    alg: this.cryptoClient.algorithmName
                };
            }
        }, {
            key: "sign",
            value: function sign(payload) {
                var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var signingInput = createSigningInput(payload, this.header());
                var signingInputHash = this.cryptoClient.createHash(signingInput);
                var signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);
                if (expanded) {
                    return {
                        header: [ _base64url2.default.encode(JSON.stringify(this.header())) ],
                        payload: JSON.stringify(payload),
                        signature: [ signature ]
                    };
                } else {
                    return [ signingInput, signature ].join(".");
                }
            }
        } ]);
        return TokenSigner;
    }();
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _JWT = __webpack_require__(160);
    var _jsontokens = __webpack_require__(86);
    var _uportLite = __webpack_require__(274);
    var _uportLite2 = _interopRequireDefault(_uportLite);
    var _nets = __webpack_require__(166);
    var _nets2 = _interopRequireDefault(_nets);
    var _tweetnacl = __webpack_require__(272);
    var _tweetnacl2 = _interopRequireDefault(_tweetnacl);
    var _tweetnaclUtil = __webpack_require__(270);
    var _tweetnaclUtil2 = _interopRequireDefault(_tweetnaclUtil);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Credentials = function() {
        function Credentials() {
            var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck(this, Credentials);
            this.settings = settings;
            this.settings.networks = settings.networks ? configNetworks(settings.networks) : {};
            if (!this.settings.registry) {
                var registry = (0, _uportLite2.default)({
                    networks: this.settings.networks
                });
                this.settings.registry = function(address) {
                    return new Promise(function(resolve, reject) {
                        registry(address, function(error, profile) {
                            if (error) return reject(error);
                            resolve(profile);
                        });
                    });
                };
            }
        }
        _createClass(Credentials, [ {
            key: "createRequest",
            value: function createRequest() {
                var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var payload = {};
                if (params.requested) {
                    payload.requested = params.requested;
                }
                if (params.verified) {
                    payload.verified = params.verified;
                }
                if (params.notifications) {
                    payload.permissions = [ "notifications" ];
                }
                if (params.callbackUrl) {
                    payload.callback = params.callbackUrl;
                }
                if (params.network_id) {
                    payload.net = params.network_id;
                }
                if (params.accountType && [ "general", "segregated", "keypair", "devicekey", "none" ].indexOf(params.accountType) >= 0) {
                    payload.act = params.accountType;
                }
                if (params.exp) {
                    payload.exp = params.exp;
                } else {
                    payload.exp = Math.floor(Date.now() / 1e3) + 600;
                }
                return (0, _JWT.createJWT)(this.settings, _extends({}, payload, {
                    type: "shareReq"
                }));
            }
        }, {
            key: "receive",
            value: function receive(token) {
                var _this = this;
                var callbackUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                return (0, _JWT.verifyJWT)(this.settings, token, callbackUrl).then(function(_ref) {
                    var payload = _ref.payload, profile = _ref.profile;
                    function processPayload(settings) {
                        var credentials = _extends({}, profile, payload.own || {}, payload.capabilities && payload.capabilities.length === 1 ? {
                            pushToken: payload.capabilities[0]
                        } : {}, {
                            address: payload.iss
                        });
                        if (payload.nad) {
                            credentials.networkAddress = payload.nad;
                        }
                        if (payload.dad) {
                            credentials.deviceKey = payload.dad;
                        }
                        if (payload.verified) {
                            return Promise.all(payload.verified.map(function(token) {
                                return (0, _JWT.verifyJWT)(settings, token);
                            })).then(function(verified) {
                                return _extends({}, credentials, {
                                    verified: verified.map(function(v) {
                                        return _extends({}, v.payload, {
                                            jwt: v.jwt
                                        });
                                    })
                                });
                            });
                        } else {
                            return credentials;
                        }
                    }
                    if (_this.settings.signer) {
                        if (payload.req) {
                            return (0, _JWT.verifyJWT)(_this.settings, payload.req).then(function(challenge) {
                                if (challenge.payload.iss === _this.settings.address && challenge.payload.type === "shareReq") {
                                    return processPayload(_this.settings);
                                }
                            });
                        } else {
                            throw new Error("Challenge was not included in response");
                        }
                    } else {
                        return processPayload(_this.settings);
                    }
                });
            }
        }, {
            key: "push",
            value: function push(token, pubEncKey, payload) {
                var PUTUTU_URL = "https://pututu.uport.space";
                return new Promise(function(resolve, reject) {
                    var endpoint = "/api/v2/sns";
                    if (!token) {
                        return reject(new Error("Missing push notification token"));
                    }
                    if (pubEncKey.url) {
                        console.error("WARNING: Calling push without a public encryption key is deprecated");
                        endpoint = "/api/v1/sns";
                        payload = pubEncKey;
                    } else {
                        if (!payload.url) {
                            return reject(new Error("Missing payload url for sending to users device"));
                        }
                        var plaintext = padMessage(JSON.stringify(payload));
                        var enc = encryptMessage(plaintext, pubEncKey);
                        payload = {
                            message: JSON.stringify(enc)
                        };
                    }
                    (0, _nets2.default)({
                        uri: PUTUTU_URL + endpoint,
                        json: payload,
                        method: "POST",
                        withCredentials: false,
                        headers: {
                            Authorization: "Bearer " + token
                        }
                    }, function(error, res, body) {
                        if (error) return reject(error);
                        if (res.statusCode === 200) {
                            resolve(body);
                        }
                        if (res.statusCode === 403) {
                            return reject(new Error("Error sending push notification to user: Invalid Token"));
                        }
                        reject(new Error("Error sending push notification to user: " + res.statusCode + " " + body.toString()));
                    });
                });
            }
        }, {
            key: "attest",
            value: function attest(_ref2) {
                var sub = _ref2.sub, claim = _ref2.claim, exp = _ref2.exp;
                return (0, _JWT.createJWT)(this.settings, {
                    sub,
                    claim,
                    exp
                });
            }
        }, {
            key: "lookup",
            value: function lookup(address) {
                return this.settings.registry(address);
            }
        } ]);
        return Credentials;
    }();
    var configNetworks = function configNetworks(nets) {
        Object.keys(nets).forEach(function(key) {
            var net = nets[key];
            if ((typeof net === "undefined" ? "undefined" : _typeof(net)) === "object") {
                [ "registry", "rpcUrl" ].forEach(function(key) {
                    if (!net.hasOwnProperty(key)) throw new Error("Malformed network config object, object must have '" + key + "' key specified.");
                });
            } else {
                throw new Error("Network configuration object required");
            }
        });
        return nets;
    };
    var padMessage = function padMessage(message) {
        var INTERVAL_LENGTH = 50;
        var padLength = INTERVAL_LENGTH - message.length % INTERVAL_LENGTH;
        return message + " ".repeat(padLength);
    };
    var encryptMessage = function encryptMessage(message, receiverKey) {
        var tmpKp = _tweetnacl2.default.box.keyPair();
        var decodedKey = _tweetnaclUtil2.default.decodeBase64(receiverKey);
        var decodedMsg = _tweetnaclUtil2.default.decodeUTF8(message);
        var nonce = _tweetnacl2.default.randomBytes(24);
        var ciphertext = _tweetnacl2.default.box(decodedMsg, nonce, decodedKey, tmpKp.secretKey);
        return {
            from: _tweetnaclUtil2.default.encodeBase64(tmpKp.publicKey),
            nonce: _tweetnaclUtil2.default.encodeBase64(nonce),
            ciphertext: _tweetnaclUtil2.default.encodeBase64(ciphertext)
        };
    };
    exports.default = Credentials;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = randomString;
    function randomString(length) {
        var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var result = "";
        for (var i = length; i > 0; --i) {
            result += chars[Math.floor(Math.random() * chars.length)];
        }
        return result;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Utils = __webpack_require__(162);
    var has = Object.prototype.hasOwnProperty;
    var defaults = {
        delimiter: "&",
        depth: 5,
        arrayLimit: 20,
        parameterLimit: 1e3,
        strictNullHandling: false,
        plainObjects: false,
        allowPrototypes: false,
        allowDots: false,
        decoder: Utils.decode
    };
    var parseValues = function parseValues(str, options) {
        var obj = {};
        var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
        for (var i = 0; i < parts.length; ++i) {
            var part = parts[i];
            var pos = part.indexOf("]=") === -1 ? part.indexOf("=") : part.indexOf("]=") + 1;
            var key, val;
            if (pos === -1) {
                key = options.decoder(part);
                val = options.strictNullHandling ? null : "";
            } else {
                key = options.decoder(part.slice(0, pos));
                val = options.decoder(part.slice(pos + 1));
            }
            if (has.call(obj, key)) {
                obj[key] = [].concat(obj[key]).concat(val);
            } else {
                obj[key] = val;
            }
        }
        return obj;
    };
    var parseObject = function parseObject(chain, val, options) {
        if (!chain.length) {
            return val;
        }
        var root = chain.shift();
        var obj;
        if (root === "[]") {
            obj = [];
            obj = obj.concat(parseObject(chain, val, options));
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
                obj = [];
                obj[index] = parseObject(chain, val, options);
            } else {
                obj[cleanRoot] = parseObject(chain, val, options);
            }
        }
        return obj;
    };
    var parseKeys = function parseKeys(givenKey, val, options) {
        if (!givenKey) {
            return;
        }
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;
        var segment = brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;
        var keys = [];
        if (parent) {
            if (!options.plainObjects && has.call(Object.prototype, parent)) {
                if (!options.allowPrototypes) {
                    return;
                }
            }
            keys.push(parent);
        }
        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
            i += 1;
            if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
                if (!options.allowPrototypes) {
                    return;
                }
            }
            keys.push(segment[1]);
        }
        if (segment) {
            keys.push("[" + key.slice(segment.index) + "]");
        }
        return parseObject(keys, val, options);
    };
    module.exports = function(str, opts) {
        var options = opts || {};
        if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== "function") {
            throw new TypeError("Decoder has to be a function.");
        }
        options.delimiter = typeof options.delimiter === "string" || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
        options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
        options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
        options.parseArrays = options.parseArrays !== false;
        options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
        options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
        options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
        options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
        options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
        options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
        if (str === "" || str === null || typeof str === "undefined") {
            return options.plainObjects ? Object.create(null) : {};
        }
        var tempObj = typeof str === "string" ? parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};
        var keys = Object.keys(tempObj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var newObj = parseKeys(key, tempObj[key], options);
            obj = Utils.merge(obj, newObj, options);
        }
        return Utils.compact(obj);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Utils = __webpack_require__(162);
    var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
            return prefix + "[]";
        },
        indices: function indices(prefix, key) {
            return prefix + "[" + key + "]";
        },
        repeat: function repeat(prefix) {
            return prefix;
        }
    };
    var defaults = {
        delimiter: "&",
        strictNullHandling: false,
        skipNulls: false,
        encode: true,
        encoder: Utils.encode
    };
    var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
        var obj = object;
        if (typeof filter === "function") {
            obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
            obj = obj.toISOString();
        } else if (obj === null) {
            if (strictNullHandling) {
                return encoder ? encoder(prefix) : prefix;
            }
            obj = "";
        }
        if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || Utils.isBuffer(obj)) {
            if (encoder) {
                return [ encoder(prefix) + "=" + encoder(obj) ];
            }
            return [ prefix + "=" + String(obj) ];
        }
        var values = [];
        if (typeof obj === "undefined") {
            return values;
        }
        var objKeys;
        if (Array.isArray(filter)) {
            objKeys = filter;
        } else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
        }
        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            if (skipNulls && obj[key] === null) {
                continue;
            }
            if (Array.isArray(obj)) {
                values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
            } else {
                values = values.concat(stringify(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
            }
        }
        return values;
    };
    module.exports = function(object, opts) {
        var obj = object;
        var options = opts || {};
        var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
        var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
        var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
        var encode = typeof options.encode === "boolean" ? options.encode : defaults.encode;
        var encoder = encode ? typeof options.encoder === "function" ? options.encoder : defaults.encoder : null;
        var sort = typeof options.sort === "function" ? options.sort : null;
        var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
        var objKeys;
        var filter;
        if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== "function") {
            throw new TypeError("Encoder has to be a function.");
        }
        if (typeof options.filter === "function") {
            filter = options.filter;
            obj = filter("", obj);
        } else if (Array.isArray(options.filter)) {
            objKeys = filter = options.filter;
        }
        var keys = [];
        if (typeof obj !== "object" || obj === null) {
            return "";
        }
        var arrayFormat;
        if (options.arrayFormat in arrayPrefixGenerators) {
            arrayFormat = options.arrayFormat;
        } else if ("indices" in options) {
            arrayFormat = options.indices ? "indices" : "repeat";
        } else {
            arrayFormat = "indices";
        }
        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        if (!objKeys) {
            objKeys = Object.keys(obj);
        }
        if (sort) {
            objKeys.sort(sort);
        }
        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            if (skipNulls && obj[key] === null) {
                continue;
            }
            keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
        }
        return keys.join(delimiter);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Stringify = __webpack_require__(442);
    var Parse = __webpack_require__(441);
    module.exports = {
        stringify: Stringify,
        parse: Parse
    };
}, function(module, exports) {
    module.exports = function() {
        throw new Error("define cannot be used indirect");
    };
}, function(module, exports) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    }
}, function(module, exports, __webpack_require__) {
    var isFunction = __webpack_require__(164);
    module.exports = forEach;
    var toString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function forEach(list, iterator, context) {
        if (!isFunction(iterator)) {
            throw new TypeError("iterator must be a function");
        }
        if (arguments.length < 3) {
            context = this;
        }
        if (toString.call(list) === "[object Array]") forEachArray(list, iterator, context); else if (typeof list === "string") forEachString(list, iterator, context); else forEachObject(list, iterator, context);
    }
    function forEachArray(array, iterator, context) {
        for (var i = 0, len = array.length; i < len; i++) {
            if (hasOwnProperty.call(array, i)) {
                iterator.call(context, array[i], i, array);
            }
        }
    }
    function forEachString(string, iterator, context) {
        for (var i = 0, len = string.length; i < len; i++) {
            iterator.call(context, string.charAt(i), i, string);
        }
    }
    function forEachObject(object, iterator, context) {
        for (var k in object) {
            if (hasOwnProperty.call(object, k)) {
                iterator.call(context, object[k], k, object);
            }
        }
    }
}, function(module, exports) {
    exports = module.exports = trim;
    function trim(str) {
        return str.replace(/^\s*|\s*$/g, "");
    }
    exports.left = function(str) {
        return str.replace(/^\s*/, "");
    };
    exports.right = function(str) {
        return str.replace(/\s*$/, "");
    };
}, function(module, exports, __webpack_require__) {
    var trim = __webpack_require__(447), forEach = __webpack_require__(446), isArray = function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
    };
    module.exports = function(headers) {
        if (!headers) return {};
        var result = {};
        forEach(trim(headers).split("\n"), function(row) {
            var index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
            if (typeof result[key] === "undefined") {
                result[key] = value;
            } else if (isArray(result[key])) {
                result[key].push(value);
            } else {
                result[key] = [ result[key], value ];
            }
        });
        return result;
    };
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var win;
        if (typeof window !== "undefined") {
            win = window;
        } else if (typeof global !== "undefined") {
            win = global;
        } else if (typeof self !== "undefined") {
            win = self;
        } else {
            win = {};
        }
        module.exports = win;
    }).call(this, __webpack_require__(12));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var window = __webpack_require__(449);
    var isFunction = __webpack_require__(164);
    var parseHeaders = __webpack_require__(448);
    var xtend = __webpack_require__(445);
    module.exports = createXHR;
    createXHR.XMLHttpRequest = window.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;
    forEachArray([ "get", "put", "post", "patch", "head", "delete" ], function(method) {
        createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
            options = initParams(uri, options, callback);
            options.method = method.toUpperCase();
            return _createXHR(options);
        };
    });
    function forEachArray(array, iterator) {
        for (var i = 0; i < array.length; i++) {
            iterator(array[i]);
        }
    }
    function isEmpty(obj) {
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) return false;
        }
        return true;
    }
    function initParams(uri, options, callback) {
        var params = uri;
        if (isFunction(options)) {
            callback = options;
            if (typeof uri === "string") {
                params = {
                    uri
                };
            }
        } else {
            params = xtend(options, {
                uri
            });
        }
        params.callback = callback;
        return params;
    }
    function createXHR(uri, options, callback) {
        options = initParams(uri, options, callback);
        return _createXHR(options);
    }
    function _createXHR(options) {
        if (typeof options.callback === "undefined") {
            throw new Error("callback argument missing");
        }
        var called = false;
        var callback = function cbOnce(err, response, body) {
            if (!called) {
                called = true;
                options.callback(err, response, body);
            }
        };
        function readystatechange() {
            if (xhr.readyState === 4) {
                setTimeout(loadFunc, 0);
            }
        }
        function getBody() {
            var body = undefined;
            if (xhr.response) {
                body = xhr.response;
            } else {
                body = xhr.responseText || getXml(xhr);
            }
            if (isJson) {
                try {
                    body = JSON.parse(body);
                } catch (e) {}
            }
            return body;
        }
        function errorFunc(evt) {
            clearTimeout(timeoutTimer);
            if (!(evt instanceof Error)) {
                evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
            }
            evt.statusCode = 0;
            return callback(evt, failureResponse);
        }
        function loadFunc() {
            if (aborted) return;
            var status;
            clearTimeout(timeoutTimer);
            if (options.useXDR && xhr.status === undefined) {
                status = 200;
            } else {
                status = xhr.status === 1223 ? 204 : xhr.status;
            }
            var response = failureResponse;
            var err = null;
            if (status !== 0) {
                response = {
                    body: getBody(),
                    statusCode: status,
                    method,
                    headers: {},
                    url: uri,
                    rawRequest: xhr
                };
                if (xhr.getAllResponseHeaders) {
                    response.headers = parseHeaders(xhr.getAllResponseHeaders());
                }
            } else {
                err = new Error("Internal XMLHttpRequest Error");
            }
            return callback(err, response, response.body);
        }
        var xhr = options.xhr || null;
        if (!xhr) {
            if (options.cors || options.useXDR) {
                xhr = new createXHR.XDomainRequest();
            } else {
                xhr = new createXHR.XMLHttpRequest();
            }
        }
        var key;
        var aborted;
        var uri = xhr.url = options.uri || options.url;
        var method = xhr.method = options.method || "GET";
        var body = options.body || options.data;
        var headers = xhr.headers = options.headers || {};
        var sync = !!options.sync;
        var isJson = false;
        var timeoutTimer;
        var failureResponse = {
            body: undefined,
            headers: {},
            statusCode: 0,
            method,
            url: uri,
            rawRequest: xhr
        };
        if ("json" in options && options.json !== false) {
            isJson = true;
            headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
            if (method !== "GET" && method !== "HEAD") {
                headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
                body = JSON.stringify(options.json === true ? body : options.json);
            }
        }
        xhr.onreadystatechange = readystatechange;
        xhr.onload = loadFunc;
        xhr.onerror = errorFunc;
        xhr.onprogress = function() {};
        xhr.onabort = function() {
            aborted = true;
        };
        xhr.ontimeout = errorFunc;
        xhr.open(method, uri, !sync, options.username, options.password);
        if (!sync) {
            xhr.withCredentials = !!options.withCredentials;
        }
        if (!sync && options.timeout > 0) {
            timeoutTimer = setTimeout(function() {
                if (aborted) return;
                aborted = true;
                xhr.abort("timeout");
                var e = new Error("XMLHttpRequest timeout");
                e.code = "ETIMEDOUT";
                errorFunc(e);
            }, options.timeout);
        }
        if (xhr.setRequestHeader) {
            for (key in headers) {
                if (headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
        } else if (options.headers && !isEmpty(options.headers)) {
            throw new Error("Headers cannot be set on an XDomainRequest object");
        }
        if ("responseType" in options) {
            xhr.responseType = options.responseType;
        }
        if ("beforeSend" in options && typeof options.beforeSend === "function") {
            options.beforeSend(xhr);
        }
        xhr.send(body || null);
        return xhr;
    }
    function getXml(xhr) {
        try {
            if (xhr.responseType === "document") {
                return xhr.responseXML;
            }
            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
            if (xhr.responseType === "" && !firefoxBugTakenEffect) {
                return xhr.responseXML;
            }
        } catch (e) {}
        return null;
    }
    function noop() {}
}, function(module, exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }
            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }
        for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
        var len = b64.length;
        if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [ validLen, placeHoldersLen ];
    }
    function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        for (var i = 0; i < len; i += 4) {
            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
            arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
        }
        return arr;
    }
    function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
            output.push(tripletToBase64(tmp));
        }
        return output.join("");
    }
    function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
            tmp = uint8[len - 1];
            parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _nets = __webpack_require__(166);
    var _nets2 = _interopRequireDefault(_nets);
    var _mobileDetect = __webpack_require__(163);
    var _mobileDetect2 = _interopRequireDefault(_mobileDetect);
    var _qs = __webpack_require__(443);
    var _qs2 = _interopRequireDefault(_qs);
    var _randomString = __webpack_require__(440);
    var _randomString2 = _interopRequireDefault(_randomString);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var CHASQUI_URL = "https://chasqui.uport.me/api/v1/topic/";
    function TopicFactory(isOnMobile) {
        var pollingInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2e3;
        var chasquiUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CHASQUI_URL;
        function waitForHashChange(topicName, cb) {
            window.onhashchange = function() {
                if (window.location.hash) {
                    var params = _qs2.default.parse(window.location.hash.slice(1));
                    if (params[topicName]) {
                        window.onhashchange = function() {};
                        window.location.hash = "";
                        cb(null, params[topicName]);
                    } else if (params.error) {
                        window.onhashchange = function() {};
                        window.location.hash = "";
                        cb(params.error);
                    }
                }
            };
        }
        function pollForResult(topicName, url, cb, cancelled) {
            var interval = setInterval(function() {
                (0, _nets2.default)({
                    uri: url,
                    json: true,
                    method: "GET",
                    withCredentials: false,
                    rejectUnauthorized: false
                }, function(err, res, body) {
                    if (err) return cb(err);
                    if (cancelled()) {
                        clearInterval(interval);
                        return cb(new Error("Request Cancelled"));
                    }
                    var data = body.message;
                    try {
                        if (data.error) {
                            clearInterval(interval);
                            return cb(data.error);
                        }
                    } catch (err) {
                        console.error(err.stack);
                        clearInterval(interval);
                        return cb(err);
                    }
                    if (data && data[topicName]) {
                        clearInterval(interval);
                        clearTopic(url);
                        return cb(null, data[topicName]);
                    }
                });
            }, pollingInterval);
        }
        function clearTopic(url) {
            (0, _nets2.default)({
                uri: url,
                method: "DELETE",
                withCredentials: false,
                rejectUnauthorized: false
            }, function(err) {
                if (err) {
                    throw err;
                }
            });
        }
        function newTopic(topicName) {
            var isCancelled = false;
            var url = void 0;
            if (isOnMobile) {
                var md = new _mobileDetect2.default(navigator.userAgent);
                if (md.userAgent() === "Chrome" && md.os() === "iOS") {
                    url = "googlechrome:" + window.location.href.substring(window.location.protocol.length);
                } else {
                    url = window.location.href;
                }
            } else {
                url = chasquiUrl + (0, _randomString2.default)(16);
            }
            var topic = new Promise(function(resolve, reject) {
                var cb = function cb(error, response) {
                    if (error) return reject(error);
                    resolve(response);
                };
                if (isOnMobile) {
                    waitForHashChange(topicName, cb);
                } else {
                    pollForResult(topicName, url, cb, function() {
                        return isCancelled;
                    });
                }
            });
            topic.url = url;
            topic.cancel = function() {
                isCancelled = true;
            };
            return topic;
        }
        return newTopic;
    }
    exports.default = TopicFactory;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _ConnectCore2 = __webpack_require__(167);
    var _ConnectCore3 = _interopRequireDefault(_ConnectCore2);
    var _web = __webpack_require__(261);
    var _web2 = _interopRequireDefault(_web);
    var _qrdisplay = __webpack_require__(101);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Connect = function(_ConnectCore) {
        _inherits(Connect, _ConnectCore);
        function Connect(appName) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, Connect);
            var _this = _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, appName, opts));
            _this.uriHandler = opts.uriHandler || _qrdisplay.openQr;
            _this.mobileUriHandler = opts.mobileUriHandler || mobileUriHandler;
            _this.closeUriHandler = opts.closeUriHandler || (_this.uriHandler === _qrdisplay.openQr ? _qrdisplay.closeQr : undefined);
            return _this;
        }
        _createClass(Connect, [ {
            key: "getWeb3",
            value: function getWeb3() {
                var provider = this.getProvider();
                var web3 = new _web2.default();
                web3.setProvider(provider);
                web3.eth.defaultAccount = "0xB42E70a3c6dd57003f4bFe7B06E370d21CDA8087";
                return web3;
            }
        } ]);
        return Connect;
    }(_ConnectCore3.default);
    function mobileUriHandler(uri) {
        window.location.assign(uri);
    }
    exports.default = Connect;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.MNID = exports.Credentials = exports.SimpleSigner = exports.QRUtil = exports.ConnectCore = exports.Connect = undefined;
    var _Connect = __webpack_require__(454);
    var _Connect2 = _interopRequireDefault(_Connect);
    var _ConnectCore = __webpack_require__(167);
    var _ConnectCore2 = _interopRequireDefault(_ConnectCore);
    var _qrdisplay = __webpack_require__(101);
    var _mnid = __webpack_require__(55);
    var _uport = __webpack_require__(161);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var QRUtil = {
        getQRDataURI: _qrdisplay.getQRDataURI,
        closeQr: _qrdisplay.closeQr,
        openQr: _qrdisplay.openQr
    };
    var MNID = {
        encode: _mnid.encode,
        decode: _mnid.decode,
        isMNID: _mnid.isMNID
    };
    exports.Connect = _Connect2.default;
    exports.ConnectCore = _ConnectCore2.default;
    exports.QRUtil = QRUtil;
    exports.SimpleSigner = _uport.SimpleSigner;
    exports.Credentials = _uport.Credentials;
    exports.MNID = MNID;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.uport = exports.web3 = undefined;
    var _uportConnect = __webpack_require__(455);
    var uport = new _uportConnect.Connect("India HouseChain", {
        clientId: "2oz6Ct7hfyoxbY3fbLpTjAJuFyaARCNYGkw",
        signer: (0, _uportConnect.SimpleSigner)("c2337070f23f579eb977ccbdfd6d4fc6e83e0d1dea402a8bcfa4cd91a73d4933")
    });
    var web3 = uport.getWeb3();
    exports.web3 = web3;
    exports.uport = uport;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _react = __webpack_require__(2);
    var _react2 = _interopRequireDefault(_react);
    var _reactRedux = __webpack_require__(47);
    var _redux = __webpack_require__(24);
    var _uportSetup = __webpack_require__(456);
    var _actions = __webpack_require__(87);
    var AppActions = _interopRequireWildcard(_actions);
    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Login = function(_Component) {
        _inherits(Login, _Component);
        function Login(props) {
            _classCallCheck(this, Login);
            var _this = _possibleConstructorReturn(this, (Login.__proto__ || Object.getPrototypeOf(Login)).call(this, props));
            _this.connectUport = _this.connectUport.bind(_this);
            _this.housePage = _this.housePage.bind(_this);
            console.log(props);
            return _this;
        }
        _createClass(Login, [ {
            key: "connectUport",
            value: function connectUport() {
                var _this2 = this;
                _uportSetup.uport.requestCredentials().then(function(credentials) {
                    console.log(credentials);
                    _this2.props.actions.connectUport(credentials);
                    _this2.housePage();
                });
            }
        }, {
            key: "housePage",
            value: function housePage() {
                this.props.history.push({
                    pathname: "/house",
                    state: this.props.location.state
                });
            }
        }, {
            key: "render",
            value: function render() {
                return _react2.default.createElement("div", null, _react2.default.createElement("h1", null, "Login to India HouseChain"), _react2.default.createElement("h4", null, "Scan the QR Code with your uPort mobile app"), _react2.default.createElement("button", {
                    onClick: this.connectUport
                }, "Connect with uPort"));
            }
        } ]);
        return Login;
    }(_react.Component);
    var mapStateToProps = function mapStateToProps(state, props) {
        return {
            uport: state.App.uport,
            userAccount: state.App.userAccount,
            contract: state.App.contract
        };
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            actions: (0, _redux.bindActionCreators)(AppActions, dispatch)
        };
    };
    exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Login);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _redux = __webpack_require__(24);
    var initialState = {};
    function App() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
        var payload = arguments[1];
        switch (payload.type) {
          case "CONNECT_UPORT":
            return _extends({}, state, {
                uport: payload.data
            });

          case "USER_ACCOUNT":
            return _extends({}, state, {
                userAccount: payload.text
            });

          case "CONTRACT":
            return _extends({}, state, {
                contract: payload.data
            });

          default:
            return state;
        }
    }
    var reducers = (0, _redux.combineReducers)({
        App
    });
    exports.default = reducers;
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = getStorage;
    function noop() {}
    var noopStorage = {
        getItem: noop,
        setItem: noop,
        removeItem: noop
    };
    function hasStorage(storageType) {
        if ((typeof self === "undefined" ? "undefined" : _typeof(self)) !== "object" || !(storageType in self)) {
            return false;
        }
        try {
            var storage = self[storageType];
            var testKey = "redux-persist " + storageType + " test";
            storage.setItem(testKey, "test");
            storage.getItem(testKey);
            storage.removeItem(testKey);
        } catch (e) {
            if (false) {}
            return false;
        }
        return true;
    }
    function getStorage(type) {
        var storageType = type + "Storage";
        if (hasStorage(storageType)) return self[storageType]; else {
            if (false) {}
            return noopStorage;
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    exports.default = createWebStorage;
    var _getStorage = __webpack_require__(459);
    var _getStorage2 = _interopRequireDefault(_getStorage);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function createWebStorage(type) {
        var storage = (0, _getStorage2.default)(type);
        return {
            getItem: function getItem(key) {
                return new Promise(function(resolve, reject) {
                    resolve(storage.getItem(key));
                });
            },
            setItem: function setItem(key, item) {
                return new Promise(function(resolve, reject) {
                    resolve(storage.setItem(key, item));
                });
            },
            removeItem: function removeItem(key) {
                return new Promise(function(resolve, reject) {
                    resolve(storage.removeItem(key));
                });
            }
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
    var _createWebStorage = __webpack_require__(460);
    var _createWebStorage2 = _interopRequireDefault(_createWebStorage);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    exports.default = (0, _createWebStorage2.default)("local");
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _redux = __webpack_require__(24);
    var _reduxPersist = __webpack_require__(95);
    var _storage = __webpack_require__(461);
    var _storage2 = _interopRequireDefault(_storage);
    var _reducers = __webpack_require__(458);
    var _reducers2 = _interopRequireDefault(_reducers);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var persistConfig = {
        key: "root",
        storage: _storage2.default
    };
    var reducer = (0, _reduxPersist.persistReducer)(persistConfig, _reducers2.default);
    exports.default = function() {
        var Store = (0, _redux.createStore)(reducer);
        var Persistor = (0, _reduxPersist.persistStore)(Store);
        return {
            Store,
            Persistor
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _react = __webpack_require__(2);
    var _react2 = _interopRequireDefault(_react);
    var _reactDom = __webpack_require__(171);
    var _reactDom2 = _interopRequireDefault(_reactDom);
    var _reactRouterDom = __webpack_require__(96);
    var _reactRedux = __webpack_require__(47);
    var _redux = __webpack_require__(24);
    var _actions = __webpack_require__(87);
    var AppActions = _interopRequireWildcard(_actions);
    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var App = function(_React$Component) {
        _inherits(App, _React$Component);
        function App(props) {
            _classCallCheck(this, App);
            var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));
            console.log(_this.props);
            if (typeof web3 == "undefined") throw "No web3 detected. Is Metamask/Mist being used?";
            web3 = new Web3(web3.currentProvider);
            console.log("Using web3 version: " + Web3.version);
            var contractDataPromise = $.getJSON("HouseChain.json");
            var networkIdPromise = web3.eth.net.getId();
            var accountsPromise = web3.eth.getAccounts();
            _this.refreshBalance = _this.refreshBalance.bind(_this);
            _this.setData = _this.setData.bind(_this);
            _this.state = {};
            Promise.all([ contractDataPromise, networkIdPromise, accountsPromise ]).then(function initApp(results) {
                var contractData = results[0];
                var networkId = results[1];
                var userAccount = results[2][0];
                if (!(networkId in contractData.networks)) {
                    console.log(contractData.networks);
                    throw new Error("Contract not found in selected Ethereum network on MetaMask.");
                }
                var contractAddress = contractData.networks[networkId].address;
                var contract = new web3.eth.Contract(contractData.abi, contractAddress);
                return {
                    contractData,
                    networkId,
                    userAccount,
                    contract
                };
            }).then(_this.setData).then(_this.refreshBalance).catch(console.error);
            return _this;
        }
        _createClass(App, [ {
            key: "setData",
            value: function setData(data) {
                this.props.actions.getUserAccount(data.userAccount);
                this.state = data;
            }
        }, {
            key: "refreshBalance",
            value: function refreshBalance() {
                console.log("The user account is " + this.state.userAccount);
                console.log(this.state.contract);
                this.state.contract.methods.balanceOf(this.state.userAccount).call().then(function(balance) {
                    $("#display").text(balance + " CDT");
                    $("#loader").hide();
                });
            }
        }, {
            key: "render",
            value: function render() {
                return _react2.default.createElement("div", {
                    className: "App"
                }, _react2.default.createElement("header", {
                    className: "App-header"
                }, _react2.default.createElement("h1", null, "Welcome to India HouseChain"), _react2.default.createElement("h2", {
                    id: "display"
                }), _react2.default.createElement("img", {
                    id: "loader",
                    src: "https://loading.io/spinners/pacman/lg.eat-bean-pie-loading-gif.gif"
                })), _react2.default.createElement("br", null), _react2.default.createElement("button", null, _react2.default.createElement(_reactRouterDom.Link, {
                    to: "/login"
                }, "Login")));
            }
        } ]);
        return App;
    }(_react2.default.Component);
    var mapStateToProps = function mapStateToProps(state, props) {
        return {};
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            actions: (0, _redux.bindActionCreators)(AppActions, dispatch)
        };
    };
    exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(App);
}, function(module, exports) {
    module.exports = function(css) {
        var location = typeof window !== "undefined" && window.location;
        if (!location) {
            throw new Error("fixUrls requires window.location");
        }
        if (!css || typeof css !== "string") {
            return css;
        }
        var baseUrl = location.protocol + "//" + location.host;
        var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
        var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
            var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function(o, $1) {
                return $1;
            }).replace(/^'(.*)'$/, function(o, $1) {
                return $1;
            });
            if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
                return fullMatch;
            }
            var newUrl;
            if (unquotedOrigUrl.indexOf("//") === 0) {
                newUrl = unquotedOrigUrl;
            } else if (unquotedOrigUrl.indexOf("/") === 0) {
                newUrl = baseUrl + unquotedOrigUrl;
            } else {
                newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, "");
            }
            return "url(" + JSON.stringify(newUrl) + ")";
        });
        return fixedCss;
    };
}, function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(169)(false);
    exports.push([ module.i, "body {\n  background-color:#F0F0F0;\n  padding: 2em;\n  font-family: 'Raleway','Source Sans Pro', 'Arial';\n}\n\n.container {\n  width: 50%;\n  margin: 0 auto;\n}\n\nlabel {\n  Display:block;\n  Margin-bottom:10px;\n}\n\ninput {\n  Padding:10px;\n  width: 50%;\n  margin-bottom: 1em;\n}\n\nbutton {\n  margin: 2em 0;\n  padding: 1em 4em;\n  Display:block;\n}\n\n#display {\n  padding:1em;\n  height: 1em;\n  background-color:#fff;\n  margin: 1em 0;\n  text-align: center;\n}\n\n#loader {\n  width: 100px;\n  display: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var content = __webpack_require__(465);
    if (typeof content === "string") content = [ [ module.i, content, "" ] ];
    var transform;
    var insertInto;
    var options = {
        hmr: true
    };
    options.transform = transform;
    options.insertInto = undefined;
    var update = __webpack_require__(168)(content, options);
    if (content.locals) module.exports = content.locals;
    if (false) {}
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, "PersistGate", function() {
        return PersistGate;
    });
    var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
    var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var PersistGate = function(_PureComponent) {
        _inherits(PersistGate, _PureComponent);
        function PersistGate() {
            var _ref;
            var _temp, _this, _ret;
            _classCallCheck(this, PersistGate);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = PersistGate.__proto__ || Object.getPrototypeOf(PersistGate)).call.apply(_ref, [ this ].concat(args))), 
            _this), _this.state = {
                bootstrapped: false
            }, _this.handlePersistorState = function() {
                var persistor = _this.props.persistor;
                var _persistor$getState = persistor.getState(), bootstrapped = _persistor$getState.bootstrapped;
                if (bootstrapped) {
                    if (_this.props.onBeforeLift) {
                        Promise.resolve(_this.props.onBeforeLift()).then(function() {
                            return _this.setState({
                                bootstrapped: true
                            });
                        }).catch(function() {
                            return _this.setState({
                                bootstrapped: true
                            });
                        });
                    } else {
                        _this.setState({
                            bootstrapped: true
                        });
                    }
                    _this._unsubscribe && _this._unsubscribe();
                }
            }, _temp), _possibleConstructorReturn(_this, _ret);
        }
        _createClass(PersistGate, [ {
            key: "componentDidMount",
            value: function componentDidMount() {
                this._unsubscribe = this.props.persistor.subscribe(this.handlePersistorState);
                this.handlePersistorState();
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._unsubscribe && this._unsubscribe();
            }
        }, {
            key: "render",
            value: function render() {
                if (false) {}
                if (typeof this.props.children === "function") {
                    return this.props.children(this.state.bootstrapped);
                }
                return this.state.bootstrapped ? this.props.children : this.props.loading;
            }
        } ]);
        return PersistGate;
    }(react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"]);
    PersistGate.defaultProps = {
        loading: null
    };
}, function(module, exports) {
    module.exports = function(originalModule) {
        if (!originalModule.webpackPolyfill) {
            var module = Object.create(originalModule);
            if (!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
                enumerable: true,
                get: function() {
                    return module.l;
                }
            });
            Object.defineProperty(module, "id", {
                enumerable: true,
                get: function() {
                    return module.i;
                }
            });
            Object.defineProperty(module, "exports", {
                enumerable: true
            });
            module.webpackPolyfill = 1;
        }
        return module;
    };
}, function(module, exports) {
    module.exports = Array.isArray || function(arr) {
        return Object.prototype.toString.call(arr) == "[object Array]";
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var emptyFunction = __webpack_require__(90);
    var invariant = __webpack_require__(91);
    var ReactPropTypesSecret = __webpack_require__(470);
    module.exports = function() {
        function shim(props, propName, componentName, location, propFullName, secret) {
            if (secret === ReactPropTypesSecret) {
                return;
            }
            invariant(false, "Calling PropTypes validators directly is not supported by the `prop-types` package. " + "Use PropTypes.checkPropTypes() to call them. " + "Read more at http://fb.me/use-check-prop-types");
        }
        shim.isRequired = shim;
        function getShim() {
            return shim;
        }
        var ReactPropTypes = {
            array: shim,
            bool: shim,
            func: shim,
            number: shim,
            object: shim,
            string: shim,
            symbol: shim,
            any: shim,
            arrayOf: getShim,
            element: shim,
            instanceOf: getShim,
            node: shim,
            objectOf: getShim,
            oneOf: getShim,
            oneOfType: getShim,
            shape: getShim,
            exact: getShim
        };
        ReactPropTypes.checkPropTypes = emptyFunction;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    function isNode(object) {
        var doc = object ? object.ownerDocument || object : document;
        var defaultView = doc.defaultView || window;
        return !!(object && (typeof defaultView.Node === "function" ? object instanceof defaultView.Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
    }
    module.exports = isNode;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var isNode = __webpack_require__(472);
    function isTextNode(object) {
        return isNode(object) && object.nodeType == 3;
    }
    module.exports = isTextNode;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var isTextNode = __webpack_require__(473);
    function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
            return false;
        } else if (outerNode === innerNode) {
            return true;
        } else if (isTextNode(outerNode)) {
            return false;
        } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
        } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
        } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        } else {
            return false;
        }
    }
    module.exports = containsNode;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function is(x, y) {
        if (x === y) {
            return x !== 0 || y !== 0 || 1 / x === 1 / y;
        } else {
            return x !== x && y !== y;
        }
    }
    function shallowEqual(objA, objB) {
        if (is(objA, objB)) {
            return true;
        }
        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
            return false;
        }
        for (var i = 0; i < keysA.length; i++) {
            if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
                return false;
            }
        }
        return true;
    }
    module.exports = shallowEqual;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function getActiveElement(doc) {
        doc = doc || (typeof document !== "undefined" ? document : undefined);
        if (typeof doc === "undefined") {
            return null;
        }
        try {
            return doc.activeElement || doc.body;
        } catch (e) {
            return doc.body;
        }
    }
    module.exports = getActiveElement;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    var ExecutionEnvironment = {
        canUseDOM,
        canUseWorkers: typeof Worker !== "undefined",
        canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen,
        isInWorker: !canUseDOM
    };
    module.exports = ExecutionEnvironment;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var ba = __webpack_require__(91), ea = __webpack_require__(2), m = __webpack_require__(477), A = __webpack_require__(173), C = __webpack_require__(90), fa = __webpack_require__(476), ha = __webpack_require__(475), ja = __webpack_require__(474), ka = __webpack_require__(172);
    function D(a) {
        for (var b = arguments.length - 1, c = "http://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 0; d < b; d++) c += "&args[]=" + encodeURIComponent(arguments[d + 1]);
        ba(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", c);
    }
    ea ? void 0 : D("227");
    function ma(a, b, c, d, e, f, h, g, k) {
        this._hasCaughtError = !1;
        this._caughtError = null;
        var v = Array.prototype.slice.call(arguments, 3);
        try {
            b.apply(c, v);
        } catch (l) {
            this._caughtError = l, this._hasCaughtError = !0;
        }
    }
    var E = {
        _caughtError: null,
        _hasCaughtError: !1,
        _rethrowError: null,
        _hasRethrowError: !1,
        invokeGuardedCallback: function(a, b, c, d, e, f, h, g, k) {
            ma.apply(E, arguments);
        },
        invokeGuardedCallbackAndCatchFirstError: function(a, b, c, d, e, f, h, g, k) {
            E.invokeGuardedCallback.apply(this, arguments);
            if (E.hasCaughtError()) {
                var v = E.clearCaughtError();
                E._hasRethrowError || (E._hasRethrowError = !0, E._rethrowError = v);
            }
        },
        rethrowCaughtError: function() {
            return na.apply(E, arguments);
        },
        hasCaughtError: function() {
            return E._hasCaughtError;
        },
        clearCaughtError: function() {
            if (E._hasCaughtError) {
                var a = E._caughtError;
                E._caughtError = null;
                E._hasCaughtError = !1;
                return a;
            }
            D("198");
        }
    };
    function na() {
        if (E._hasRethrowError) {
            var a = E._rethrowError;
            E._rethrowError = null;
            E._hasRethrowError = !1;
            throw a;
        }
    }
    var oa = null, pa = {};
    function qa() {
        if (oa) for (var a in pa) {
            var b = pa[a], c = oa.indexOf(a);
            -1 < c ? void 0 : D("96", a);
            if (!ra[c]) {
                b.extractEvents ? void 0 : D("97", a);
                ra[c] = b;
                c = b.eventTypes;
                for (var d in c) {
                    var e = void 0;
                    var f = c[d], h = b, g = d;
                    sa.hasOwnProperty(g) ? D("99", g) : void 0;
                    sa[g] = f;
                    var k = f.phasedRegistrationNames;
                    if (k) {
                        for (e in k) k.hasOwnProperty(e) && ta(k[e], h, g);
                        e = !0;
                    } else f.registrationName ? (ta(f.registrationName, h, g), e = !0) : e = !1;
                    e ? void 0 : D("98", d, a);
                }
            }
        }
    }
    function ta(a, b, c) {
        ua[a] ? D("100", a) : void 0;
        ua[a] = b;
        va[a] = b.eventTypes[c].dependencies;
    }
    var ra = [], sa = {}, ua = {}, va = {};
    function wa(a) {
        oa ? D("101") : void 0;
        oa = Array.prototype.slice.call(a);
        qa();
    }
    function xa(a) {
        var b = !1, c;
        for (c in a) if (a.hasOwnProperty(c)) {
            var d = a[c];
            pa.hasOwnProperty(c) && pa[c] === d || (pa[c] ? D("102", c) : void 0, pa[c] = d, 
            b = !0);
        }
        b && qa();
    }
    var Ca = Object.freeze({
        plugins: ra,
        eventNameDispatchConfigs: sa,
        registrationNameModules: ua,
        registrationNameDependencies: va,
        possibleRegistrationNames: null,
        injectEventPluginOrder: wa,
        injectEventPluginsByName: xa
    }), Da = null, Ea = null, Fa = null;
    function Ga(a, b, c, d) {
        b = a.type || "unknown-event";
        a.currentTarget = Fa(d);
        E.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);
        a.currentTarget = null;
    }
    function Ha(a, b) {
        null == b ? D("30") : void 0;
        if (null == a) return b;
        if (Array.isArray(a)) {
            if (Array.isArray(b)) return a.push.apply(a, b), a;
            a.push(b);
            return a;
        }
        return Array.isArray(b) ? [ a ].concat(b) : [ a, b ];
    }
    function Ia(a, b, c) {
        Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
    }
    var Ja = null;
    function Ka(a, b) {
        if (a) {
            var c = a._dispatchListeners, d = a._dispatchInstances;
            if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) Ga(a, b, c[e], d[e]); else c && Ga(a, b, c, d);
            a._dispatchListeners = null;
            a._dispatchInstances = null;
            a.isPersistent() || a.constructor.release(a);
        }
    }
    function La(a) {
        return Ka(a, !0);
    }
    function Ma(a) {
        return Ka(a, !1);
    }
    var Na = {
        injectEventPluginOrder: wa,
        injectEventPluginsByName: xa
    };
    function Oa(a, b) {
        var c = a.stateNode;
        if (!c) return null;
        var d = Da(c);
        if (!d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;

          default:
            a = !1;
        }
        if (a) return null;
        c && "function" !== typeof c ? D("231", b, typeof c) : void 0;
        return c;
    }
    function Pa(a, b) {
        null !== a && (Ja = Ha(Ja, a));
        a = Ja;
        Ja = null;
        a && (b ? Ia(a, La) : Ia(a, Ma), Ja ? D("95") : void 0, E.rethrowCaughtError());
    }
    function Qa(a, b, c, d) {
        for (var e = null, f = 0; f < ra.length; f++) {
            var h = ra[f];
            h && (h = h.extractEvents(a, b, c, d)) && (e = Ha(e, h));
        }
        Pa(e, !1);
    }
    var Ra = Object.freeze({
        injection: Na,
        getListener: Oa,
        runEventsInBatch: Pa,
        runExtractedEventsInBatch: Qa
    }), Sa = Math.random().toString(36).slice(2), F = "__reactInternalInstance$" + Sa, Ta = "__reactEventHandlers$" + Sa;
    function Ua(a) {
        if (a[F]) return a[F];
        for (;!a[F]; ) if (a.parentNode) a = a.parentNode; else return null;
        a = a[F];
        return 5 === a.tag || 6 === a.tag ? a : null;
    }
    function Va(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        D("33");
    }
    function Xa(a) {
        return a[Ta] || null;
    }
    var bb = Object.freeze({
        precacheFiberNode: function(a, b) {
            b[F] = a;
        },
        getClosestInstanceFromNode: Ua,
        getInstanceFromNode: function(a) {
            a = a[F];
            return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
        },
        getNodeFromInstance: Va,
        getFiberCurrentPropsFromNode: Xa,
        updateFiberProps: function(a, b) {
            a[Ta] = b;
        }
    });
    function L(a) {
        do {
            a = a["return"];
        } while (a && 5 !== a.tag);
        return a ? a : null;
    }
    function cb(a, b, c) {
        for (var d = []; a; ) d.push(a), a = L(a);
        for (a = d.length; 0 < a--; ) b(d[a], "captured", c);
        for (a = 0; a < d.length; a++) b(d[a], "bubbled", c);
    }
    function db(a, b, c) {
        if (b = Oa(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = Ha(c._dispatchListeners, b), 
        c._dispatchInstances = Ha(c._dispatchInstances, a);
    }
    function eb(a) {
        a && a.dispatchConfig.phasedRegistrationNames && cb(a._targetInst, db, a);
    }
    function fb(a) {
        if (a && a.dispatchConfig.phasedRegistrationNames) {
            var b = a._targetInst;
            b = b ? L(b) : null;
            cb(b, db, a);
        }
    }
    function gb(a, b, c) {
        a && c && c.dispatchConfig.registrationName && (b = Oa(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = Ha(c._dispatchListeners, b), 
        c._dispatchInstances = Ha(c._dispatchInstances, a));
    }
    function hb(a) {
        a && a.dispatchConfig.registrationName && gb(a._targetInst, null, a);
    }
    function ib(a) {
        Ia(a, eb);
    }
    function jb(a, b, c, d) {
        if (c && d) a: {
            var e = c;
            for (var f = d, h = 0, g = e; g; g = L(g)) h++;
            g = 0;
            for (var k = f; k; k = L(k)) g++;
            for (;0 < h - g; ) e = L(e), h--;
            for (;0 < g - h; ) f = L(f), g--;
            for (;h--; ) {
                if (e === f || e === f.alternate) break a;
                e = L(e);
                f = L(f);
            }
            e = null;
        } else e = null;
        f = e;
        for (e = []; c && c !== f; ) {
            h = c.alternate;
            if (null !== h && h === f) break;
            e.push(c);
            c = L(c);
        }
        for (c = []; d && d !== f; ) {
            h = d.alternate;
            if (null !== h && h === f) break;
            c.push(d);
            d = L(d);
        }
        for (d = 0; d < e.length; d++) gb(e[d], "bubbled", a);
        for (a = c.length; 0 < a--; ) gb(c[a], "captured", b);
    }
    var kb = Object.freeze({
        accumulateTwoPhaseDispatches: ib,
        accumulateTwoPhaseDispatchesSkipTarget: function(a) {
            Ia(a, fb);
        },
        accumulateEnterLeaveDispatches: jb,
        accumulateDirectDispatches: function(a) {
            Ia(a, hb);
        }
    }), lb = null;
    function mb() {
        !lb && m.canUseDOM && (lb = "textContent" in document.documentElement ? "textContent" : "innerText");
        return lb;
    }
    var M = {
        _root: null,
        _startText: null,
        _fallbackText: null
    };
    function nb() {
        if (M._fallbackText) return M._fallbackText;
        var a, b = M._startText, c = b.length, d, e = ob(), f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var h = c - a;
        for (d = 1; d <= h && b[c - d] === e[f - d]; d++) ;
        M._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);
        return M._fallbackText;
    }
    function ob() {
        return "value" in M._root ? M._root.value : M._root[mb()];
    }
    var pb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "), qb = {
        type: null,
        target: null,
        currentTarget: C.thatReturnsNull,
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function(a) {
            return a.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
    };
    function N(a, b, c, d) {
        this.dispatchConfig = a;
        this._targetInst = b;
        this.nativeEvent = c;
        a = this.constructor.Interface;
        for (var e in a) a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
        this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? C.thatReturnsTrue : C.thatReturnsFalse;
        this.isPropagationStopped = C.thatReturnsFalse;
        return this;
    }
    A(N.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var a = this.nativeEvent;
            a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), 
            this.isDefaultPrevented = C.thatReturnsTrue);
        },
        stopPropagation: function() {
            var a = this.nativeEvent;
            a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), 
            this.isPropagationStopped = C.thatReturnsTrue);
        },
        persist: function() {
            this.isPersistent = C.thatReturnsTrue;
        },
        isPersistent: C.thatReturnsFalse,
        destructor: function() {
            var a = this.constructor.Interface, b;
            for (b in a) this[b] = null;
            for (a = 0; a < pb.length; a++) this[pb[a]] = null;
        }
    });
    N.Interface = qb;
    N.extend = function(a) {
        function b() {}
        function c() {
            return d.apply(this, arguments);
        }
        var d = this;
        b.prototype = d.prototype;
        var e = new b();
        A(e, c.prototype);
        c.prototype = e;
        c.prototype.constructor = c;
        c.Interface = A({}, d.Interface, a);
        c.extend = d.extend;
        rb(c);
        return c;
    };
    rb(N);
    function sb(a, b, c, d) {
        if (this.eventPool.length) {
            var e = this.eventPool.pop();
            this.call(e, a, b, c, d);
            return e;
        }
        return new this(a, b, c, d);
    }
    function tb(a) {
        a instanceof this ? void 0 : D("223");
        a.destructor();
        10 > this.eventPool.length && this.eventPool.push(a);
    }
    function rb(a) {
        a.eventPool = [];
        a.getPooled = sb;
        a.release = tb;
    }
    var ub = N.extend({
        data: null
    }), vb = N.extend({
        data: null
    }), wb = [ 9, 13, 27, 32 ], xb = m.canUseDOM && "CompositionEvent" in window, yb = null;
    m.canUseDOM && "documentMode" in document && (yb = document.documentMode);
    var zb = m.canUseDOM && "TextEvent" in window && !yb, Ab = m.canUseDOM && (!xb || yb && 8 < yb && 11 >= yb), Bb = String.fromCharCode(32), Kb = {
        beforeInput: {
            phasedRegistrationNames: {
                bubbled: "onBeforeInput",
                captured: "onBeforeInputCapture"
            },
            dependencies: [ "topCompositionEnd", "topKeyPress", "topTextInput", "topPaste" ]
        },
        compositionEnd: {
            phasedRegistrationNames: {
                bubbled: "onCompositionEnd",
                captured: "onCompositionEndCapture"
            },
            dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
        },
        compositionStart: {
            phasedRegistrationNames: {
                bubbled: "onCompositionStart",
                captured: "onCompositionStartCapture"
            },
            dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
        },
        compositionUpdate: {
            phasedRegistrationNames: {
                bubbled: "onCompositionUpdate",
                captured: "onCompositionUpdateCapture"
            },
            dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
        }
    }, Lb = !1;
    function Mb(a, b) {
        switch (a) {
          case "topKeyUp":
            return -1 !== wb.indexOf(b.keyCode);

          case "topKeyDown":
            return 229 !== b.keyCode;

          case "topKeyPress":
          case "topMouseDown":
          case "topBlur":
            return !0;

          default:
            return !1;
        }
    }
    function Nb(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
    }
    var Ob = !1;
    function Pb(a, b) {
        switch (a) {
          case "topCompositionEnd":
            return Nb(b);

          case "topKeyPress":
            if (32 !== b.which) return null;
            Lb = !0;
            return Bb;

          case "topTextInput":
            return a = b.data, a === Bb && Lb ? null : a;

          default:
            return null;
        }
    }
    function Qb(a, b) {
        if (Ob) return "topCompositionEnd" === a || !xb && Mb(a, b) ? (a = nb(), M._root = null, 
        M._startText = null, M._fallbackText = null, Ob = !1, a) : null;
        switch (a) {
          case "topPaste":
            return null;

          case "topKeyPress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                if (b.char && 1 < b.char.length) return b.char;
                if (b.which) return String.fromCharCode(b.which);
            }
            return null;

          case "topCompositionEnd":
            return Ab ? null : b.data;

          default:
            return null;
        }
    }
    var Rb = {
        eventTypes: Kb,
        extractEvents: function(a, b, c, d) {
            var e = void 0;
            var f = void 0;
            if (xb) b: {
                switch (a) {
                  case "topCompositionStart":
                    e = Kb.compositionStart;
                    break b;

                  case "topCompositionEnd":
                    e = Kb.compositionEnd;
                    break b;

                  case "topCompositionUpdate":
                    e = Kb.compositionUpdate;
                    break b;
                }
                e = void 0;
            } else Ob ? Mb(a, c) && (e = Kb.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (e = Kb.compositionStart);
            e ? (Ab && (Ob || e !== Kb.compositionStart ? e === Kb.compositionEnd && Ob && (f = nb()) : (M._root = d, 
            M._startText = ob(), Ob = !0)), e = ub.getPooled(e, b, c, d), f ? e.data = f : (f = Nb(c), 
            null !== f && (e.data = f)), ib(e), f = e) : f = null;
            (a = zb ? Pb(a, c) : Qb(a, c)) ? (b = vb.getPooled(Kb.beforeInput, b, c, d), b.data = a, 
            ib(b)) : b = null;
            return null === f ? b : null === b ? f : [ f, b ];
        }
    }, Sb = null, Tb = {
        injectFiberControlledHostComponent: function(a) {
            Sb = a;
        }
    }, Ub = null, Vb = null;
    function Wb(a) {
        if (a = Ea(a)) {
            Sb && "function" === typeof Sb.restoreControlledState ? void 0 : D("194");
            var b = Da(a.stateNode);
            Sb.restoreControlledState(a.stateNode, a.type, b);
        }
    }
    function Xb(a) {
        Ub ? Vb ? Vb.push(a) : Vb = [ a ] : Ub = a;
    }
    function Yb() {
        return null !== Ub || null !== Vb;
    }
    function Zb() {
        if (Ub) {
            var a = Ub, b = Vb;
            Vb = Ub = null;
            Wb(a);
            if (b) for (a = 0; a < b.length; a++) Wb(b[a]);
        }
    }
    var $b = Object.freeze({
        injection: Tb,
        enqueueStateRestore: Xb,
        needsStateRestore: Yb,
        restoreStateIfNeeded: Zb
    });
    function ac(a, b) {
        return a(b);
    }
    function bc(a, b, c) {
        return a(b, c);
    }
    function cc() {}
    var dc = !1;
    function ec(a, b) {
        if (dc) return a(b);
        dc = !0;
        try {
            return ac(a, b);
        } finally {
            dc = !1, Yb() && (cc(), Zb());
        }
    }
    var fc = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function gc(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!fc[a.type] : "textarea" === b ? !0 : !1;
    }
    function hc(a) {
        a = a.target || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
    }
    function ic(a, b) {
        if (!m.canUseDOM || b && !("addEventListener" in document)) return !1;
        a = "on" + a;
        b = a in document;
        b || (b = document.createElement("div"), b.setAttribute(a, "return;"), b = "function" === typeof b[a]);
        return b;
    }
    function jc(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function kc(a) {
        var b = jc(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, {
            configurable: !0,
            get: function() {
                return c.get.call(this);
            },
            set: function(a) {
                d = "" + a;
                c.set.call(this, a);
            }
        }), Object.defineProperty(a, b, {
            enumerable: c.enumerable
        }), {
            getValue: function() {
                return d;
            },
            setValue: function(a) {
                d = "" + a;
            },
            stopTracking: function() {
                a._valueTracker = null;
                delete a[b];
            }
        };
    }
    function lc(a) {
        a._valueTracker || (a._valueTracker = kc(a));
    }
    function mc(a) {
        if (!a) return !1;
        var b = a._valueTracker;
        if (!b) return !0;
        var c = b.getValue();
        var d = "";
        a && (d = jc(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), !0) : !1;
    }
    var nc = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, O = "function" === typeof Symbol && Symbol["for"], oc = O ? Symbol["for"]("react.element") : 60103, pc = O ? Symbol["for"]("react.call") : 60104, qc = O ? Symbol["for"]("react.return") : 60105, rc = O ? Symbol["for"]("react.portal") : 60106, sc = O ? Symbol["for"]("react.fragment") : 60107, tc = O ? Symbol["for"]("react.strict_mode") : 60108, uc = O ? Symbol["for"]("react.provider") : 60109, vc = O ? Symbol["for"]("react.context") : 60110, wc = O ? Symbol["for"]("react.async_mode") : 60111, xc = O ? Symbol["for"]("react.forward_ref") : 60112, yc = "function" === typeof Symbol && Symbol.iterator;
    function zc(a) {
        if (null === a || "undefined" === typeof a) return null;
        a = yc && a[yc] || a["@@iterator"];
        return "function" === typeof a ? a : null;
    }
    function Ac(a) {
        a = a.type;
        if ("function" === typeof a) return a.displayName || a.name;
        if ("string" === typeof a) return a;
        switch (a) {
          case sc:
            return "ReactFragment";

          case rc:
            return "ReactPortal";

          case pc:
            return "ReactCall";

          case qc:
            return "ReactReturn";
        }
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case xc:
            return a = a.render.displayName || a.render.name || "", "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef";
        }
        return null;
    }
    function Bc(a) {
        var b = "";
        do {
            a: switch (a.tag) {
              case 0:
              case 1:
              case 2:
              case 5:
                var c = a._debugOwner, d = a._debugSource;
                var e = Ac(a);
                var f = null;
                c && (f = Ac(c));
                c = d;
                e = "\n    in " + (e || "Unknown") + (c ? " (at " + c.fileName.replace(/^.*[\\\/]/, "") + ":" + c.lineNumber + ")" : f ? " (created by " + f + ")" : "");
                break a;

              default:
                e = "";
            }
            b += e;
            a = a["return"];
        } while (a);
        return b;
    }
    var Cc = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Dc = {}, Ec = {};
    function Fc(a) {
        if (Ec.hasOwnProperty(a)) return !0;
        if (Dc.hasOwnProperty(a)) return !1;
        if (Cc.test(a)) return Ec[a] = !0;
        Dc[a] = !0;
        return !1;
    }
    function Gc(a, b, c, d) {
        if (null !== c && 0 === c.type) return !1;
        switch (typeof b) {
          case "function":
          case "symbol":
            return !0;

          case "boolean":
            if (d) return !1;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;

          default:
            return !1;
        }
    }
    function Hc(a, b, c, d) {
        if (null === b || "undefined" === typeof b || Gc(a, b, c, d)) return !0;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;

          case 4:
            return !1 === b;

          case 5:
            return isNaN(b);

          case 6:
            return isNaN(b) || 1 > b;
        }
        return !1;
    }
    function U(a, b, c, d, e) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
    }
    var V = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        V[a] = new U(a, 0, !1, a, null);
    });
    [ [ "acceptCharset", "accept-charset" ], [ "className", "class" ], [ "htmlFor", "for" ], [ "httpEquiv", "http-equiv" ] ].forEach(function(a) {
        var b = a[0];
        V[b] = new U(b, 1, !1, a[1], null);
    });
    [ "contentEditable", "draggable", "spellCheck", "value" ].forEach(function(a) {
        V[a] = new U(a, 2, !1, a.toLowerCase(), null);
    });
    [ "autoReverse", "externalResourcesRequired", "preserveAlpha" ].forEach(function(a) {
        V[a] = new U(a, 2, !1, a, null);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        V[a] = new U(a, 3, !1, a.toLowerCase(), null);
    });
    [ "checked", "multiple", "muted", "selected" ].forEach(function(a) {
        V[a] = new U(a, 3, !0, a.toLowerCase(), null);
    });
    [ "capture", "download" ].forEach(function(a) {
        V[a] = new U(a, 4, !1, a.toLowerCase(), null);
    });
    [ "cols", "rows", "size", "span" ].forEach(function(a) {
        V[a] = new U(a, 6, !1, a.toLowerCase(), null);
    });
    [ "rowSpan", "start" ].forEach(function(a) {
        V[a] = new U(a, 5, !1, a.toLowerCase(), null);
    });
    var Sc = /[\-:]([a-z])/g;
    function Tc(a) {
        return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(Sc, Tc);
        V[b] = new U(b, 1, !1, a, null);
    });
    "xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(Sc, Tc);
        V[b] = new U(b, 1, !1, a, "http://www.w3.org/1999/xlink");
    });
    [ "xml:base", "xml:lang", "xml:space" ].forEach(function(a) {
        var b = a.replace(Sc, Tc);
        V[b] = new U(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace");
    });
    V.tabIndex = new U("tabIndex", 1, !1, "tabindex", null);
    function Uc(a, b, c, d) {
        var e = V.hasOwnProperty(b) ? V[b] : null;
        var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0;
        f || (Hc(b, c, e, d) && (c = null), d || null === e ? Fc(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, 
        d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, 
        d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
    }
    function Vc(a, b) {
        var c = b.checked;
        return A({}, b, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != c ? c : a._wrapperState.initialChecked
        });
    }
    function Wc(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Xc(null != b.value ? b.value : c);
        a._wrapperState = {
            initialChecked: d,
            initialValue: c,
            controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
        };
    }
    function Yc(a, b) {
        b = b.checked;
        null != b && Uc(a, "checked", b, !1);
    }
    function Zc(a, b) {
        Yc(a, b);
        var c = Xc(b.value);
        if (null != c) if ("number" === b.type) {
            if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        b.hasOwnProperty("value") ? $c(a, b.type, c) : b.hasOwnProperty("defaultValue") && $c(a, b.type, Xc(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function ad(a, b) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) "" === a.value && (a.value = "" + a._wrapperState.initialValue), 
        a.defaultValue = "" + a._wrapperState.initialValue;
        b = a.name;
        "" !== b && (a.name = "");
        a.defaultChecked = !a.defaultChecked;
        a.defaultChecked = !a.defaultChecked;
        "" !== b && (a.name = b);
    }
    function $c(a, b, c) {
        if ("number" !== b || a.ownerDocument.activeElement !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    function Xc(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "object":
          case "string":
          case "undefined":
            return a;

          default:
            return "";
        }
    }
    var bd = {
        change: {
            phasedRegistrationNames: {
                bubbled: "onChange",
                captured: "onChangeCapture"
            },
            dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")
        }
    };
    function cd(a, b, c) {
        a = N.getPooled(bd.change, a, b, c);
        a.type = "change";
        Xb(c);
        ib(a);
        return a;
    }
    var dd = null, ed = null;
    function fd(a) {
        Pa(a, !1);
    }
    function gd(a) {
        var b = Va(a);
        if (mc(b)) return a;
    }
    function hd(a, b) {
        if ("topChange" === a) return b;
    }
    var id = !1;
    m.canUseDOM && (id = ic("input") && (!document.documentMode || 9 < document.documentMode));
    function jd() {
        dd && (dd.detachEvent("onpropertychange", kd), ed = dd = null);
    }
    function kd(a) {
        "value" === a.propertyName && gd(ed) && (a = cd(ed, a, hc(a)), ec(fd, a));
    }
    function ld(a, b, c) {
        "topFocus" === a ? (jd(), dd = b, ed = c, dd.attachEvent("onpropertychange", kd)) : "topBlur" === a && jd();
    }
    function md(a) {
        if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return gd(ed);
    }
    function nd(a, b) {
        if ("topClick" === a) return gd(b);
    }
    function od(a, b) {
        if ("topInput" === a || "topChange" === a) return gd(b);
    }
    var pd = {
        eventTypes: bd,
        _isInputEventSupported: id,
        extractEvents: function(a, b, c, d) {
            var e = b ? Va(b) : window, f = void 0, h = void 0, g = e.nodeName && e.nodeName.toLowerCase();
            "select" === g || "input" === g && "file" === e.type ? f = hd : gc(e) ? id ? f = od : (f = md, 
            h = ld) : (g = e.nodeName) && "input" === g.toLowerCase() && ("checkbox" === e.type || "radio" === e.type) && (f = nd);
            if (f && (f = f(a, b))) return cd(f, c, d);
            h && h(a, e, b);
            "topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && $c(e, "number", e.value);
        }
    }, qd = N.extend({
        view: null,
        detail: null
    }), rd = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function sd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = rd[a]) ? !!b[a] : !1;
    }
    function td() {
        return sd;
    }
    var ud = qd.extend({
        screenX: null,
        screenY: null,
        clientX: null,
        clientY: null,
        pageX: null,
        pageY: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        getModifierState: td,
        button: null,
        buttons: null,
        relatedTarget: function(a) {
            return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
        }
    }), vd = {
        mouseEnter: {
            registrationName: "onMouseEnter",
            dependencies: [ "topMouseOut", "topMouseOver" ]
        },
        mouseLeave: {
            registrationName: "onMouseLeave",
            dependencies: [ "topMouseOut", "topMouseOver" ]
        }
    }, wd = {
        eventTypes: vd,
        extractEvents: function(a, b, c, d) {
            if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;
            var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;
            "topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? Ua(b) : null) : a = null;
            if (a === b) return null;
            var f = null == a ? e : Va(a);
            e = null == b ? e : Va(b);
            var h = ud.getPooled(vd.mouseLeave, a, c, d);
            h.type = "mouseleave";
            h.target = f;
            h.relatedTarget = e;
            c = ud.getPooled(vd.mouseEnter, b, c, d);
            c.type = "mouseenter";
            c.target = e;
            c.relatedTarget = f;
            jb(h, c, a, b);
            return [ h, c ];
        }
    };
    function xd(a) {
        var b = a;
        if (a.alternate) for (;b["return"]; ) b = b["return"]; else {
            if (0 !== (b.effectTag & 2)) return 1;
            for (;b["return"]; ) if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
        }
        return 3 === b.tag ? 2 : 3;
    }
    function yd(a) {
        return (a = a._reactInternalFiber) ? 2 === xd(a) : !1;
    }
    function zd(a) {
        2 !== xd(a) ? D("188") : void 0;
    }
    function Ad(a) {
        var b = a.alternate;
        if (!b) return b = xd(a), 3 === b ? D("188") : void 0, 1 === b ? null : a;
        for (var c = a, d = b; ;) {
            var e = c["return"], f = e ? e.alternate : null;
            if (!e || !f) break;
            if (e.child === f.child) {
                for (var h = e.child; h; ) {
                    if (h === c) return zd(e), a;
                    if (h === d) return zd(e), b;
                    h = h.sibling;
                }
                D("188");
            }
            if (c["return"] !== d["return"]) c = e, d = f; else {
                h = !1;
                for (var g = e.child; g; ) {
                    if (g === c) {
                        h = !0;
                        c = e;
                        d = f;
                        break;
                    }
                    if (g === d) {
                        h = !0;
                        d = e;
                        c = f;
                        break;
                    }
                    g = g.sibling;
                }
                if (!h) {
                    for (g = f.child; g; ) {
                        if (g === c) {
                            h = !0;
                            c = f;
                            d = e;
                            break;
                        }
                        if (g === d) {
                            h = !0;
                            d = f;
                            c = e;
                            break;
                        }
                        g = g.sibling;
                    }
                    h ? void 0 : D("189");
                }
            }
            c.alternate !== d ? D("190") : void 0;
        }
        3 !== c.tag ? D("188") : void 0;
        return c.stateNode.current === c ? a : b;
    }
    function Bd(a) {
        a = Ad(a);
        if (!a) return null;
        for (var b = a; ;) {
            if (5 === b.tag || 6 === b.tag) return b;
            if (b.child) b.child["return"] = b, b = b.child; else {
                if (b === a) break;
                for (;!b.sibling; ) {
                    if (!b["return"] || b["return"] === a) return null;
                    b = b["return"];
                }
                b.sibling["return"] = b["return"];
                b = b.sibling;
            }
        }
        return null;
    }
    function Cd(a) {
        a = Ad(a);
        if (!a) return null;
        for (var b = a; ;) {
            if (5 === b.tag || 6 === b.tag) return b;
            if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child; else {
                if (b === a) break;
                for (;!b.sibling; ) {
                    if (!b["return"] || b["return"] === a) return null;
                    b = b["return"];
                }
                b.sibling["return"] = b["return"];
                b = b.sibling;
            }
        }
        return null;
    }
    var Dd = N.extend({
        animationName: null,
        elapsedTime: null,
        pseudoElement: null
    }), Ed = N.extend({
        clipboardData: function(a) {
            return "clipboardData" in a ? a.clipboardData : window.clipboardData;
        }
    }), Fd = qd.extend({
        relatedTarget: null
    });
    function Gd(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
    }
    var Hd = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, Id = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, Jd = qd.extend({
        key: function(a) {
            if (a.key) {
                var b = Hd[a.key] || a.key;
                if ("Unidentified" !== b) return b;
            }
            return "keypress" === a.type ? (a = Gd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Id[a.keyCode] || "Unidentified" : "";
        },
        location: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        repeat: null,
        locale: null,
        getModifierState: td,
        charCode: function(a) {
            return "keypress" === a.type ? Gd(a) : 0;
        },
        keyCode: function(a) {
            return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
        },
        which: function(a) {
            return "keypress" === a.type ? Gd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
        }
    }), Kd = ud.extend({
        dataTransfer: null
    }), Ld = qd.extend({
        touches: null,
        targetTouches: null,
        changedTouches: null,
        altKey: null,
        metaKey: null,
        ctrlKey: null,
        shiftKey: null,
        getModifierState: td
    }), Md = N.extend({
        propertyName: null,
        elapsedTime: null,
        pseudoElement: null
    }), Nd = ud.extend({
        deltaX: function(a) {
            return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
            return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: null,
        deltaMode: null
    }), Od = {}, Pd = {};
    function Qd(a, b) {
        var c = a[0].toUpperCase() + a.slice(1), d = "on" + c;
        c = "top" + c;
        b = {
            phasedRegistrationNames: {
                bubbled: d,
                captured: d + "Capture"
            },
            dependencies: [ c ],
            isInteractive: b
        };
        Od[a] = b;
        Pd[c] = b;
    }
    "blur cancel click close contextMenu copy cut doubleClick dragEnd dragStart drop focus input invalid keyDown keyPress keyUp mouseDown mouseUp paste pause play rateChange reset seeked submit touchCancel touchEnd touchStart volumeChange".split(" ").forEach(function(a) {
        Qd(a, !0);
    });
    "abort animationEnd animationIteration animationStart canPlay canPlayThrough drag dragEnter dragExit dragLeave dragOver durationChange emptied encrypted ended error load loadedData loadedMetadata loadStart mouseMove mouseOut mouseOver playing progress scroll seeking stalled suspend timeUpdate toggle touchMove transitionEnd waiting wheel".split(" ").forEach(function(a) {
        Qd(a, !1);
    });
    var Rd = {
        eventTypes: Od,
        isInteractiveTopLevelEventType: function(a) {
            a = Pd[a];
            return void 0 !== a && !0 === a.isInteractive;
        },
        extractEvents: function(a, b, c, d) {
            var e = Pd[a];
            if (!e) return null;
            switch (a) {
              case "topKeyPress":
                if (0 === Gd(c)) return null;

              case "topKeyDown":
              case "topKeyUp":
                a = Jd;
                break;

              case "topBlur":
              case "topFocus":
                a = Fd;
                break;

              case "topClick":
                if (2 === c.button) return null;

              case "topDoubleClick":
              case "topMouseDown":
              case "topMouseMove":
              case "topMouseUp":
              case "topMouseOut":
              case "topMouseOver":
              case "topContextMenu":
                a = ud;
                break;

              case "topDrag":
              case "topDragEnd":
              case "topDragEnter":
              case "topDragExit":
              case "topDragLeave":
              case "topDragOver":
              case "topDragStart":
              case "topDrop":
                a = Kd;
                break;

              case "topTouchCancel":
              case "topTouchEnd":
              case "topTouchMove":
              case "topTouchStart":
                a = Ld;
                break;

              case "topAnimationEnd":
              case "topAnimationIteration":
              case "topAnimationStart":
                a = Dd;
                break;

              case "topTransitionEnd":
                a = Md;
                break;

              case "topScroll":
                a = qd;
                break;

              case "topWheel":
                a = Nd;
                break;

              case "topCopy":
              case "topCut":
              case "topPaste":
                a = Ed;
                break;

              default:
                a = N;
            }
            b = a.getPooled(e, b, c, d);
            ib(b);
            return b;
        }
    }, Sd = Rd.isInteractiveTopLevelEventType, Td = [];
    function Ud(a) {
        var b = a.targetInst;
        do {
            if (!b) {
                a.ancestors.push(b);
                break;
            }
            var c;
            for (c = b; c["return"]; ) c = c["return"];
            c = 3 !== c.tag ? null : c.stateNode.containerInfo;
            if (!c) break;
            a.ancestors.push(b);
            b = Ua(c);
        } while (b);
        for (c = 0; c < a.ancestors.length; c++) b = a.ancestors[c], Qa(a.topLevelType, b, a.nativeEvent, hc(a.nativeEvent));
    }
    var Vd = !0;
    function Wd(a) {
        Vd = !!a;
    }
    function W(a, b, c) {
        if (!c) return null;
        a = (Sd(a) ? Xd : Yd).bind(null, a);
        c.addEventListener(b, a, !1);
    }
    function Zd(a, b, c) {
        if (!c) return null;
        a = (Sd(a) ? Xd : Yd).bind(null, a);
        c.addEventListener(b, a, !0);
    }
    function Xd(a, b) {
        bc(Yd, a, b);
    }
    function Yd(a, b) {
        if (Vd) {
            var c = hc(b);
            c = Ua(c);
            null !== c && "number" === typeof c.tag && 2 !== xd(c) && (c = null);
            if (Td.length) {
                var d = Td.pop();
                d.topLevelType = a;
                d.nativeEvent = b;
                d.targetInst = c;
                a = d;
            } else a = {
                topLevelType: a,
                nativeEvent: b,
                targetInst: c,
                ancestors: []
            };
            try {
                ec(Ud, a);
            } finally {
                a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 
                10 > Td.length && Td.push(a);
            }
        }
    }
    var $d = Object.freeze({
        get _enabled() {
            return Vd;
        },
        setEnabled: Wd,
        isEnabled: function() {
            return Vd;
        },
        trapBubbledEvent: W,
        trapCapturedEvent: Zd,
        dispatchEvent: Yd
    });
    function ae(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        c["ms" + a] = "MS" + b;
        c["O" + a] = "o" + b.toLowerCase();
        return c;
    }
    var be = {
        animationend: ae("Animation", "AnimationEnd"),
        animationiteration: ae("Animation", "AnimationIteration"),
        animationstart: ae("Animation", "AnimationStart"),
        transitionend: ae("Transition", "TransitionEnd")
    }, ce = {}, de = {};
    m.canUseDOM && (de = document.createElement("div").style, "AnimationEvent" in window || (delete be.animationend.animation, 
    delete be.animationiteration.animation, delete be.animationstart.animation), "TransitionEvent" in window || delete be.transitionend.transition);
    function ee(a) {
        if (ce[a]) return ce[a];
        if (!be[a]) return a;
        var b = be[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in de) return ce[a] = b[c];
        return a;
    }
    var fe = {
        topAnimationEnd: ee("animationend"),
        topAnimationIteration: ee("animationiteration"),
        topAnimationStart: ee("animationstart"),
        topBlur: "blur",
        topCancel: "cancel",
        topChange: "change",
        topClick: "click",
        topClose: "close",
        topCompositionEnd: "compositionend",
        topCompositionStart: "compositionstart",
        topCompositionUpdate: "compositionupdate",
        topContextMenu: "contextmenu",
        topCopy: "copy",
        topCut: "cut",
        topDoubleClick: "dblclick",
        topDrag: "drag",
        topDragEnd: "dragend",
        topDragEnter: "dragenter",
        topDragExit: "dragexit",
        topDragLeave: "dragleave",
        topDragOver: "dragover",
        topDragStart: "dragstart",
        topDrop: "drop",
        topFocus: "focus",
        topInput: "input",
        topKeyDown: "keydown",
        topKeyPress: "keypress",
        topKeyUp: "keyup",
        topLoad: "load",
        topLoadStart: "loadstart",
        topMouseDown: "mousedown",
        topMouseMove: "mousemove",
        topMouseOut: "mouseout",
        topMouseOver: "mouseover",
        topMouseUp: "mouseup",
        topPaste: "paste",
        topScroll: "scroll",
        topSelectionChange: "selectionchange",
        topTextInput: "textInput",
        topToggle: "toggle",
        topTouchCancel: "touchcancel",
        topTouchEnd: "touchend",
        topTouchMove: "touchmove",
        topTouchStart: "touchstart",
        topTransitionEnd: ee("transitionend"),
        topWheel: "wheel"
    }, ge = {
        topAbort: "abort",
        topCanPlay: "canplay",
        topCanPlayThrough: "canplaythrough",
        topDurationChange: "durationchange",
        topEmptied: "emptied",
        topEncrypted: "encrypted",
        topEnded: "ended",
        topError: "error",
        topLoadedData: "loadeddata",
        topLoadedMetadata: "loadedmetadata",
        topLoadStart: "loadstart",
        topPause: "pause",
        topPlay: "play",
        topPlaying: "playing",
        topProgress: "progress",
        topRateChange: "ratechange",
        topSeeked: "seeked",
        topSeeking: "seeking",
        topStalled: "stalled",
        topSuspend: "suspend",
        topTimeUpdate: "timeupdate",
        topVolumeChange: "volumechange",
        topWaiting: "waiting"
    }, he = {}, ie = 0, je = "_reactListenersID" + ("" + Math.random()).slice(2);
    function ke(a) {
        Object.prototype.hasOwnProperty.call(a, je) || (a[je] = ie++, he[a[je]] = {});
        return he[a[je]];
    }
    function le(a) {
        for (;a && a.firstChild; ) a = a.firstChild;
        return a;
    }
    function me(a, b) {
        var c = le(a);
        a = 0;
        for (var d; c; ) {
            if (3 === c.nodeType) {
                d = a + c.textContent.length;
                if (a <= b && d >= b) return {
                    node: c,
                    offset: b - a
                };
                a = d;
            }
            a: {
                for (;c; ) {
                    if (c.nextSibling) {
                        c = c.nextSibling;
                        break a;
                    }
                    c = c.parentNode;
                }
                c = void 0;
            }
            c = le(c);
        }
    }
    function ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
    }
    var oe = m.canUseDOM && "documentMode" in document && 11 >= document.documentMode, pe = {
        select: {
            phasedRegistrationNames: {
                bubbled: "onSelect",
                captured: "onSelectCapture"
            },
            dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")
        }
    }, qe = null, re = null, se = null, te = !1;
    function ue(a, b) {
        if (te || null == qe || qe !== fa()) return null;
        var c = qe;
        "selectionStart" in c && ne(c) ? c = {
            start: c.selectionStart,
            end: c.selectionEnd
        } : window.getSelection ? (c = window.getSelection(), c = {
            anchorNode: c.anchorNode,
            anchorOffset: c.anchorOffset,
            focusNode: c.focusNode,
            focusOffset: c.focusOffset
        }) : c = void 0;
        return se && ha(se, c) ? null : (se = c, a = N.getPooled(pe.select, re, a, b), a.type = "select", 
        a.target = qe, ib(a), a);
    }
    var ve = {
        eventTypes: pe,
        extractEvents: function(a, b, c, d) {
            var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument, f;
            if (!(f = !e)) {
                a: {
                    e = ke(e);
                    f = va.onSelect;
                    for (var h = 0; h < f.length; h++) {
                        var g = f[h];
                        if (!e.hasOwnProperty(g) || !e[g]) {
                            e = !1;
                            break a;
                        }
                    }
                    e = !0;
                }
                f = !e;
            }
            if (f) return null;
            e = b ? Va(b) : window;
            switch (a) {
              case "topFocus":
                if (gc(e) || "true" === e.contentEditable) qe = e, re = b, se = null;
                break;

              case "topBlur":
                se = re = qe = null;
                break;

              case "topMouseDown":
                te = !0;
                break;

              case "topContextMenu":
              case "topMouseUp":
                return te = !1, ue(c, d);

              case "topSelectionChange":
                if (oe) break;

              case "topKeyDown":
              case "topKeyUp":
                return ue(c, d);
            }
            return null;
        }
    };
    Na.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
    Da = bb.getFiberCurrentPropsFromNode;
    Ea = bb.getInstanceFromNode;
    Fa = bb.getNodeFromInstance;
    Na.injectEventPluginsByName({
        SimpleEventPlugin: Rd,
        EnterLeaveEventPlugin: wd,
        ChangeEventPlugin: pd,
        SelectEventPlugin: ve,
        BeforeInputEventPlugin: Rb
    });
    function xe(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.stateNode = this.type = null;
        this.sibling = this.child = this["return"] = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.effectTag = 0;
        this.lastEffect = this.firstEffect = this.nextEffect = null;
        this.expirationTime = 0;
        this.alternate = null;
    }
    function ze(a, b, c) {
        var d = a.alternate;
        null === d ? (d = new xe(a.tag, b, a.key, a.mode), d.type = a.type, d.stateNode = a.stateNode, 
        d.alternate = a, a.alternate = d) : (d.pendingProps = b, d.effectTag = 0, d.nextEffect = null, 
        d.firstEffect = null, d.lastEffect = null);
        d.expirationTime = c;
        d.child = a.child;
        d.memoizedProps = a.memoizedProps;
        d.memoizedState = a.memoizedState;
        d.updateQueue = a.updateQueue;
        d.sibling = a.sibling;
        d.index = a.index;
        d.ref = a.ref;
        return d;
    }
    function Ae(a, b, c) {
        var d = a.type, e = a.key;
        a = a.props;
        var f = void 0;
        if ("function" === typeof d) f = d.prototype && d.prototype.isReactComponent ? 2 : 0; else if ("string" === typeof d) f = 5; else switch (d) {
          case sc:
            return Be(a.children, b, c, e);

          case wc:
            f = 11;
            b |= 3;
            break;

          case tc:
            f = 11;
            b |= 2;
            break;

          case pc:
            f = 7;
            break;

          case qc:
            f = 9;
            break;

          default:
            if ("object" === typeof d && null !== d) switch (d.$$typeof) {
              case uc:
                f = 13;
                break;

              case vc:
                f = 12;
                break;

              case xc:
                f = 14;
                break;

              default:
                if ("number" === typeof d.tag) return b = d, b.pendingProps = a, b.expirationTime = c, 
                b;
                D("130", null == d ? d : typeof d, "");
            } else D("130", null == d ? d : typeof d, "");
        }
        b = new xe(f, a, e, b);
        b.type = d;
        b.expirationTime = c;
        return b;
    }
    function Be(a, b, c, d) {
        a = new xe(10, a, d, b);
        a.expirationTime = c;
        return a;
    }
    function Ce(a, b, c) {
        a = new xe(6, a, null, b);
        a.expirationTime = c;
        return a;
    }
    function De(a, b, c) {
        b = new xe(4, null !== a.children ? a.children : [], a.key, b);
        b.expirationTime = c;
        b.stateNode = {
            containerInfo: a.containerInfo,
            pendingChildren: null,
            implementation: a.implementation
        };
        return b;
    }
    var Ee = null, Fe = null;
    function Ge(a) {
        return function(b) {
            try {
                return a(b);
            } catch (c) {}
        };
    }
    function He(a) {
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
        var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (b.isDisabled || !b.supportsFiber) return !0;
        try {
            var c = b.inject(a);
            Ee = Ge(function(a) {
                return b.onCommitFiberRoot(c, a);
            });
            Fe = Ge(function(a) {
                return b.onCommitFiberUnmount(c, a);
            });
        } catch (d) {}
        return !0;
    }
    function Ie(a) {
        "function" === typeof Ee && Ee(a);
    }
    function Je(a) {
        "function" === typeof Fe && Fe(a);
    }
    new Set();
    function Ke(a) {
        return {
            baseState: a,
            expirationTime: 0,
            first: null,
            last: null,
            callbackList: null,
            hasForceUpdate: !1,
            isInitialized: !1,
            capturedValues: null
        };
    }
    function Le(a, b) {
        null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);
        if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
    }
    var Me = void 0, Ne = void 0;
    function Oe(a) {
        Me = Ne = null;
        var b = a.alternate, c = a.updateQueue;
        null === c && (c = a.updateQueue = Ke(null));
        null !== b ? (a = b.updateQueue, null === a && (a = b.updateQueue = Ke(null))) : a = null;
        Me = c;
        Ne = a !== c ? a : null;
    }
    function Pe(a, b) {
        Oe(a);
        a = Me;
        var c = Ne;
        null === c ? Le(a, b) : null === a.last || null === c.last ? (Le(a, b), Le(c, b)) : (Le(a, b), 
        c.last = b);
    }
    function Qe(a, b, c, d) {
        a = a.partialState;
        return "function" === typeof a ? a.call(b, c, d) : a;
    }
    function Re(a, b, c, d, e, f) {
        null !== a && a.updateQueue === c && (c = b.updateQueue = {
            baseState: c.baseState,
            expirationTime: c.expirationTime,
            first: c.first,
            last: c.last,
            isInitialized: c.isInitialized,
            capturedValues: c.capturedValues,
            callbackList: null,
            hasForceUpdate: !1
        });
        c.expirationTime = 0;
        c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);
        for (var h = !0, g = c.first, k = !1; null !== g; ) {
            var v = g.expirationTime;
            if (v > f) {
                var l = c.expirationTime;
                if (0 === l || l > v) c.expirationTime = v;
                k || (k = !0, c.baseState = a);
            } else {
                k || (c.first = g.next, null === c.first && (c.last = null));
                if (g.isReplace) a = Qe(g, d, a, e), h = !0; else if (v = Qe(g, d, a, e)) a = h ? A({}, a, v) : A(a, v), 
                h = !1;
                g.isForced && (c.hasForceUpdate = !0);
                null !== g.callback && (v = c.callbackList, null === v && (v = c.callbackList = []), 
                v.push(g));
                null !== g.capturedValue && (v = c.capturedValues, null === v ? c.capturedValues = [ g.capturedValue ] : v.push(g.capturedValue));
            }
            g = g.next;
        }
        null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || null !== c.capturedValues || (b.updateQueue = null);
        k || (c.baseState = a);
        return a;
    }
    function Se(a, b) {
        var c = a.callbackList;
        if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
            var d = c[a], e = d.callback;
            d.callback = null;
            "function" !== typeof e ? D("191", e) : void 0;
            e.call(b);
        }
    }
    function Te(a, b, c, d, e) {
        function f(a, b, c, d, e, f) {
            if (null === b || null !== a.updateQueue && a.updateQueue.hasForceUpdate) return !0;
            var n = a.stateNode;
            a = a.type;
            return "function" === typeof n.shouldComponentUpdate ? n.shouldComponentUpdate(c, e, f) : a.prototype && a.prototype.isPureReactComponent ? !ha(b, c) || !ha(d, e) : !0;
        }
        function h(a, b) {
            b.updater = r;
            a.stateNode = b;
            b._reactInternalFiber = a;
        }
        function g(a, b, c, d) {
            a = b.state;
            "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
            "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
            b.state !== a && r.enqueueReplaceState(b, b.state, null);
        }
        function k(a, b, c, d) {
            a = a.type;
            if ("function" === typeof a.getDerivedStateFromProps) return a.getDerivedStateFromProps.call(null, c, d);
        }
        var v = a.cacheContext, l = a.getMaskedContext, p = a.getUnmaskedContext, z = a.isContextConsumer, B = a.hasContextChanged, r = {
            isMounted: yd,
            enqueueSetState: function(a, d, e) {
                a = a._reactInternalFiber;
                e = void 0 === e ? null : e;
                var f = c(a);
                Pe(a, {
                    expirationTime: f,
                    partialState: d,
                    callback: e,
                    isReplace: !1,
                    isForced: !1,
                    capturedValue: null,
                    next: null
                });
                b(a, f);
            },
            enqueueReplaceState: function(a, d, e) {
                a = a._reactInternalFiber;
                e = void 0 === e ? null : e;
                var f = c(a);
                Pe(a, {
                    expirationTime: f,
                    partialState: d,
                    callback: e,
                    isReplace: !0,
                    isForced: !1,
                    capturedValue: null,
                    next: null
                });
                b(a, f);
            },
            enqueueForceUpdate: function(a, d) {
                a = a._reactInternalFiber;
                d = void 0 === d ? null : d;
                var e = c(a);
                Pe(a, {
                    expirationTime: e,
                    partialState: null,
                    callback: d,
                    isReplace: !1,
                    isForced: !0,
                    capturedValue: null,
                    next: null
                });
                b(a, e);
            }
        };
        return {
            adoptClassInstance: h,
            callGetDerivedStateFromProps: k,
            constructClassInstance: function(a, b) {
                var c = a.type, d = p(a), e = z(a), f = e ? l(a, d) : ka;
                c = new c(b, f);
                var n = null !== c.state && void 0 !== c.state ? c.state : null;
                h(a, c);
                a.memoizedState = n;
                b = k(a, c, b, n);
                null !== b && void 0 !== b && (a.memoizedState = A({}, a.memoizedState, b));
                e && v(a, d, f);
                return c;
            },
            mountClassInstance: function(a, b) {
                var c = a.type, d = a.alternate, e = a.stateNode, f = a.pendingProps, n = p(a);
                e.props = f;
                e.state = a.memoizedState;
                e.refs = ka;
                e.context = l(a, n);
                "function" === typeof c.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (c = e.state, 
                "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), 
                c !== e.state && r.enqueueReplaceState(e, e.state, null), c = a.updateQueue, null !== c && (e.state = Re(d, a, c, e, f, b)));
                "function" === typeof e.componentDidMount && (a.effectTag |= 4);
            },
            resumeMountClassInstance: function(a, b) {
                var c = a.type, n = a.stateNode;
                n.props = a.memoizedProps;
                n.state = a.memoizedState;
                var h = a.memoizedProps, r = a.pendingProps, z = n.context, q = p(a);
                q = l(a, q);
                (c = "function" === typeof c.getDerivedStateFromProps || "function" === typeof n.getSnapshotBeforeUpdate) || "function" !== typeof n.UNSAFE_componentWillReceiveProps && "function" !== typeof n.componentWillReceiveProps || (h !== r || z !== q) && g(a, n, r, q);
                z = a.memoizedState;
                b = null !== a.updateQueue ? Re(null, a, a.updateQueue, n, r, b) : z;
                var u = void 0;
                h !== r && (u = k(a, n, r, b));
                if (null !== u && void 0 !== u) {
                    b = null === b || void 0 === b ? u : A({}, b, u);
                    var t = a.updateQueue;
                    null !== t && (t.baseState = A({}, t.baseState, u));
                }
                if (!(h !== r || z !== b || B() || null !== a.updateQueue && a.updateQueue.hasForceUpdate)) return "function" === typeof n.componentDidMount && (a.effectTag |= 4), 
                !1;
                (h = f(a, h, r, z, b, q)) ? (c || "function" !== typeof n.UNSAFE_componentWillMount && "function" !== typeof n.componentWillMount || ("function" === typeof n.componentWillMount && n.componentWillMount(), 
                "function" === typeof n.UNSAFE_componentWillMount && n.UNSAFE_componentWillMount()), 
                "function" === typeof n.componentDidMount && (a.effectTag |= 4)) : ("function" === typeof n.componentDidMount && (a.effectTag |= 4), 
                d(a, r), e(a, b));
                n.props = r;
                n.state = b;
                n.context = q;
                return h;
            },
            updateClassInstance: function(a, b, c) {
                var n = b.type, x = b.stateNode;
                x.props = b.memoizedProps;
                x.state = b.memoizedState;
                var h = b.memoizedProps, r = b.pendingProps, q = x.context, u = p(b);
                u = l(b, u);
                (n = "function" === typeof n.getDerivedStateFromProps || "function" === typeof x.getSnapshotBeforeUpdate) || "function" !== typeof x.UNSAFE_componentWillReceiveProps && "function" !== typeof x.componentWillReceiveProps || (h !== r || q !== u) && g(b, x, r, u);
                q = b.memoizedState;
                c = null !== b.updateQueue ? Re(a, b, b.updateQueue, x, r, c) : q;
                var t = void 0;
                h !== r && (t = k(b, x, r, c));
                if (null !== t && void 0 !== t) {
                    c = null === c || void 0 === c ? t : A({}, c, t);
                    var y = b.updateQueue;
                    null !== y && (y.baseState = A({}, y.baseState, t));
                }
                if (!(h !== r || q !== c || B() || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof x.componentDidUpdate || h === a.memoizedProps && q === a.memoizedState || (b.effectTag |= 4), 
                "function" !== typeof x.getSnapshotBeforeUpdate || h === a.memoizedProps && q === a.memoizedState || (b.effectTag |= 2048), 
                !1;
                (t = f(b, h, r, q, c, u)) ? (n || "function" !== typeof x.UNSAFE_componentWillUpdate && "function" !== typeof x.componentWillUpdate || ("function" === typeof x.componentWillUpdate && x.componentWillUpdate(r, c, u), 
                "function" === typeof x.UNSAFE_componentWillUpdate && x.UNSAFE_componentWillUpdate(r, c, u)), 
                "function" === typeof x.componentDidUpdate && (b.effectTag |= 4), "function" === typeof x.getSnapshotBeforeUpdate && (b.effectTag |= 2048)) : ("function" !== typeof x.componentDidUpdate || h === a.memoizedProps && q === a.memoizedState || (b.effectTag |= 4), 
                "function" !== typeof x.getSnapshotBeforeUpdate || h === a.memoizedProps && q === a.memoizedState || (b.effectTag |= 2048), 
                d(b, r), e(b, c));
                x.props = r;
                x.state = c;
                x.context = u;
                return t;
            }
        };
    }
    var Ue = Array.isArray;
    function Ve(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
            if (c._owner) {
                c = c._owner;
                var d = void 0;
                c && (2 !== c.tag ? D("110") : void 0, d = c.stateNode);
                d ? void 0 : D("147", a);
                var e = "" + a;
                if (null !== b && null !== b.ref && b.ref._stringRef === e) return b.ref;
                b = function(a) {
                    var b = d.refs === ka ? d.refs = {} : d.refs;
                    null === a ? delete b[e] : b[e] = a;
                };
                b._stringRef = e;
                return b;
            }
            "string" !== typeof a ? D("148") : void 0;
            c._owner ? void 0 : D("254", a);
        }
        return a;
    }
    function We(a, b) {
        "textarea" !== a.type && D("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
    }
    function Xe(a) {
        function b(b, c) {
            if (a) {
                var d = b.lastEffect;
                null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
                c.nextEffect = null;
                c.effectTag = 8;
            }
        }
        function c(c, d) {
            if (!a) return null;
            for (;null !== d; ) b(c, d), d = d.sibling;
            return null;
        }
        function d(a, b) {
            for (a = new Map(); null !== b; ) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), 
            b = b.sibling;
            return a;
        }
        function e(a, b, c) {
            a = ze(a, b, c);
            a.index = 0;
            a.sibling = null;
            return a;
        }
        function f(b, c, d) {
            b.index = d;
            if (!a) return c;
            d = b.alternate;
            if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;
            b.effectTag = 2;
            return c;
        }
        function h(b) {
            a && null === b.alternate && (b.effectTag = 2);
            return b;
        }
        function g(a, b, c, d) {
            if (null === b || 6 !== b.tag) return b = Ce(c, a.mode, d), b["return"] = a, b;
            b = e(b, c, d);
            b["return"] = a;
            return b;
        }
        function k(a, b, c, d) {
            if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Ve(a, b, c), 
            d["return"] = a, d;
            d = Ae(c, a.mode, d);
            d.ref = Ve(a, b, c);
            d["return"] = a;
            return d;
        }
        function v(a, b, c, d) {
            if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = De(c, a.mode, d), 
            b["return"] = a, b;
            b = e(b, c.children || [], d);
            b["return"] = a;
            return b;
        }
        function l(a, b, c, d, f) {
            if (null === b || 10 !== b.tag) return b = Be(c, a.mode, d, f), b["return"] = a, 
            b;
            b = e(b, c, d);
            b["return"] = a;
            return b;
        }
        function p(a, b, c) {
            if ("string" === typeof b || "number" === typeof b) return b = Ce("" + b, a.mode, c), 
            b["return"] = a, b;
            if ("object" === typeof b && null !== b) {
                switch (b.$$typeof) {
                  case oc:
                    return c = Ae(b, a.mode, c), c.ref = Ve(a, null, b), c["return"] = a, c;

                  case rc:
                    return b = De(b, a.mode, c), b["return"] = a, b;
                }
                if (Ue(b) || zc(b)) return b = Be(b, a.mode, c, null), b["return"] = a, b;
                We(a, b);
            }
            return null;
        }
        function z(a, b, c, d) {
            var e = null !== b ? b.key : null;
            if ("string" === typeof c || "number" === typeof c) return null !== e ? null : g(a, b, "" + c, d);
            if ("object" === typeof c && null !== c) {
                switch (c.$$typeof) {
                  case oc:
                    return c.key === e ? c.type === sc ? l(a, b, c.props.children, d, e) : k(a, b, c, d) : null;

                  case rc:
                    return c.key === e ? v(a, b, c, d) : null;
                }
                if (Ue(c) || zc(c)) return null !== e ? null : l(a, b, c, d, null);
                We(a, c);
            }
            return null;
        }
        function B(a, b, c, d, e) {
            if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, 
            g(b, a, "" + d, e);
            if ("object" === typeof d && null !== d) {
                switch (d.$$typeof) {
                  case oc:
                    return a = a.get(null === d.key ? c : d.key) || null, d.type === sc ? l(b, a, d.props.children, e, d.key) : k(b, a, d, e);

                  case rc:
                    return a = a.get(null === d.key ? c : d.key) || null, v(b, a, d, e);
                }
                if (Ue(d) || zc(d)) return a = a.get(c) || null, l(b, a, d, e, null);
                We(b, d);
            }
            return null;
        }
        function r(e, l, g, h) {
            for (var r = null, k = null, q = l, u = l = 0, t = null; null !== q && u < g.length; u++) {
                q.index > u ? (t = q, q = null) : t = q.sibling;
                var n = z(e, q, g[u], h);
                if (null === n) {
                    null === q && (q = t);
                    break;
                }
                a && q && null === n.alternate && b(e, q);
                l = f(n, l, u);
                null === k ? r = n : k.sibling = n;
                k = n;
                q = t;
            }
            if (u === g.length) return c(e, q), r;
            if (null === q) {
                for (;u < g.length; u++) if (q = p(e, g[u], h)) l = f(q, l, u), null === k ? r = q : k.sibling = q, 
                k = q;
                return r;
            }
            for (q = d(e, q); u < g.length; u++) if (t = B(q, e, u, g[u], h)) {
                if (a && null !== t.alternate) q["delete"](null === t.key ? u : t.key);
                l = f(t, l, u);
                null === k ? r = t : k.sibling = t;
                k = t;
            }
            a && q.forEach(function(a) {
                return b(e, a);
            });
            return r;
        }
        function Q(e, l, g, h) {
            var r = zc(g);
            "function" !== typeof r ? D("150") : void 0;
            g = r.call(g);
            null == g ? D("151") : void 0;
            for (var k = r = null, q = l, u = l = 0, t = null, n = g.next(); null !== q && !n.done; u++, 
            n = g.next()) {
                q.index > u ? (t = q, q = null) : t = q.sibling;
                var H = z(e, q, n.value, h);
                if (null === H) {
                    q || (q = t);
                    break;
                }
                a && q && null === H.alternate && b(e, q);
                l = f(H, l, u);
                null === k ? r = H : k.sibling = H;
                k = H;
                q = t;
            }
            if (n.done) return c(e, q), r;
            if (null === q) {
                for (;!n.done; u++, n = g.next()) n = p(e, n.value, h), null !== n && (l = f(n, l, u), 
                null === k ? r = n : k.sibling = n, k = n);
                return r;
            }
            for (q = d(e, q); !n.done; u++, n = g.next()) if (n = B(q, e, u, n.value, h), null !== n) {
                if (a && null !== n.alternate) q["delete"](null === n.key ? u : n.key);
                l = f(n, l, u);
                null === k ? r = n : k.sibling = n;
                k = n;
            }
            a && q.forEach(function(a) {
                return b(e, a);
            });
            return r;
        }
        return function(a, d, f, l) {
            "object" === typeof f && null !== f && f.type === sc && null === f.key && (f = f.props.children);
            var g = "object" === typeof f && null !== f;
            if (g) switch (f.$$typeof) {
              case oc:
                a: {
                    var k = f.key;
                    for (g = d; null !== g; ) {
                        if (g.key === k) if (10 === g.tag ? f.type === sc : g.type === f.type) {
                            c(a, g.sibling);
                            d = e(g, f.type === sc ? f.props.children : f.props, l);
                            d.ref = Ve(a, g, f);
                            d["return"] = a;
                            a = d;
                            break a;
                        } else {
                            c(a, g);
                            break;
                        } else b(a, g);
                        g = g.sibling;
                    }
                    f.type === sc ? (d = Be(f.props.children, a.mode, l, f.key), d["return"] = a, a = d) : (l = Ae(f, a.mode, l), 
                    l.ref = Ve(a, d, f), l["return"] = a, a = l);
                }
                return h(a);

              case rc:
                a: {
                    for (g = f.key; null !== d; ) {
                        if (d.key === g) if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                            c(a, d.sibling);
                            d = e(d, f.children || [], l);
                            d["return"] = a;
                            a = d;
                            break a;
                        } else {
                            c(a, d);
                            break;
                        } else b(a, d);
                        d = d.sibling;
                    }
                    d = De(f, a.mode, l);
                    d["return"] = a;
                    a = d;
                }
                return h(a);
            }
            if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), 
            d = e(d, f, l), d["return"] = a, a = d) : (c(a, d), d = Ce(f, a.mode, l), d["return"] = a, 
            a = d), h(a);
            if (Ue(f)) return r(a, d, f, l);
            if (zc(f)) return Q(a, d, f, l);
            g && We(a, f);
            if ("undefined" === typeof f) switch (a.tag) {
              case 2:
              case 1:
                l = a.type, D("152", l.displayName || l.name || "Component");
            }
            return c(a, d);
        };
    }
    var Ye = Xe(!0), Ze = Xe(!1);
    function $e(a, b, c, d, e, f, h) {
        function g(a, b, c) {
            k(a, b, c, b.expirationTime);
        }
        function k(a, b, c, d) {
            b.child = null === a ? Ze(b, null, c, d) : Ye(b, a.child, c, d);
        }
        function v(a, b) {
            var c = b.ref;
            if (null === a && null !== c || null !== a && a.ref !== c) b.effectTag |= 128;
        }
        function l(a, b, c, d, e, f) {
            v(a, b);
            if (!c && !e) return d && y(b, !1), r(a, b);
            c = b.stateNode;
            nc.current = b;
            var l = e ? null : c.render();
            b.effectTag |= 1;
            e && (k(a, b, null, f), b.child = null);
            k(a, b, l, f);
            b.memoizedState = c.state;
            b.memoizedProps = c.props;
            d && y(b, !0);
            return b.child;
        }
        function p(a) {
            var b = a.stateNode;
            b.pendingContext ? t(a, b.pendingContext, b.pendingContext !== b.context) : b.context && t(a, b.context, !1);
            Y(a, b.containerInfo);
        }
        function z(a, b, c, d) {
            var e = a.child;
            for (null !== e && (e["return"] = a); null !== e; ) {
                switch (e.tag) {
                  case 12:
                    var f = e.stateNode | 0;
                    if (e.type === b && 0 !== (f & c)) {
                        for (f = e; null !== f; ) {
                            var l = f.alternate;
                            if (0 === f.expirationTime || f.expirationTime > d) f.expirationTime = d, null !== l && (0 === l.expirationTime || l.expirationTime > d) && (l.expirationTime = d); else if (null !== l && (0 === l.expirationTime || l.expirationTime > d)) l.expirationTime = d; else break;
                            f = f["return"];
                        }
                        f = null;
                    } else f = e.child;
                    break;

                  case 13:
                    f = e.type === a.type ? null : e.child;
                    break;

                  default:
                    f = e.child;
                }
                if (null !== f) f["return"] = e; else for (f = e; null !== f; ) {
                    if (f === a) {
                        f = null;
                        break;
                    }
                    e = f.sibling;
                    if (null !== e) {
                        f = e;
                        break;
                    }
                    f = f["return"];
                }
                e = f;
            }
        }
        function B(a, b, c) {
            var d = b.type._context, e = b.pendingProps, f = b.memoizedProps;
            if (!q() && f === e) return b.stateNode = 0, G(b), r(a, b);
            var l = e.value;
            b.memoizedProps = e;
            if (null === f) l = 1073741823; else if (f.value === e.value) {
                if (f.children === e.children) return b.stateNode = 0, G(b), r(a, b);
                l = 0;
            } else {
                var h = f.value;
                if (h === l && (0 !== h || 1 / h === 1 / l) || h !== h && l !== l) {
                    if (f.children === e.children) return b.stateNode = 0, G(b), r(a, b);
                    l = 0;
                } else if (l = "function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, l) : 1073741823, 
                l |= 0, 0 === l) {
                    if (f.children === e.children) return b.stateNode = 0, G(b), r(a, b);
                } else z(b, d, l, c);
            }
            b.stateNode = l;
            G(b);
            g(a, b, e.children);
            return b.child;
        }
        function r(a, b) {
            null !== a && b.child !== a.child ? D("153") : void 0;
            if (null !== b.child) {
                a = b.child;
                var c = ze(a, a.pendingProps, a.expirationTime);
                b.child = c;
                for (c["return"] = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = ze(a, a.pendingProps, a.expirationTime), 
                c["return"] = b;
                c.sibling = null;
            }
            return b.child;
        }
        var Q = a.shouldSetTextContent, n = a.shouldDeprioritizeSubtree, x = b.pushHostContext, Y = b.pushHostContainer, G = d.pushProvider, R = c.getMaskedContext, S = c.getUnmaskedContext, q = c.hasContextChanged, u = c.pushContextProvider, t = c.pushTopLevelContextObject, y = c.invalidateContextProvider, H = e.enterHydrationState, Wa = e.resetHydrationState, Cb = e.tryToClaimNextHydratableInstance;
        a = Te(c, f, h, function(a, b) {
            a.memoizedProps = b;
        }, function(a, b) {
            a.memoizedState = b;
        });
        var Jc = a.adoptClassInstance, Kc = a.callGetDerivedStateFromProps, Lc = a.constructClassInstance, Db = a.mountClassInstance, Mc = a.resumeMountClassInstance, Eb = a.updateClassInstance;
        return {
            beginWork: function(a, b, c) {
                if (0 === b.expirationTime || b.expirationTime > c) {
                    switch (b.tag) {
                      case 3:
                        p(b);
                        break;

                      case 2:
                        u(b);
                        break;

                      case 4:
                        Y(b, b.stateNode.containerInfo);
                        break;

                      case 13:
                        G(b);
                    }
                    return null;
                }
                switch (b.tag) {
                  case 0:
                    null !== a ? D("155") : void 0;
                    var d = b.type, e = b.pendingProps, f = S(b);
                    f = R(b, f);
                    d = d(e, f);
                    b.effectTag |= 1;
                    "object" === typeof d && null !== d && "function" === typeof d.render && void 0 === d.$$typeof ? (f = b.type, 
                    b.tag = 2, b.memoizedState = null !== d.state && void 0 !== d.state ? d.state : null, 
                    "function" === typeof f.getDerivedStateFromProps && (e = Kc(b, d, e, b.memoizedState), 
                    null !== e && void 0 !== e && (b.memoizedState = A({}, b.memoizedState, e))), e = u(b), 
                    Jc(b, d), Db(b, c), a = l(a, b, !0, e, !1, c)) : (b.tag = 1, g(a, b, d), b.memoizedProps = e, 
                    a = b.child);
                    return a;

                  case 1:
                    return e = b.type, c = b.pendingProps, q() || b.memoizedProps !== c ? (d = S(b), 
                    d = R(b, d), e = e(c, d), b.effectTag |= 1, g(a, b, e), b.memoizedProps = c, a = b.child) : a = r(a, b), 
                    a;

                  case 2:
                    e = u(b);
                    null === a ? null === b.stateNode ? (Lc(b, b.pendingProps), Db(b, c), d = !0) : d = Mc(b, c) : d = Eb(a, b, c);
                    f = !1;
                    var h = b.updateQueue;
                    null !== h && null !== h.capturedValues && (f = d = !0);
                    return l(a, b, d, e, f, c);

                  case 3:
                    a: if (p(b), d = b.updateQueue, null !== d) {
                        f = b.memoizedState;
                        e = Re(a, b, d, null, null, c);
                        b.memoizedState = e;
                        d = b.updateQueue;
                        if (null !== d && null !== d.capturedValues) d = null; else if (f === e) {
                            Wa();
                            a = r(a, b);
                            break a;
                        } else d = e.element;
                        f = b.stateNode;
                        (null === a || null === a.child) && f.hydrate && H(b) ? (b.effectTag |= 2, b.child = Ze(b, null, d, c)) : (Wa(), 
                        g(a, b, d));
                        b.memoizedState = e;
                        a = b.child;
                    } else Wa(), a = r(a, b);
                    return a;

                  case 5:
                    a: {
                        x(b);
                        null === a && Cb(b);
                        e = b.type;
                        h = b.memoizedProps;
                        d = b.pendingProps;
                        f = null !== a ? a.memoizedProps : null;
                        if (!q() && h === d) {
                            if (h = b.mode & 1 && n(e, d)) b.expirationTime = 1073741823;
                            if (!h || 1073741823 !== c) {
                                a = r(a, b);
                                break a;
                            }
                        }
                        h = d.children;
                        Q(e, d) ? h = null : f && Q(e, f) && (b.effectTag |= 16);
                        v(a, b);
                        1073741823 !== c && b.mode & 1 && n(e, d) ? (b.expirationTime = 1073741823, b.memoizedProps = d, 
                        a = null) : (g(a, b, h), b.memoizedProps = d, a = b.child);
                    }
                    return a;

                  case 6:
                    return null === a && Cb(b), b.memoizedProps = b.pendingProps, null;

                  case 8:
                    b.tag = 7;

                  case 7:
                    return e = b.pendingProps, q() || b.memoizedProps !== e || (e = b.memoizedProps), 
                    d = e.children, b.stateNode = null === a ? Ze(b, b.stateNode, d, c) : Ye(b, a.stateNode, d, c), 
                    b.memoizedProps = e, b.stateNode;

                  case 9:
                    return null;

                  case 4:
                    return Y(b, b.stateNode.containerInfo), e = b.pendingProps, q() || b.memoizedProps !== e ? (null === a ? b.child = Ye(b, null, e, c) : g(a, b, e), 
                    b.memoizedProps = e, a = b.child) : a = r(a, b), a;

                  case 14:
                    return c = b.type.render, c = c(b.pendingProps, b.ref), g(a, b, c), b.memoizedProps = c, 
                    b.child;

                  case 10:
                    return c = b.pendingProps, q() || b.memoizedProps !== c ? (g(a, b, c), b.memoizedProps = c, 
                    a = b.child) : a = r(a, b), a;

                  case 11:
                    return c = b.pendingProps.children, q() || null !== c && b.memoizedProps !== c ? (g(a, b, c), 
                    b.memoizedProps = c, a = b.child) : a = r(a, b), a;

                  case 13:
                    return B(a, b, c);

                  case 12:
                    a: {
                        d = b.type;
                        f = b.pendingProps;
                        h = b.memoizedProps;
                        e = d._currentValue;
                        var t = d._changedBits;
                        if (q() || 0 !== t || h !== f) {
                            b.memoizedProps = f;
                            var k = f.unstable_observedBits;
                            if (void 0 === k || null === k) k = 1073741823;
                            b.stateNode = k;
                            if (0 !== (t & k)) z(b, d, t, c); else if (h === f) {
                                a = r(a, b);
                                break a;
                            }
                            c = f.children;
                            c = c(e);
                            g(a, b, c);
                            a = b.child;
                        } else a = r(a, b);
                    }
                    return a;

                  default:
                    D("156");
                }
            }
        };
    }
    function af(a, b, c, d, e) {
        function f(a) {
            a.effectTag |= 4;
        }
        var h = a.createInstance, g = a.createTextInstance, k = a.appendInitialChild, v = a.finalizeInitialChildren, l = a.prepareUpdate, p = a.persistence, z = b.getRootHostContainer, B = b.popHostContext, r = b.getHostContext, Q = b.popHostContainer, n = c.popContextProvider, x = c.popTopLevelContextObject, Y = d.popProvider, G = e.prepareToHydrateHostInstance, R = e.prepareToHydrateHostTextInstance, S = e.popHydrationState, q = void 0, u = void 0, t = void 0;
        a.mutation ? (q = function() {}, u = function(a, b, c) {
            (b.updateQueue = c) && f(b);
        }, t = function(a, b, c, d) {
            c !== d && f(b);
        }) : p ? D("235") : D("236");
        return {
            completeWork: function(a, b, c) {
                var d = b.pendingProps;
                switch (b.tag) {
                  case 1:
                    return null;

                  case 2:
                    return n(b), a = b.stateNode, d = b.updateQueue, null !== d && null !== d.capturedValues && (b.effectTag &= -65, 
                    "function" === typeof a.componentDidCatch ? b.effectTag |= 256 : d.capturedValues = null), 
                    null;

                  case 3:
                    Q(b);
                    x(b);
                    d = b.stateNode;
                    d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
                    if (null === a || null === a.child) S(b), b.effectTag &= -3;
                    q(b);
                    a = b.updateQueue;
                    null !== a && null !== a.capturedValues && (b.effectTag |= 256);
                    return null;

                  case 5:
                    B(b);
                    c = z();
                    var e = b.type;
                    if (null !== a && null != b.stateNode) {
                        var p = a.memoizedProps, H = b.stateNode, y = r();
                        H = l(H, e, p, d, c, y);
                        u(a, b, H, e, p, d, c, y);
                        a.ref !== b.ref && (b.effectTag |= 128);
                    } else {
                        if (!d) return null === b.stateNode ? D("166") : void 0, null;
                        a = r();
                        if (S(b)) G(b, c, a) && f(b); else {
                            p = h(e, d, c, a, b);
                            a: for (y = b.child; null !== y; ) {
                                if (5 === y.tag || 6 === y.tag) k(p, y.stateNode); else if (4 !== y.tag && null !== y.child) {
                                    y.child["return"] = y;
                                    y = y.child;
                                    continue;
                                }
                                if (y === b) break;
                                for (;null === y.sibling; ) {
                                    if (null === y["return"] || y["return"] === b) break a;
                                    y = y["return"];
                                }
                                y.sibling["return"] = y["return"];
                                y = y.sibling;
                            }
                            v(p, e, d, c, a) && f(b);
                            b.stateNode = p;
                        }
                        null !== b.ref && (b.effectTag |= 128);
                    }
                    return null;

                  case 6:
                    if (a && null != b.stateNode) t(a, b, a.memoizedProps, d); else {
                        if ("string" !== typeof d) return null === b.stateNode ? D("166") : void 0, null;
                        a = z();
                        c = r();
                        S(b) ? R(b) && f(b) : b.stateNode = g(d, a, c, b);
                    }
                    return null;

                  case 7:
                    (d = b.memoizedProps) ? void 0 : D("165");
                    b.tag = 8;
                    e = [];
                    a: for ((p = b.stateNode) && (p["return"] = b); null !== p; ) {
                        if (5 === p.tag || 6 === p.tag || 4 === p.tag) D("247"); else if (9 === p.tag) e.push(p.pendingProps.value); else if (null !== p.child) {
                            p.child["return"] = p;
                            p = p.child;
                            continue;
                        }
                        for (;null === p.sibling; ) {
                            if (null === p["return"] || p["return"] === b) break a;
                            p = p["return"];
                        }
                        p.sibling["return"] = p["return"];
                        p = p.sibling;
                    }
                    p = d.handler;
                    d = p(d.props, e);
                    b.child = Ye(b, null !== a ? a.child : null, d, c);
                    return b.child;

                  case 8:
                    return b.tag = 7, null;

                  case 9:
                    return null;

                  case 14:
                    return null;

                  case 10:
                    return null;

                  case 11:
                    return null;

                  case 4:
                    return Q(b), q(b), null;

                  case 13:
                    return Y(b), null;

                  case 12:
                    return null;

                  case 0:
                    D("167");

                  default:
                    D("156");
                }
            }
        };
    }
    function bf(a, b, c, d, e) {
        var f = a.popHostContainer, h = a.popHostContext, g = b.popContextProvider, k = b.popTopLevelContextObject, v = c.popProvider;
        return {
            throwException: function(a, b, c) {
                b.effectTag |= 512;
                b.firstEffect = b.lastEffect = null;
                b = {
                    value: c,
                    source: b,
                    stack: Bc(b)
                };
                do {
                    switch (a.tag) {
                      case 3:
                        Oe(a);
                        a.updateQueue.capturedValues = [ b ];
                        a.effectTag |= 1024;
                        return;

                      case 2:
                        if (c = a.stateNode, 0 === (a.effectTag & 64) && null !== c && "function" === typeof c.componentDidCatch && !e(c)) {
                            Oe(a);
                            c = a.updateQueue;
                            var d = c.capturedValues;
                            null === d ? c.capturedValues = [ b ] : d.push(b);
                            a.effectTag |= 1024;
                            return;
                        }
                    }
                    a = a["return"];
                } while (null !== a);
            },
            unwindWork: function(a) {
                switch (a.tag) {
                  case 2:
                    g(a);
                    var b = a.effectTag;
                    return b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null;

                  case 3:
                    return f(a), k(a), b = a.effectTag, b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null;

                  case 5:
                    return h(a), null;

                  case 4:
                    return f(a), null;

                  case 13:
                    return v(a), null;

                  default:
                    return null;
                }
            },
            unwindInterruptedWork: function(a) {
                switch (a.tag) {
                  case 2:
                    g(a);
                    break;

                  case 3:
                    f(a);
                    k(a);
                    break;

                  case 5:
                    h(a);
                    break;

                  case 4:
                    f(a);
                    break;

                  case 13:
                    v(a);
                }
            }
        };
    }
    function cf(a, b) {
        var c = b.source;
        null === b.stack && Bc(c);
        null !== c && Ac(c);
        b = b.value;
        null !== a && 2 === a.tag && Ac(a);
        try {
            b && b.suppressReactErrorLogging || console.error(b);
        } catch (d) {
            d && d.suppressReactErrorLogging || console.error(d);
        }
    }
    function df(a, b, c, d, e) {
        function f(a) {
            var c = a.ref;
            if (null !== c) if ("function" === typeof c) try {
                c(null);
            } catch (t) {
                b(a, t);
            } else c.current = null;
        }
        function h(a) {
            "function" === typeof Je && Je(a);
            switch (a.tag) {
              case 2:
                f(a);
                var c = a.stateNode;
                if ("function" === typeof c.componentWillUnmount) try {
                    c.props = a.memoizedProps, c.state = a.memoizedState, c.componentWillUnmount();
                } catch (t) {
                    b(a, t);
                }
                break;

              case 5:
                f(a);
                break;

              case 7:
                g(a.stateNode);
                break;

              case 4:
                p && v(a);
            }
        }
        function g(a) {
            for (var b = a; ;) if (h(b), null === b.child || p && 4 === b.tag) {
                if (b === a) break;
                for (;null === b.sibling; ) {
                    if (null === b["return"] || b["return"] === a) return;
                    b = b["return"];
                }
                b.sibling["return"] = b["return"];
                b = b.sibling;
            } else b.child["return"] = b, b = b.child;
        }
        function k(a) {
            return 5 === a.tag || 3 === a.tag || 4 === a.tag;
        }
        function v(a) {
            for (var b = a, c = !1, d = void 0, e = void 0; ;) {
                if (!c) {
                    c = b["return"];
                    a: for (;;) {
                        null === c ? D("160") : void 0;
                        switch (c.tag) {
                          case 5:
                            d = c.stateNode;
                            e = !1;
                            break a;

                          case 3:
                            d = c.stateNode.containerInfo;
                            e = !0;
                            break a;

                          case 4:
                            d = c.stateNode.containerInfo;
                            e = !0;
                            break a;
                        }
                        c = c["return"];
                    }
                    c = !0;
                }
                if (5 === b.tag || 6 === b.tag) g(b), e ? S(d, b.stateNode) : R(d, b.stateNode); else if (4 === b.tag ? d = b.stateNode.containerInfo : h(b), 
                null !== b.child) {
                    b.child["return"] = b;
                    b = b.child;
                    continue;
                }
                if (b === a) break;
                for (;null === b.sibling; ) {
                    if (null === b["return"] || b["return"] === a) return;
                    b = b["return"];
                    4 === b.tag && (c = !1);
                }
                b.sibling["return"] = b["return"];
                b = b.sibling;
            }
        }
        var l = a.getPublicInstance, p = a.mutation;
        a = a.persistence;
        p || (a ? D("235") : D("236"));
        var z = p.commitMount, B = p.commitUpdate, r = p.resetTextContent, Q = p.commitTextUpdate, n = p.appendChild, x = p.appendChildToContainer, Y = p.insertBefore, G = p.insertInContainerBefore, R = p.removeChild, S = p.removeChildFromContainer;
        return {
            commitBeforeMutationLifeCycles: function(a, b) {
                switch (b.tag) {
                  case 2:
                    if (b.effectTag & 2048 && null !== a) {
                        var c = a.memoizedProps, d = a.memoizedState;
                        a = b.stateNode;
                        a.props = b.memoizedProps;
                        a.state = b.memoizedState;
                        b = a.getSnapshotBeforeUpdate(c, d);
                        a.__reactInternalSnapshotBeforeUpdate = b;
                    }
                    break;

                  case 3:
                  case 5:
                  case 6:
                  case 4:
                    break;

                  default:
                    D("163");
                }
            },
            commitResetTextContent: function(a) {
                r(a.stateNode);
            },
            commitPlacement: function(a) {
                a: {
                    for (var b = a["return"]; null !== b; ) {
                        if (k(b)) {
                            var c = b;
                            break a;
                        }
                        b = b["return"];
                    }
                    D("160");
                    c = void 0;
                }
                var d = b = void 0;
                switch (c.tag) {
                  case 5:
                    b = c.stateNode;
                    d = !1;
                    break;

                  case 3:
                    b = c.stateNode.containerInfo;
                    d = !0;
                    break;

                  case 4:
                    b = c.stateNode.containerInfo;
                    d = !0;
                    break;

                  default:
                    D("161");
                }
                c.effectTag & 16 && (r(b), c.effectTag &= -17);
                a: b: for (c = a; ;) {
                    for (;null === c.sibling; ) {
                        if (null === c["return"] || k(c["return"])) {
                            c = null;
                            break a;
                        }
                        c = c["return"];
                    }
                    c.sibling["return"] = c["return"];
                    for (c = c.sibling; 5 !== c.tag && 6 !== c.tag; ) {
                        if (c.effectTag & 2) continue b;
                        if (null === c.child || 4 === c.tag) continue b; else c.child["return"] = c, c = c.child;
                    }
                    if (!(c.effectTag & 2)) {
                        c = c.stateNode;
                        break a;
                    }
                }
                for (var e = a; ;) {
                    if (5 === e.tag || 6 === e.tag) c ? d ? G(b, e.stateNode, c) : Y(b, e.stateNode, c) : d ? x(b, e.stateNode) : n(b, e.stateNode); else if (4 !== e.tag && null !== e.child) {
                        e.child["return"] = e;
                        e = e.child;
                        continue;
                    }
                    if (e === a) break;
                    for (;null === e.sibling; ) {
                        if (null === e["return"] || e["return"] === a) return;
                        e = e["return"];
                    }
                    e.sibling["return"] = e["return"];
                    e = e.sibling;
                }
            },
            commitDeletion: function(a) {
                v(a);
                a["return"] = null;
                a.child = null;
                a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
            },
            commitWork: function(a, b) {
                switch (b.tag) {
                  case 2:
                    break;

                  case 5:
                    var c = b.stateNode;
                    if (null != c) {
                        var d = b.memoizedProps;
                        a = null !== a ? a.memoizedProps : d;
                        var e = b.type, f = b.updateQueue;
                        b.updateQueue = null;
                        null !== f && B(c, f, e, a, d, b);
                    }
                    break;

                  case 6:
                    null === b.stateNode ? D("162") : void 0;
                    c = b.memoizedProps;
                    Q(b.stateNode, null !== a ? a.memoizedProps : c, c);
                    break;

                  case 3:
                    break;

                  default:
                    D("163");
                }
            },
            commitLifeCycles: function(a, b, c) {
                switch (c.tag) {
                  case 2:
                    a = c.stateNode;
                    if (c.effectTag & 4) if (null === b) a.props = c.memoizedProps, a.state = c.memoizedState, 
                    a.componentDidMount(); else {
                        var d = b.memoizedProps;
                        b = b.memoizedState;
                        a.props = c.memoizedProps;
                        a.state = c.memoizedState;
                        a.componentDidUpdate(d, b, a.__reactInternalSnapshotBeforeUpdate);
                    }
                    c = c.updateQueue;
                    null !== c && Se(c, a);
                    break;

                  case 3:
                    b = c.updateQueue;
                    if (null !== b) {
                        a = null;
                        if (null !== c.child) switch (c.child.tag) {
                          case 5:
                            a = l(c.child.stateNode);
                            break;

                          case 2:
                            a = c.child.stateNode;
                        }
                        Se(b, a);
                    }
                    break;

                  case 5:
                    a = c.stateNode;
                    null === b && c.effectTag & 4 && z(a, c.type, c.memoizedProps, c);
                    break;

                  case 6:
                    break;

                  case 4:
                    break;

                  default:
                    D("163");
                }
            },
            commitErrorLogging: function(a, b) {
                switch (a.tag) {
                  case 2:
                    var c = a.type;
                    b = a.stateNode;
                    var d = a.updateQueue;
                    null === d || null === d.capturedValues ? D("264") : void 0;
                    var f = d.capturedValues;
                    d.capturedValues = null;
                    "function" !== typeof c.getDerivedStateFromCatch && e(b);
                    b.props = a.memoizedProps;
                    b.state = a.memoizedState;
                    for (c = 0; c < f.length; c++) {
                        d = f[c];
                        var l = d.value, g = d.stack;
                        cf(a, d);
                        b.componentDidCatch(l, {
                            componentStack: null !== g ? g : ""
                        });
                    }
                    break;

                  case 3:
                    c = a.updateQueue;
                    null === c || null === c.capturedValues ? D("264") : void 0;
                    f = c.capturedValues;
                    c.capturedValues = null;
                    for (c = 0; c < f.length; c++) d = f[c], cf(a, d), b(d.value);
                    break;

                  default:
                    D("265");
                }
            },
            commitAttachRef: function(a) {
                var b = a.ref;
                if (null !== b) {
                    var c = a.stateNode;
                    switch (a.tag) {
                      case 5:
                        a = l(c);
                        break;

                      default:
                        a = c;
                    }
                    "function" === typeof b ? b(a) : b.current = a;
                }
            },
            commitDetachRef: function(a) {
                a = a.ref;
                null !== a && ("function" === typeof a ? a(null) : a.current = null);
            }
        };
    }
    var ef = {};
    function ff(a, b) {
        function c(a) {
            a === ef ? D("174") : void 0;
            return a;
        }
        var d = a.getChildHostContext, e = a.getRootHostContext;
        a = b.createCursor;
        var f = b.push, h = b.pop, g = a(ef), k = a(ef), v = a(ef);
        return {
            getHostContext: function() {
                return c(g.current);
            },
            getRootHostContainer: function() {
                return c(v.current);
            },
            popHostContainer: function(a) {
                h(g, a);
                h(k, a);
                h(v, a);
            },
            popHostContext: function(a) {
                k.current === a && (h(g, a), h(k, a));
            },
            pushHostContainer: function(a, b) {
                f(v, b, a);
                f(k, a, a);
                f(g, ef, a);
                b = e(b);
                h(g, a);
                f(g, b, a);
            },
            pushHostContext: function(a) {
                var b = c(v.current), e = c(g.current);
                b = d(e, a.type, b);
                e !== b && (f(k, a, a), f(g, b, a));
            }
        };
    }
    function gf(a) {
        function b(a, b) {
            var c = new xe(5, null, null, 0);
            c.type = "DELETED";
            c.stateNode = b;
            c["return"] = a;
            c.effectTag = 8;
            null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
        }
        function c(a, b) {
            switch (a.tag) {
              case 5:
                return b = f(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

              case 6:
                return b = h(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

              default:
                return !1;
            }
        }
        function d(a) {
            for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag; ) a = a["return"];
            p = a;
        }
        var e = a.shouldSetTextContent;
        a = a.hydration;
        if (!a) return {
            enterHydrationState: function() {
                return !1;
            },
            resetHydrationState: function() {},
            tryToClaimNextHydratableInstance: function() {},
            prepareToHydrateHostInstance: function() {
                D("175");
            },
            prepareToHydrateHostTextInstance: function() {
                D("176");
            },
            popHydrationState: function() {
                return !1;
            }
        };
        var f = a.canHydrateInstance, h = a.canHydrateTextInstance, g = a.getNextHydratableSibling, k = a.getFirstHydratableChild, v = a.hydrateInstance, l = a.hydrateTextInstance, p = null, z = null, B = !1;
        return {
            enterHydrationState: function(a) {
                z = k(a.stateNode.containerInfo);
                p = a;
                return B = !0;
            },
            resetHydrationState: function() {
                z = p = null;
                B = !1;
            },
            tryToClaimNextHydratableInstance: function(a) {
                if (B) {
                    var d = z;
                    if (d) {
                        if (!c(a, d)) {
                            d = g(d);
                            if (!d || !c(a, d)) {
                                a.effectTag |= 2;
                                B = !1;
                                p = a;
                                return;
                            }
                            b(p, z);
                        }
                        p = a;
                        z = k(d);
                    } else a.effectTag |= 2, B = !1, p = a;
                }
            },
            prepareToHydrateHostInstance: function(a, b, c) {
                b = v(a.stateNode, a.type, a.memoizedProps, b, c, a);
                a.updateQueue = b;
                return null !== b ? !0 : !1;
            },
            prepareToHydrateHostTextInstance: function(a) {
                return l(a.stateNode, a.memoizedProps, a);
            },
            popHydrationState: function(a) {
                if (a !== p) return !1;
                if (!B) return d(a), B = !0, !1;
                var c = a.type;
                if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = z; c; ) b(a, c), 
                c = g(c);
                d(a);
                z = p ? g(a.stateNode) : null;
                return !0;
            }
        };
    }
    function hf(a) {
        function b(a, b, c) {
            a = a.stateNode;
            a.__reactInternalMemoizedUnmaskedChildContext = b;
            a.__reactInternalMemoizedMaskedChildContext = c;
        }
        function c(a) {
            return 2 === a.tag && null != a.type.childContextTypes;
        }
        function d(a, b) {
            var c = a.stateNode, d = a.type.childContextTypes;
            if ("function" !== typeof c.getChildContext) return b;
            c = c.getChildContext();
            for (var e in c) e in d ? void 0 : D("108", Ac(a) || "Unknown", e);
            return A({}, b, c);
        }
        var e = a.createCursor, f = a.push, h = a.pop, g = e(ka), k = e(!1), v = ka;
        return {
            getUnmaskedContext: function(a) {
                return c(a) ? v : g.current;
            },
            cacheContext: b,
            getMaskedContext: function(a, c) {
                var d = a.type.contextTypes;
                if (!d) return ka;
                var e = a.stateNode;
                if (e && e.__reactInternalMemoizedUnmaskedChildContext === c) return e.__reactInternalMemoizedMaskedChildContext;
                var f = {}, g;
                for (g in d) f[g] = c[g];
                e && b(a, c, f);
                return f;
            },
            hasContextChanged: function() {
                return k.current;
            },
            isContextConsumer: function(a) {
                return 2 === a.tag && null != a.type.contextTypes;
            },
            isContextProvider: c,
            popContextProvider: function(a) {
                c(a) && (h(k, a), h(g, a));
            },
            popTopLevelContextObject: function(a) {
                h(k, a);
                h(g, a);
            },
            pushTopLevelContextObject: function(a, b, c) {
                null != g.cursor ? D("168") : void 0;
                f(g, b, a);
                f(k, c, a);
            },
            processChildContext: d,
            pushContextProvider: function(a) {
                if (!c(a)) return !1;
                var b = a.stateNode;
                b = b && b.__reactInternalMemoizedMergedChildContext || ka;
                v = g.current;
                f(g, b, a);
                f(k, k.current, a);
                return !0;
            },
            invalidateContextProvider: function(a, b) {
                var c = a.stateNode;
                c ? void 0 : D("169");
                if (b) {
                    var e = d(a, v);
                    c.__reactInternalMemoizedMergedChildContext = e;
                    h(k, a);
                    h(g, a);
                    f(g, e, a);
                } else h(k, a);
                f(k, b, a);
            },
            findCurrentUnmaskedContext: function(a) {
                for (2 !== xd(a) || 2 !== a.tag ? D("170") : void 0; 3 !== a.tag; ) {
                    if (c(a)) return a.stateNode.__reactInternalMemoizedMergedChildContext;
                    (a = a["return"]) ? void 0 : D("171");
                }
                return a.stateNode.context;
            }
        };
    }
    function jf(a) {
        var b = a.createCursor, c = a.push, d = a.pop, e = b(null), f = b(null), h = b(0);
        return {
            pushProvider: function(a) {
                var b = a.type._context;
                c(h, b._changedBits, a);
                c(f, b._currentValue, a);
                c(e, a, a);
                b._currentValue = a.pendingProps.value;
                b._changedBits = a.stateNode;
            },
            popProvider: function(a) {
                var b = h.current, c = f.current;
                d(e, a);
                d(f, a);
                d(h, a);
                a = a.type._context;
                a._currentValue = c;
                a._changedBits = b;
            }
        };
    }
    function kf() {
        var a = [], b = -1;
        return {
            createCursor: function(a) {
                return {
                    current: a
                };
            },
            isEmpty: function() {
                return -1 === b;
            },
            pop: function(c) {
                0 > b || (c.current = a[b], a[b] = null, b--);
            },
            push: function(c, d) {
                b++;
                a[b] = c.current;
                c.current = d;
            },
            checkThatStackIsEmpty: function() {},
            resetStackAfterFatalErrorInDev: function() {}
        };
    }
    function lf(a) {
        function b() {
            if (null !== I) for (var a = I["return"]; null !== a; ) Lc(a), a = a["return"];
            Ya = null;
            Z = 0;
            I = null;
            Nc = !1;
        }
        function c(a) {
            return null !== ya && ya.has(a);
        }
        function d(a) {
            for (;;) {
                var b = a.alternate, c = a["return"], d = a.sibling;
                if (0 === (a.effectTag & 512)) {
                    b = Cb(b, a, Z);
                    var e = a;
                    if (1073741823 === Z || 1073741823 !== e.expirationTime) {
                        b: switch (e.tag) {
                          case 3:
                          case 2:
                            var f = e.updateQueue;
                            f = null === f ? 0 : f.expirationTime;
                            break b;

                          default:
                            f = 0;
                        }
                        for (var g = e.child; null !== g; ) 0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), 
                        g = g.sibling;
                        e.expirationTime = f;
                    }
                    if (null !== b) return b;
                    null !== c && 0 === (c.effectTag & 512) && (null === c.firstEffect && (c.firstEffect = a.firstEffect), 
                    null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), 
                    c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, 
                    c.lastEffect = a));
                    if (null !== d) return d;
                    if (null !== c) a = c; else {
                        Nc = !0;
                        break;
                    }
                } else {
                    a = Kc(a);
                    if (null !== a) return a.effectTag &= 2559, a;
                    null !== c && (c.firstEffect = c.lastEffect = null, c.effectTag |= 512);
                    if (null !== d) return d;
                    if (null !== c) a = c; else break;
                }
            }
            return null;
        }
        function e(a) {
            var b = Wa(a.alternate, a, Z);
            null === b && (b = d(a));
            nc.current = null;
            return b;
        }
        function f(a, c, f) {
            ca ? D("243") : void 0;
            ca = !0;
            if (c !== Z || a !== Ya || null === I) b(), Ya = a, Z = c, I = ze(Ya.current, null, Z), 
            a.pendingCommitExpirationTime = 0;
            var g = !1;
            do {
                try {
                    if (f) for (;null !== I && !S(); ) I = e(I); else for (;null !== I; ) I = e(I);
                } catch (Oc) {
                    if (null === I) {
                        g = !0;
                        q(Oc);
                        break;
                    }
                    f = I;
                    var h = f["return"];
                    if (null === h) {
                        g = !0;
                        q(Oc);
                        break;
                    }
                    Jc(h, f, Oc);
                    I = d(f);
                }
                break;
            } while (1);
            ca = !1;
            if (g || null !== I) return null;
            if (Nc) return a.pendingCommitExpirationTime = c, a.current.alternate;
            D("262");
        }
        function h(a, b, c, d) {
            a = {
                value: c,
                source: a,
                stack: Bc(a)
            };
            Pe(b, {
                expirationTime: d,
                partialState: null,
                callback: null,
                isReplace: !1,
                isForced: !1,
                capturedValue: a,
                next: null
            });
            v(b, d);
        }
        function g(a, b) {
            a: {
                ca && !Za ? D("263") : void 0;
                for (var d = a["return"]; null !== d; ) {
                    switch (d.tag) {
                      case 2:
                        var e = d.stateNode;
                        if ("function" === typeof d.type.getDerivedStateFromCatch || "function" === typeof e.componentDidCatch && !c(e)) {
                            h(a, d, b, 1);
                            a = void 0;
                            break a;
                        }
                        break;

                      case 3:
                        h(a, d, b, 1);
                        a = void 0;
                        break a;
                    }
                    d = d["return"];
                }
                3 === a.tag && h(a, a, b, 1);
                a = void 0;
            }
            return a;
        }
        function k(a) {
            a = 0 !== ia ? ia : ca ? Za ? 1 : Z : a.mode & 1 ? za ? 10 * (((l() + 15) / 10 | 0) + 1) : 25 * (((l() + 500) / 25 | 0) + 1) : 1;
            za && (0 === da || a > da) && (da = a);
            return a;
        }
        function v(a, c) {
            a: {
                for (;null !== a; ) {
                    if (0 === a.expirationTime || a.expirationTime > c) a.expirationTime = c;
                    null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > c) && (a.alternate.expirationTime = c);
                    if (null === a["return"]) if (3 === a.tag) {
                        var d = a.stateNode;
                        !ca && 0 !== Z && c < Z && b();
                        ca && !Za && Ya === d || B(d, c);
                        Fb > xg && D("185");
                    } else {
                        c = void 0;
                        break a;
                    }
                    a = a["return"];
                }
                c = void 0;
            }
            return c;
        }
        function l() {
            ye = Ic() - Pc;
            return yg = (ye / 10 | 0) + 2;
        }
        function p(a, b, c, d, e) {
            var f = ia;
            ia = 1;
            try {
                return a(b, c, d, e);
            } finally {
                ia = f;
            }
        }
        function z(a) {
            if (0 !== Gb) {
                if (a > Gb) return;
                mg(Qc);
            }
            var b = Ic() - Pc;
            Gb = a;
            Qc = lg(Q, {
                timeout: 10 * (a - 2) - b
            });
        }
        function B(a, b) {
            if (null === a.nextScheduledRoot) a.remainingExpirationTime = b, null === K ? (la = K = a, 
            a.nextScheduledRoot = a) : (K = K.nextScheduledRoot = a, K.nextScheduledRoot = la); else {
                var c = a.remainingExpirationTime;
                if (0 === c || b < c) a.remainingExpirationTime = b;
            }
            T || (J ? Hb && (aa = a, P = 1, G(a, 1, !1)) : 1 === b ? n() : z(b));
        }
        function r() {
            var a = 0, b = null;
            if (null !== K) for (var c = K, d = la; null !== d; ) {
                var e = d.remainingExpirationTime;
                if (0 === e) {
                    null === c || null === K ? D("244") : void 0;
                    if (d === d.nextScheduledRoot) {
                        la = K = d.nextScheduledRoot = null;
                        break;
                    } else if (d === la) la = e = d.nextScheduledRoot, K.nextScheduledRoot = e, d.nextScheduledRoot = null; else if (d === K) {
                        K = c;
                        K.nextScheduledRoot = la;
                        d.nextScheduledRoot = null;
                        break;
                    } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;
                    d = c.nextScheduledRoot;
                } else {
                    if (0 === a || e < a) a = e, b = d;
                    if (d === K) break;
                    c = d;
                    d = d.nextScheduledRoot;
                }
            }
            c = aa;
            null !== c && c === b && 1 === a ? Fb++ : Fb = 0;
            aa = b;
            P = a;
        }
        function Q(a) {
            x(0, !0, a);
        }
        function n() {
            x(1, !1, null);
        }
        function x(a, b, c) {
            $a = c;
            r();
            if (b) for (;null !== aa && 0 !== P && (0 === a || a >= P) && (!Ib || l() >= P); ) G(aa, P, !Ib), 
            r(); else for (;null !== aa && 0 !== P && (0 === a || a >= P); ) G(aa, P, !1), r();
            null !== $a && (Gb = 0, Qc = -1);
            0 !== P && z(P);
            $a = null;
            Ib = !1;
            Y();
        }
        function Y() {
            Fb = 0;
            if (null !== Aa) {
                var a = Aa;
                Aa = null;
                for (var b = 0; b < a.length; b++) {
                    var c = a[b];
                    try {
                        c._onComplete();
                    } catch (wg) {
                        Ba || (Ba = !0, Jb = wg);
                    }
                }
            }
            if (Ba) throw a = Jb, Jb = null, Ba = !1, a;
        }
        function G(a, b, c) {
            T ? D("245") : void 0;
            T = !0;
            c ? (c = a.finishedWork, null !== c ? R(a, c, b) : (a.finishedWork = null, c = f(a, b, !0), 
            null !== c && (S() ? a.finishedWork = c : R(a, c, b)))) : (c = a.finishedWork, null !== c ? R(a, c, b) : (a.finishedWork = null, 
            c = f(a, b, !1), null !== c && R(a, c, b)));
            T = !1;
        }
        function R(a, b, c) {
            var d = a.firstBatch;
            if (null !== d && d._expirationTime <= c && (null === Aa ? Aa = [ d ] : Aa.push(d), 
            d._defer)) {
                a.finishedWork = b;
                a.remainingExpirationTime = 0;
                return;
            }
            a.finishedWork = null;
            Za = ca = !0;
            c = b.stateNode;
            c.current === b ? D("177") : void 0;
            d = c.pendingCommitExpirationTime;
            0 === d ? D("261") : void 0;
            c.pendingCommitExpirationTime = 0;
            var e = l();
            nc.current = null;
            if (1 < b.effectTag) if (null !== b.lastEffect) {
                b.lastEffect.nextEffect = b;
                var f = b.firstEffect;
            } else f = b; else f = b.firstEffect;
            zg(c.containerInfo);
            for (w = f; null !== w; ) {
                var h = !1, k = void 0;
                try {
                    for (;null !== w; ) w.effectTag & 2048 && Db(w.alternate, w), w = w.nextEffect;
                } catch (ab) {
                    h = !0, k = ab;
                }
                h && (null === w ? D("178") : void 0, g(w, k), null !== w && (w = w.nextEffect));
            }
            for (w = f; null !== w; ) {
                h = !1;
                k = void 0;
                try {
                    for (;null !== w; ) {
                        var p = w.effectTag;
                        p & 16 && Mc(w);
                        if (p & 128) {
                            var n = w.alternate;
                            null !== n && kg(n);
                        }
                        switch (p & 14) {
                          case 2:
                            Eb(w);
                            w.effectTag &= -3;
                            break;

                          case 6:
                            Eb(w);
                            w.effectTag &= -3;
                            we(w.alternate, w);
                            break;

                          case 4:
                            we(w.alternate, w);
                            break;

                          case 8:
                            gg(w);
                        }
                        w = w.nextEffect;
                    }
                } catch (ab) {
                    h = !0, k = ab;
                }
                h && (null === w ? D("178") : void 0, g(w, k), null !== w && (w = w.nextEffect));
            }
            Ag(c.containerInfo);
            c.current = b;
            for (w = f; null !== w; ) {
                p = !1;
                n = void 0;
                try {
                    for (f = c, h = e, k = d; null !== w; ) {
                        var r = w.effectTag;
                        r & 36 && hg(f, w.alternate, w, h, k);
                        r & 256 && ig(w, q);
                        r & 128 && jg(w);
                        var t = w.nextEffect;
                        w.nextEffect = null;
                        w = t;
                    }
                } catch (ab) {
                    p = !0, n = ab;
                }
                p && (null === w ? D("178") : void 0, g(w, n), null !== w && (w = w.nextEffect));
            }
            ca = Za = !1;
            "function" === typeof Ie && Ie(b.stateNode);
            b = c.current.expirationTime;
            0 === b && (ya = null);
            a.remainingExpirationTime = b;
        }
        function S() {
            return null === $a || $a.timeRemaining() > Bg ? !1 : Ib = !0;
        }
        function q(a) {
            null === aa ? D("246") : void 0;
            aa.remainingExpirationTime = 0;
            Ba || (Ba = !0, Jb = a);
        }
        var u = kf(), t = ff(a, u), y = hf(u);
        u = jf(u);
        var H = gf(a), Wa = $e(a, t, y, u, H, v, k).beginWork, Cb = af(a, t, y, u, H).completeWork;
        t = bf(t, y, u, v, c);
        var Jc = t.throwException, Kc = t.unwindWork, Lc = t.unwindInterruptedWork;
        t = df(a, g, v, k, function(a) {
            null === ya ? ya = new Set([ a ]) : ya.add(a);
        }, l);
        var Db = t.commitBeforeMutationLifeCycles, Mc = t.commitResetTextContent, Eb = t.commitPlacement, gg = t.commitDeletion, we = t.commitWork, hg = t.commitLifeCycles, ig = t.commitErrorLogging, jg = t.commitAttachRef, kg = t.commitDetachRef, Ic = a.now, lg = a.scheduleDeferredCallback, mg = a.cancelDeferredCallback, zg = a.prepareForCommit, Ag = a.resetAfterCommit, Pc = Ic(), yg = 2, ye = Pc, Rc = 0, ia = 0, ca = !1, I = null, Ya = null, Z = 0, w = null, Za = !1, Nc = !1, ya = null, la = null, K = null, Gb = 0, Qc = -1, T = !1, aa = null, P = 0, da = 0, Ib = !1, Ba = !1, Jb = null, $a = null, J = !1, Hb = !1, za = !1, Aa = null, xg = 1e3, Fb = 0, Bg = 1;
        return {
            recalculateCurrentTime: l,
            computeExpirationForFiber: k,
            scheduleWork: v,
            requestWork: B,
            flushRoot: function(a, b) {
                T ? D("253") : void 0;
                aa = a;
                P = b;
                G(a, b, !1);
                n();
                Y();
            },
            batchedUpdates: function(a, b) {
                var c = J;
                J = !0;
                try {
                    return a(b);
                } finally {
                    (J = c) || T || n();
                }
            },
            unbatchedUpdates: function(a, b) {
                if (J && !Hb) {
                    Hb = !0;
                    try {
                        return a(b);
                    } finally {
                        Hb = !1;
                    }
                }
                return a(b);
            },
            flushSync: function(a, b) {
                T ? D("187") : void 0;
                var c = J;
                J = !0;
                try {
                    return p(a, b);
                } finally {
                    J = c, n();
                }
            },
            flushControlled: function(a) {
                var b = J;
                J = !0;
                try {
                    p(a);
                } finally {
                    (J = b) || T || x(1, !1, null);
                }
            },
            deferredUpdates: function(a) {
                var b = ia;
                ia = 25 * (((l() + 500) / 25 | 0) + 1);
                try {
                    return a();
                } finally {
                    ia = b;
                }
            },
            syncUpdates: p,
            interactiveUpdates: function(a, b, c) {
                if (za) return a(b, c);
                J || T || 0 === da || (x(da, !1, null), da = 0);
                var d = za, e = J;
                J = za = !0;
                try {
                    return a(b, c);
                } finally {
                    za = d, (J = e) || T || n();
                }
            },
            flushInteractiveUpdates: function() {
                T || 0 === da || (x(da, !1, null), da = 0);
            },
            computeUniqueAsyncExpiration: function() {
                var a = 25 * (((l() + 500) / 25 | 0) + 1);
                a <= Rc && (a = Rc + 1);
                return Rc = a;
            },
            legacyContext: y
        };
    }
    function mf(a) {
        function b(a, b, c, d, e, h) {
            d = b.current;
            if (c) {
                c = c._reactInternalFiber;
                var l = g(c);
                c = k(c) ? v(c, l) : l;
            } else c = ka;
            null === b.context ? b.context = c : b.pendingContext = c;
            b = h;
            Pe(d, {
                expirationTime: e,
                partialState: {
                    element: a
                },
                callback: void 0 === b ? null : b,
                isReplace: !1,
                isForced: !1,
                capturedValue: null,
                next: null
            });
            f(d, e);
            return e;
        }
        var c = a.getPublicInstance;
        a = lf(a);
        var d = a.recalculateCurrentTime, e = a.computeExpirationForFiber, f = a.scheduleWork, h = a.legacyContext, g = h.findCurrentUnmaskedContext, k = h.isContextProvider, v = h.processChildContext;
        return {
            createContainer: function(a, b, c) {
                b = new xe(3, null, null, b ? 3 : 0);
                a = {
                    current: b,
                    containerInfo: a,
                    pendingChildren: null,
                    pendingCommitExpirationTime: 0,
                    finishedWork: null,
                    context: null,
                    pendingContext: null,
                    hydrate: c,
                    remainingExpirationTime: 0,
                    firstBatch: null,
                    nextScheduledRoot: null
                };
                return b.stateNode = a;
            },
            updateContainer: function(a, c, f, h) {
                var g = c.current, k = d();
                g = e(g);
                return b(a, c, f, k, g, h);
            },
            updateContainerAtExpirationTime: function(a, c, e, f, g) {
                var h = d();
                return b(a, c, e, h, f, g);
            },
            flushRoot: a.flushRoot,
            requestWork: a.requestWork,
            computeUniqueAsyncExpiration: a.computeUniqueAsyncExpiration,
            batchedUpdates: a.batchedUpdates,
            unbatchedUpdates: a.unbatchedUpdates,
            deferredUpdates: a.deferredUpdates,
            syncUpdates: a.syncUpdates,
            interactiveUpdates: a.interactiveUpdates,
            flushInteractiveUpdates: a.flushInteractiveUpdates,
            flushControlled: a.flushControlled,
            flushSync: a.flushSync,
            getPublicRootInstance: function(a) {
                a = a.current;
                if (!a.child) return null;
                switch (a.child.tag) {
                  case 5:
                    return c(a.child.stateNode);

                  default:
                    return a.child.stateNode;
                }
            },
            findHostInstance: function(a) {
                var b = a._reactInternalFiber;
                void 0 === b && ("function" === typeof a.render ? D("188") : D("268", Object.keys(a)));
                a = Bd(b);
                return null === a ? null : a.stateNode;
            },
            findHostInstanceWithNoPortals: function(a) {
                a = Cd(a);
                return null === a ? null : a.stateNode;
            },
            injectIntoDevTools: function(a) {
                var b = a.findFiberByHostInstance;
                return He(A({}, a, {
                    findHostInstanceByFiber: function(a) {
                        a = Bd(a);
                        return null === a ? null : a.stateNode;
                    },
                    findFiberByHostInstance: function(a) {
                        return b ? b(a) : null;
                    }
                }));
            }
        };
    }
    var nf = Object.freeze({
        default: mf
    }), of = nf && mf || nf, pf = of["default"] ? of["default"] : of;
    function qf(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
            $$typeof: rc,
            key: null == d ? null : "" + d,
            children: a,
            containerInfo: b,
            implementation: c
        };
    }
    var rf = "object" === typeof performance && "function" === typeof performance.now, sf = void 0;
    sf = rf ? function() {
        return performance.now();
    } : function() {
        return Date.now();
    };
    var tf = void 0, uf = void 0;
    if (m.canUseDOM) if ("function" !== typeof requestIdleCallback || "function" !== typeof cancelIdleCallback) {
        var vf = null, wf = !1, xf = -1, yf = !1, zf = 0, Af = 33, Bf = 33, Cf = void 0;
        Cf = rf ? {
            didTimeout: !1,
            timeRemaining: function() {
                var a = zf - performance.now();
                return 0 < a ? a : 0;
            }
        } : {
            didTimeout: !1,
            timeRemaining: function() {
                var a = zf - Date.now();
                return 0 < a ? a : 0;
            }
        };
        var Df = "__reactIdleCallback$" + Math.random().toString(36).slice(2);
        window.addEventListener("message", function(a) {
            if (a.source === window && a.data === Df) {
                wf = !1;
                a = sf();
                if (0 >= zf - a) if (-1 !== xf && xf <= a) Cf.didTimeout = !0; else {
                    yf || (yf = !0, requestAnimationFrame(Ef));
                    return;
                } else Cf.didTimeout = !1;
                xf = -1;
                a = vf;
                vf = null;
                null !== a && a(Cf);
            }
        }, !1);
        var Ef = function(a) {
            yf = !1;
            var b = a - zf + Bf;
            b < Bf && Af < Bf ? (8 > b && (b = 8), Bf = b < Af ? Af : b) : Af = b;
            zf = a + Bf;
            wf || (wf = !0, window.postMessage(Df, "*"));
        };
        tf = function(a, b) {
            vf = a;
            null != b && "number" === typeof b.timeout && (xf = sf() + b.timeout);
            yf || (yf = !0, requestAnimationFrame(Ef));
            return 0;
        };
        uf = function() {
            vf = null;
            wf = !1;
            xf = -1;
        };
    } else tf = window.requestIdleCallback, uf = window.cancelIdleCallback; else tf = function(a) {
        return setTimeout(function() {
            a({
                timeRemaining: function() {
                    return Infinity;
                },
                didTimeout: !1
            });
        });
    }, uf = function(a) {
        clearTimeout(a);
    };
    function Ff(a) {
        var b = "";
        ea.Children.forEach(a, function(a) {
            null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
        });
        return b;
    }
    function Gf(a, b) {
        a = A({
            children: void 0
        }, b);
        if (b = Ff(b.children)) a.children = b;
        return a;
    }
    function Hf(a, b, c, d) {
        a = a.options;
        if (b) {
            b = {};
            for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
            for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), 
            e && d && (a[c].defaultSelected = !0);
        } else {
            c = "" + c;
            b = null;
            for (e = 0; e < a.length; e++) {
                if (a[e].value === c) {
                    a[e].selected = !0;
                    d && (a[e].defaultSelected = !0);
                    return;
                }
                null !== b || a[e].disabled || (b = a[e]);
            }
            null !== b && (b.selected = !0);
        }
    }
    function If(a, b) {
        var c = b.value;
        a._wrapperState = {
            initialValue: null != c ? c : b.defaultValue,
            wasMultiple: !!b.multiple
        };
    }
    function Jf(a, b) {
        null != b.dangerouslySetInnerHTML ? D("91") : void 0;
        return A({}, b, {
            value: void 0,
            defaultValue: void 0,
            children: "" + a._wrapperState.initialValue
        });
    }
    function Kf(a, b) {
        var c = b.value;
        null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? D("92") : void 0, 
        Array.isArray(b) && (1 >= b.length ? void 0 : D("93"), b = b[0]), c = "" + b), null == c && (c = ""));
        a._wrapperState = {
            initialValue: "" + c
        };
    }
    function Lf(a, b) {
        var c = b.value;
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));
        null != b.defaultValue && (a.defaultValue = b.defaultValue);
    }
    function Mf(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && (a.value = b);
    }
    var Nf = {
        html: "http://www.w3.org/1999/xhtml",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg"
    };
    function Of(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";

          case "math":
            return "http://www.w3.org/1998/Math/MathML";

          default:
            return "http://www.w3.org/1999/xhtml";
        }
    }
    function Pf(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? Of(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var Qf = void 0, Rf = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
            MSApp.execUnsafeLocalFunction(function() {
                return a(b, c, d, e);
            });
        } : a;
    }(function(a, b) {
        if (a.namespaceURI !== Nf.svg || "innerHTML" in a) a.innerHTML = b; else {
            Qf = Qf || document.createElement("div");
            Qf.innerHTML = "<svg>" + b + "</svg>";
            for (b = Qf.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
            for (;b.firstChild; ) a.appendChild(b.firstChild);
        }
    });
    function Sf(a, b) {
        if (b) {
            var c = a.firstChild;
            if (c && c === a.lastChild && 3 === c.nodeType) {
                c.nodeValue = b;
                return;
            }
        }
        a.textContent = b;
    }
    var Tf = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }, Uf = [ "Webkit", "ms", "Moz", "O" ];
    Object.keys(Tf).forEach(function(a) {
        Uf.forEach(function(b) {
            b = b + a.charAt(0).toUpperCase() + a.substring(1);
            Tf[b] = Tf[a];
        });
    });
    function Vf(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--");
            var e = c;
            var f = b[c];
            e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || Tf.hasOwnProperty(e) && Tf[e] ? ("" + f).trim() : f + "px";
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var Wf = A({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function Xf(a, b, c) {
        b && (Wf[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? D("137", a, c()) : void 0), 
        null != b.dangerouslySetInnerHTML && (null != b.children ? D("60") : void 0, "object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML ? void 0 : D("61")), 
        null != b.style && "object" !== typeof b.style ? D("62", c()) : void 0);
    }
    function Yf(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;

          default:
            return !0;
        }
    }
    var Zf = C.thatReturns("");
    function $f(a, b) {
        a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;
        var c = ke(a);
        b = va[b];
        for (var d = 0; d < b.length; d++) {
            var e = b[d];
            c.hasOwnProperty(e) && c[e] || ("topScroll" === e ? Zd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (Zd("topFocus", "focus", a), 
            Zd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (ic("cancel", !0) && Zd("topCancel", "cancel", a), 
            c.topCancel = !0) : "topClose" === e ? (ic("close", !0) && Zd("topClose", "close", a), 
            c.topClose = !0) : fe.hasOwnProperty(e) && W(e, fe[e], a), c[e] = !0);
        }
    }
    function ag(a, b, c, d) {
        c = 9 === c.nodeType ? c : c.ownerDocument;
        d === Nf.html && (d = Of(a));
        d === Nf.html ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "<script><\/script>", 
        a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, {
            is: b.is
        }) : c.createElement(a) : a = c.createElementNS(d, a);
        return a;
    }
    function bg(a, b) {
        return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
    }
    function cg(a, b, c, d) {
        var e = Yf(b, c);
        switch (b) {
          case "iframe":
          case "object":
            W("topLoad", "load", a);
            var f = c;
            break;

          case "video":
          case "audio":
            for (f in ge) ge.hasOwnProperty(f) && W(f, ge[f], a);
            f = c;
            break;

          case "source":
            W("topError", "error", a);
            f = c;
            break;

          case "img":
          case "image":
          case "link":
            W("topError", "error", a);
            W("topLoad", "load", a);
            f = c;
            break;

          case "form":
            W("topReset", "reset", a);
            W("topSubmit", "submit", a);
            f = c;
            break;

          case "details":
            W("topToggle", "toggle", a);
            f = c;
            break;

          case "input":
            Wc(a, c);
            f = Vc(a, c);
            W("topInvalid", "invalid", a);
            $f(d, "onChange");
            break;

          case "option":
            f = Gf(a, c);
            break;

          case "select":
            If(a, c);
            f = A({}, c, {
                value: void 0
            });
            W("topInvalid", "invalid", a);
            $f(d, "onChange");
            break;

          case "textarea":
            Kf(a, c);
            f = Jf(a, c);
            W("topInvalid", "invalid", a);
            $f(d, "onChange");
            break;

          default:
            f = c;
        }
        Xf(b, f, Zf);
        var h = f, g;
        for (g in h) if (h.hasOwnProperty(g)) {
            var k = h[g];
            "style" === g ? Vf(a, k, Zf) : "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, 
            null != k && Rf(a, k)) : "children" === g ? "string" === typeof k ? ("textarea" !== b || "" !== k) && Sf(a, k) : "number" === typeof k && Sf(a, "" + k) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (ua.hasOwnProperty(g) ? null != k && $f(d, g) : null != k && Uc(a, g, k, e));
        }
        switch (b) {
          case "input":
            lc(a);
            ad(a, c);
            break;

          case "textarea":
            lc(a);
            Mf(a, c);
            break;

          case "option":
            null != c.value && a.setAttribute("value", c.value);
            break;

          case "select":
            a.multiple = !!c.multiple;
            b = c.value;
            null != b ? Hf(a, !!c.multiple, b, !1) : null != c.defaultValue && Hf(a, !!c.multiple, c.defaultValue, !0);
            break;

          default:
            "function" === typeof f.onClick && (a.onclick = C);
        }
    }
    function dg(a, b, c, d, e) {
        var f = null;
        switch (b) {
          case "input":
            c = Vc(a, c);
            d = Vc(a, d);
            f = [];
            break;

          case "option":
            c = Gf(a, c);
            d = Gf(a, d);
            f = [];
            break;

          case "select":
            c = A({}, c, {
                value: void 0
            });
            d = A({}, d, {
                value: void 0
            });
            f = [];
            break;

          case "textarea":
            c = Jf(a, c);
            d = Jf(a, d);
            f = [];
            break;

          default:
            "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = C);
        }
        Xf(b, d, Zf);
        b = a = void 0;
        var h = null;
        for (a in c) if (!d.hasOwnProperty(a) && c.hasOwnProperty(a) && null != c[a]) if ("style" === a) {
            var g = c[a];
            for (b in g) g.hasOwnProperty(b) && (h || (h = {}), h[b] = "");
        } else "dangerouslySetInnerHTML" !== a && "children" !== a && "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (ua.hasOwnProperty(a) ? f || (f = []) : (f = f || []).push(a, null));
        for (a in d) {
            var k = d[a];
            g = null != c ? c[a] : void 0;
            if (d.hasOwnProperty(a) && k !== g && (null != k || null != g)) if ("style" === a) if (g) {
                for (b in g) !g.hasOwnProperty(b) || k && k.hasOwnProperty(b) || (h || (h = {}), 
                h[b] = "");
                for (b in k) k.hasOwnProperty(b) && g[b] !== k[b] && (h || (h = {}), h[b] = k[b]);
            } else h || (f || (f = []), f.push(a, h)), h = k; else "dangerouslySetInnerHTML" === a ? (k = k ? k.__html : void 0, 
            g = g ? g.__html : void 0, null != k && g !== k && (f = f || []).push(a, "" + k)) : "children" === a ? g === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(a, "" + k) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && (ua.hasOwnProperty(a) ? (null != k && $f(e, a), 
            f || g === k || (f = [])) : (f = f || []).push(a, k));
        }
        h && (f = f || []).push("style", h);
        return f;
    }
    function eg(a, b, c, d, e) {
        "input" === c && "radio" === e.type && null != e.name && Yc(a, e);
        Yf(c, d);
        d = Yf(c, e);
        for (var f = 0; f < b.length; f += 2) {
            var h = b[f], g = b[f + 1];
            "style" === h ? Vf(a, g, Zf) : "dangerouslySetInnerHTML" === h ? Rf(a, g) : "children" === h ? Sf(a, g) : Uc(a, h, g, d);
        }
        switch (c) {
          case "input":
            Zc(a, e);
            break;

          case "textarea":
            Lf(a, e);
            break;

          case "select":
            a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, 
            c = e.value, null != c ? Hf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Hf(a, !!e.multiple, e.defaultValue, !0) : Hf(a, !!e.multiple, e.multiple ? [] : "", !1));
        }
    }
    function fg(a, b, c, d, e) {
        switch (b) {
          case "iframe":
          case "object":
            W("topLoad", "load", a);
            break;

          case "video":
          case "audio":
            for (var f in ge) ge.hasOwnProperty(f) && W(f, ge[f], a);
            break;

          case "source":
            W("topError", "error", a);
            break;

          case "img":
          case "image":
          case "link":
            W("topError", "error", a);
            W("topLoad", "load", a);
            break;

          case "form":
            W("topReset", "reset", a);
            W("topSubmit", "submit", a);
            break;

          case "details":
            W("topToggle", "toggle", a);
            break;

          case "input":
            Wc(a, c);
            W("topInvalid", "invalid", a);
            $f(e, "onChange");
            break;

          case "select":
            If(a, c);
            W("topInvalid", "invalid", a);
            $f(e, "onChange");
            break;

          case "textarea":
            Kf(a, c), W("topInvalid", "invalid", a), $f(e, "onChange");
        }
        Xf(b, c, Zf);
        d = null;
        for (var h in c) c.hasOwnProperty(h) && (f = c[h], "children" === h ? "string" === typeof f ? a.textContent !== f && (d = [ "children", f ]) : "number" === typeof f && a.textContent !== "" + f && (d = [ "children", "" + f ]) : ua.hasOwnProperty(h) && null != f && $f(e, h));
        switch (b) {
          case "input":
            lc(a);
            ad(a, c);
            break;

          case "textarea":
            lc(a);
            Mf(a, c);
            break;

          case "select":
          case "option":
            break;

          default:
            "function" === typeof c.onClick && (a.onclick = C);
        }
        return d;
    }
    function ng(a, b) {
        return a.nodeValue !== b;
    }
    var og = Object.freeze({
        createElement: ag,
        createTextNode: bg,
        setInitialProperties: cg,
        diffProperties: dg,
        updateProperties: eg,
        diffHydratedProperties: fg,
        diffHydratedText: ng,
        warnForUnmatchedText: function() {},
        warnForDeletedHydratableElement: function() {},
        warnForDeletedHydratableText: function() {},
        warnForInsertedHydratedElement: function() {},
        warnForInsertedHydratedText: function() {},
        restoreControlledState: function(a, b, c) {
            switch (b) {
              case "input":
                Zc(a, c);
                b = c.name;
                if ("radio" === c.type && null != b) {
                    for (c = a; c.parentNode; ) c = c.parentNode;
                    c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                    for (b = 0; b < c.length; b++) {
                        var d = c[b];
                        if (d !== a && d.form === a.form) {
                            var e = Xa(d);
                            e ? void 0 : D("90");
                            mc(d);
                            Zc(d, e);
                        }
                    }
                }
                break;

              case "textarea":
                Lf(a, c);
                break;

              case "select":
                b = c.value, null != b && Hf(a, !!c.multiple, b, !1);
            }
        }
    });
    Tb.injectFiberControlledHostComponent(og);
    var pg = null, qg = null;
    function rg(a) {
        this._expirationTime = X.computeUniqueAsyncExpiration();
        this._root = a;
        this._callbacks = this._next = null;
        this._hasChildren = this._didComplete = !1;
        this._children = null;
        this._defer = !0;
    }
    rg.prototype.render = function(a) {
        this._defer ? void 0 : D("250");
        this._hasChildren = !0;
        this._children = a;
        var b = this._root._internalRoot, c = this._expirationTime, d = new sg();
        X.updateContainerAtExpirationTime(a, b, null, c, d._onCommit);
        return d;
    };
    rg.prototype.then = function(a) {
        if (this._didComplete) a(); else {
            var b = this._callbacks;
            null === b && (b = this._callbacks = []);
            b.push(a);
        }
    };
    rg.prototype.commit = function() {
        var a = this._root._internalRoot, b = a.firstBatch;
        this._defer && null !== b ? void 0 : D("251");
        if (this._hasChildren) {
            var c = this._expirationTime;
            if (b !== this) {
                this._hasChildren && (c = this._expirationTime = b._expirationTime, this.render(this._children));
                for (var d = null, e = b; e !== this; ) d = e, e = e._next;
                null === d ? D("251") : void 0;
                d._next = e._next;
                this._next = b;
                a.firstBatch = this;
            }
            this._defer = !1;
            X.flushRoot(a, c);
            b = this._next;
            this._next = null;
            b = a.firstBatch = b;
            null !== b && b._hasChildren && b.render(b._children);
        } else this._next = null, this._defer = !1;
    };
    rg.prototype._onComplete = function() {
        if (!this._didComplete) {
            this._didComplete = !0;
            var a = this._callbacks;
            if (null !== a) for (var b = 0; b < a.length; b++) (0, a[b])();
        }
    };
    function sg() {
        this._callbacks = null;
        this._didCommit = !1;
        this._onCommit = this._onCommit.bind(this);
    }
    sg.prototype.then = function(a) {
        if (this._didCommit) a(); else {
            var b = this._callbacks;
            null === b && (b = this._callbacks = []);
            b.push(a);
        }
    };
    sg.prototype._onCommit = function() {
        if (!this._didCommit) {
            this._didCommit = !0;
            var a = this._callbacks;
            if (null !== a) for (var b = 0; b < a.length; b++) {
                var c = a[b];
                "function" !== typeof c ? D("191", c) : void 0;
                c();
            }
        }
    };
    function tg(a, b, c) {
        this._internalRoot = X.createContainer(a, b, c);
    }
    tg.prototype.render = function(a, b) {
        var c = this._internalRoot, d = new sg();
        b = void 0 === b ? null : b;
        null !== b && d.then(b);
        X.updateContainer(a, c, null, d._onCommit);
        return d;
    };
    tg.prototype.unmount = function(a) {
        var b = this._internalRoot, c = new sg();
        a = void 0 === a ? null : a;
        null !== a && c.then(a);
        X.updateContainer(null, b, null, c._onCommit);
        return c;
    };
    tg.prototype.legacy_renderSubtreeIntoContainer = function(a, b, c) {
        var d = this._internalRoot, e = new sg();
        c = void 0 === c ? null : c;
        null !== c && e.then(c);
        X.updateContainer(b, d, a, e._onCommit);
        return e;
    };
    tg.prototype.createBatch = function() {
        var a = new rg(this), b = a._expirationTime, c = this._internalRoot, d = c.firstBatch;
        if (null === d) c.firstBatch = a, a._next = null; else {
            for (c = null; null !== d && d._expirationTime <= b; ) c = d, d = d._next;
            a._next = d;
            null !== c && (c._next = a);
        }
        return a;
    };
    function ug(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function vg(a, b) {
        switch (a) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!b.autoFocus;
        }
        return !1;
    }
    var X = pf({
        getRootHostContext: function(a) {
            var b = a.nodeType;
            switch (b) {
              case 9:
              case 11:
                a = (a = a.documentElement) ? a.namespaceURI : Pf(null, "");
                break;

              default:
                b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = Pf(a, b);
            }
            return a;
        },
        getChildHostContext: function(a, b) {
            return Pf(a, b);
        },
        getPublicInstance: function(a) {
            return a;
        },
        prepareForCommit: function() {
            pg = Vd;
            var a = fa();
            if (ne(a)) {
                if ("selectionStart" in a) var b = {
                    start: a.selectionStart,
                    end: a.selectionEnd
                }; else a: {
                    var c = window.getSelection && window.getSelection();
                    if (c && 0 !== c.rangeCount) {
                        b = c.anchorNode;
                        var d = c.anchorOffset, e = c.focusNode;
                        c = c.focusOffset;
                        try {
                            b.nodeType, e.nodeType;
                        } catch (B) {
                            b = null;
                            break a;
                        }
                        var f = 0, h = -1, g = -1, k = 0, v = 0, l = a, p = null;
                        b: for (;;) {
                            for (var z; ;) {
                                l !== b || 0 !== d && 3 !== l.nodeType || (h = f + d);
                                l !== e || 0 !== c && 3 !== l.nodeType || (g = f + c);
                                3 === l.nodeType && (f += l.nodeValue.length);
                                if (null === (z = l.firstChild)) break;
                                p = l;
                                l = z;
                            }
                            for (;;) {
                                if (l === a) break b;
                                p === b && ++k === d && (h = f);
                                p === e && ++v === c && (g = f);
                                if (null !== (z = l.nextSibling)) break;
                                l = p;
                                p = l.parentNode;
                            }
                            l = z;
                        }
                        b = -1 === h || -1 === g ? null : {
                            start: h,
                            end: g
                        };
                    } else b = null;
                }
                b = b || {
                    start: 0,
                    end: 0
                };
            } else b = null;
            qg = {
                focusedElem: a,
                selectionRange: b
            };
            Wd(!1);
        },
        resetAfterCommit: function() {
            var a = qg, b = fa(), c = a.focusedElem, d = a.selectionRange;
            if (b !== c && ja(document.documentElement, c)) {
                if (ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, 
                c.selectionEnd = Math.min(a, c.value.length); else if (window.getSelection) {
                    b = window.getSelection();
                    var e = c[mb()].length;
                    a = Math.min(d.start, e);
                    d = void 0 === d.end ? a : Math.min(d.end, e);
                    !b.extend && a > d && (e = d, d = a, a = e);
                    e = me(c, a);
                    var f = me(c, d);
                    if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
                        var h = document.createRange();
                        h.setStart(e.node, e.offset);
                        b.removeAllRanges();
                        a > d ? (b.addRange(h), b.extend(f.node, f.offset)) : (h.setEnd(f.node, f.offset), 
                        b.addRange(h));
                    }
                }
                b = [];
                for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({
                    element: a,
                    left: a.scrollLeft,
                    top: a.scrollTop
                });
                c.focus();
                for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
            }
            qg = null;
            Wd(pg);
            pg = null;
        },
        createInstance: function(a, b, c, d, e) {
            a = ag(a, b, c, d);
            a[F] = e;
            a[Ta] = b;
            return a;
        },
        appendInitialChild: function(a, b) {
            a.appendChild(b);
        },
        finalizeInitialChildren: function(a, b, c, d) {
            cg(a, b, c, d);
            return vg(b, c);
        },
        prepareUpdate: function(a, b, c, d, e) {
            return dg(a, b, c, d, e);
        },
        shouldSetTextContent: function(a, b) {
            return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
        },
        shouldDeprioritizeSubtree: function(a, b) {
            return !!b.hidden;
        },
        createTextInstance: function(a, b, c, d) {
            a = bg(a, b);
            a[F] = d;
            return a;
        },
        now: sf,
        mutation: {
            commitMount: function(a, b, c) {
                vg(b, c) && a.focus();
            },
            commitUpdate: function(a, b, c, d, e) {
                a[Ta] = e;
                eg(a, b, c, d, e);
            },
            resetTextContent: function(a) {
                Sf(a, "");
            },
            commitTextUpdate: function(a, b, c) {
                a.nodeValue = c;
            },
            appendChild: function(a, b) {
                a.appendChild(b);
            },
            appendChildToContainer: function(a, b) {
                8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
            },
            insertBefore: function(a, b, c) {
                a.insertBefore(b, c);
            },
            insertInContainerBefore: function(a, b, c) {
                8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
            },
            removeChild: function(a, b) {
                a.removeChild(b);
            },
            removeChildFromContainer: function(a, b) {
                8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
            }
        },
        hydration: {
            canHydrateInstance: function(a, b) {
                return 1 !== a.nodeType || b.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
            },
            canHydrateTextInstance: function(a, b) {
                return "" === b || 3 !== a.nodeType ? null : a;
            },
            getNextHydratableSibling: function(a) {
                for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType; ) a = a.nextSibling;
                return a;
            },
            getFirstHydratableChild: function(a) {
                for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType; ) a = a.nextSibling;
                return a;
            },
            hydrateInstance: function(a, b, c, d, e, f) {
                a[F] = f;
                a[Ta] = c;
                return fg(a, b, c, e, d);
            },
            hydrateTextInstance: function(a, b, c) {
                a[F] = c;
                return ng(a, b);
            },
            didNotMatchHydratedContainerTextInstance: function() {},
            didNotMatchHydratedTextInstance: function() {},
            didNotHydrateContainerInstance: function() {},
            didNotHydrateInstance: function() {},
            didNotFindHydratableContainerInstance: function() {},
            didNotFindHydratableContainerTextInstance: function() {},
            didNotFindHydratableInstance: function() {},
            didNotFindHydratableTextInstance: function() {}
        },
        scheduleDeferredCallback: tf,
        cancelDeferredCallback: uf
    }), Cg = X;
    ac = Cg.batchedUpdates;
    bc = Cg.interactiveUpdates;
    cc = Cg.flushInteractiveUpdates;
    function Dg(a, b) {
        b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
        if (!b) for (var c; c = a.lastChild; ) a.removeChild(c);
        return new tg(a, !1, b);
    }
    function Eg(a, b, c, d, e) {
        ug(c) ? void 0 : D("200");
        var f = c._reactRootContainer;
        if (f) {
            if ("function" === typeof e) {
                var h = e;
                e = function() {
                    var a = X.getPublicRootInstance(f._internalRoot);
                    h.call(a);
                };
            }
            null != a ? f.legacy_renderSubtreeIntoContainer(a, b, e) : f.render(b, e);
        } else {
            f = c._reactRootContainer = Dg(c, d);
            if ("function" === typeof e) {
                var g = e;
                e = function() {
                    var a = X.getPublicRootInstance(f._internalRoot);
                    g.call(a);
                };
            }
            X.unbatchedUpdates(function() {
                null != a ? f.legacy_renderSubtreeIntoContainer(a, b, e) : f.render(b, e);
            });
        }
        return X.getPublicRootInstance(f._internalRoot);
    }
    function Fg(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        ug(b) ? void 0 : D("200");
        return qf(a, b, null, c);
    }
    var Gg = {
        createPortal: Fg,
        findDOMNode: function(a) {
            return null == a ? null : 1 === a.nodeType ? a : X.findHostInstance(a);
        },
        hydrate: function(a, b, c) {
            return Eg(null, a, b, !0, c);
        },
        render: function(a, b, c) {
            return Eg(null, a, b, !1, c);
        },
        unstable_renderSubtreeIntoContainer: function(a, b, c, d) {
            null == a || void 0 === a._reactInternalFiber ? D("38") : void 0;
            return Eg(a, b, c, !1, d);
        },
        unmountComponentAtNode: function(a) {
            ug(a) ? void 0 : D("40");
            return a._reactRootContainer ? (X.unbatchedUpdates(function() {
                Eg(null, null, a, !1, function() {
                    a._reactRootContainer = null;
                });
            }), !0) : !1;
        },
        unstable_createPortal: function() {
            return Fg.apply(void 0, arguments);
        },
        unstable_batchedUpdates: X.batchedUpdates,
        unstable_deferredUpdates: X.deferredUpdates,
        flushSync: X.flushSync,
        unstable_flushControlled: X.flushControlled,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
            EventPluginHub: Ra,
            EventPluginRegistry: Ca,
            EventPropagators: kb,
            ReactControlledComponent: $b,
            ReactDOMComponentTree: bb,
            ReactDOMEventListener: $d
        },
        unstable_createRoot: function(a, b) {
            return new tg(a, !0, null != b && !0 === b.hydrate);
        }
    };
    X.injectIntoDevTools({
        findFiberByHostInstance: Ua,
        bundleType: 0,
        version: "16.3.2",
        rendererPackageName: "react-dom"
    });
    var Hg = Object.freeze({
        default: Gg
    }), Ig = Hg && Gg || Hg;
    module.exports = Ig["default"] ? Ig["default"] : Ig;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var m = __webpack_require__(173), n = __webpack_require__(91), p = __webpack_require__(172), q = __webpack_require__(90), r = "function" === typeof Symbol && Symbol["for"], t = r ? Symbol["for"]("react.element") : 60103, u = r ? Symbol["for"]("react.portal") : 60106, v = r ? Symbol["for"]("react.fragment") : 60107, w = r ? Symbol["for"]("react.strict_mode") : 60108, x = r ? Symbol["for"]("react.provider") : 60109, y = r ? Symbol["for"]("react.context") : 60110, z = r ? Symbol["for"]("react.async_mode") : 60111, A = r ? Symbol["for"]("react.forward_ref") : 60112, B = "function" === typeof Symbol && Symbol.iterator;
    function C(a) {
        for (var b = arguments.length - 1, e = "http://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 0; c < b; c++) e += "&args[]=" + encodeURIComponent(arguments[c + 1]);
        n(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", e);
    }
    var D = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    };
    function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = p;
        this.updater = e || D;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
        "object" !== typeof a && "function" !== typeof a && null != a ? C("85") : void 0;
        this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {}
    F.prototype = E.prototype;
    function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = p;
        this.updater = e || D;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    m(H, E.prototype);
    H.isPureReactComponent = !0;
    var I = {
        current: null
    }, J = Object.prototype.hasOwnProperty, K = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function L(a, b, e) {
        var c = void 0, d = {}, g = null, h = null;
        if (null != b) for (c in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (g = "" + b.key), 
        b) J.call(b, c) && !K.hasOwnProperty(c) && (d[c] = b[c]);
        var f = arguments.length - 2;
        if (1 === f) d.children = e; else if (1 < f) {
            for (var k = Array(f), l = 0; l < f; l++) k[l] = arguments[l + 2];
            d.children = k;
        }
        if (a && a.defaultProps) for (c in f = a.defaultProps, f) void 0 === d[c] && (d[c] = f[c]);
        return {
            $$typeof: t,
            type: a,
            key: g,
            ref: h,
            props: d,
            _owner: I.current
        };
    }
    function M(a) {
        return "object" === typeof a && null !== a && a.$$typeof === t;
    }
    function escape(a) {
        var b = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + ("" + a).replace(/[=:]/g, function(a) {
            return b[a];
        });
    }
    var N = /\/+/g, O = [];
    function P(a, b, e, c) {
        if (O.length) {
            var d = O.pop();
            d.result = a;
            d.keyPrefix = b;
            d.func = e;
            d.context = c;
            d.count = 0;
            return d;
        }
        return {
            result: a,
            keyPrefix: b,
            func: e,
            context: c,
            count: 0
        };
    }
    function Q(a) {
        a.result = null;
        a.keyPrefix = null;
        a.func = null;
        a.context = null;
        a.count = 0;
        10 > O.length && O.push(a);
    }
    function R(a, b, e, c) {
        var d = typeof a;
        if ("undefined" === d || "boolean" === d) a = null;
        var g = !1;
        if (null === a) g = !0; else switch (d) {
          case "string":
          case "number":
            g = !0;
            break;

          case "object":
            switch (a.$$typeof) {
              case t:
              case u:
                g = !0;
            }
        }
        if (g) return e(c, a, "" === b ? "." + S(a, 0) : b), 1;
        g = 0;
        b = "" === b ? "." : b + ":";
        if (Array.isArray(a)) for (var h = 0; h < a.length; h++) {
            d = a[h];
            var f = b + S(d, h);
            g += R(d, f, e, c);
        } else if (null === a || "undefined" === typeof a ? f = null : (f = B && a[B] || a["@@iterator"], 
        f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), 
        h = 0; !(d = a.next()).done; ) d = d.value, f = b + S(d, h++), g += R(d, f, e, c); else "object" === d && (e = "" + a, 
        C("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
        return g;
    }
    function S(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
    }
    function T(a, b) {
        a.func.call(a.context, b, a.count++);
    }
    function U(a, b, e) {
        var c = a.result, d = a.keyPrefix;
        a = a.func.call(a.context, b, a.count++);
        Array.isArray(a) ? V(a, c, e, q.thatReturnsArgument) : null != a && (M(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(N, "$&/") + "/") + e, 
        a = {
            $$typeof: t,
            type: a.type,
            key: b,
            ref: a.ref,
            props: a.props,
            _owner: a._owner
        }), c.push(a));
    }
    function V(a, b, e, c, d) {
        var g = "";
        null != e && (g = ("" + e).replace(N, "$&/") + "/");
        b = P(b, g, c, d);
        null == a || R(a, "", U, b);
        Q(b);
    }
    var W = {
        Children: {
            map: function(a, b, e) {
                if (null == a) return a;
                var c = [];
                V(a, c, null, b, e);
                return c;
            },
            forEach: function(a, b, e) {
                if (null == a) return a;
                b = P(null, null, b, e);
                null == a || R(a, "", T, b);
                Q(b);
            },
            count: function(a) {
                return null == a ? 0 : R(a, "", q.thatReturnsNull, null);
            },
            toArray: function(a) {
                var b = [];
                V(a, b, null, q.thatReturnsArgument);
                return b;
            },
            only: function(a) {
                M(a) ? void 0 : C("143");
                return a;
            }
        },
        createRef: function() {
            return {
                current: null
            };
        },
        Component: E,
        PureComponent: G,
        createContext: function(a, b) {
            void 0 === b && (b = null);
            a = {
                $$typeof: y,
                _calculateChangedBits: b,
                _defaultValue: a,
                _currentValue: a,
                _changedBits: 0,
                Provider: null,
                Consumer: null
            };
            a.Provider = {
                $$typeof: x,
                _context: a
            };
            return a.Consumer = a;
        },
        forwardRef: function(a) {
            return {
                $$typeof: A,
                render: a
            };
        },
        Fragment: v,
        StrictMode: w,
        unstable_AsyncMode: z,
        createElement: L,
        cloneElement: function(a, b, e) {
            null === a || void 0 === a ? C("267", a) : void 0;
            var c = void 0, d = m({}, a.props), g = a.key, h = a.ref, f = a._owner;
            if (null != b) {
                void 0 !== b.ref && (h = b.ref, f = I.current);
                void 0 !== b.key && (g = "" + b.key);
                var k = void 0;
                a.type && a.type.defaultProps && (k = a.type.defaultProps);
                for (c in b) J.call(b, c) && !K.hasOwnProperty(c) && (d[c] = void 0 === b[c] && void 0 !== k ? k[c] : b[c]);
            }
            c = arguments.length - 2;
            if (1 === c) d.children = e; else if (1 < c) {
                k = Array(c);
                for (var l = 0; l < c; l++) k[l] = arguments[l + 2];
                d.children = k;
            }
            return {
                $$typeof: t,
                type: a.type,
                key: g,
                ref: h,
                props: d,
                _owner: f
            };
        },
        createFactory: function(a) {
            var b = L.bind(null, a);
            b.type = a;
            return b;
        },
        isValidElement: M,
        version: "16.3.2",
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
            ReactCurrentOwner: I,
            assign: m
        }
    }, X = Object.freeze({
        default: W
    }), Y = X && W || X;
    module.exports = Y["default"] ? Y["default"] : Y;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _react = __webpack_require__(2);
    var _react2 = _interopRequireDefault(_react);
    var _reactDom = __webpack_require__(171);
    var _reactDom2 = _interopRequireDefault(_reactDom);
    var _reactRouterDom = __webpack_require__(96);
    var _reactRedux = __webpack_require__(47);
    var _react3 = __webpack_require__(467);
    var _reduxPersist = __webpack_require__(95);
    __webpack_require__(466);
    var _app = __webpack_require__(463);
    var _app2 = _interopRequireDefault(_app);
    var _store = __webpack_require__(462);
    var _store2 = _interopRequireDefault(_store);
    var _login = __webpack_require__(457);
    var _login2 = _interopRequireDefault(_login);
    var _house = __webpack_require__(183);
    var _house2 = _interopRequireDefault(_house);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var Root = function Root() {
        return _react2.default.createElement(_reactRouterDom.BrowserRouter, null, _react2.default.createElement("div", null, _react2.default.createElement(_reactRouterDom.Route, {
            exact: true,
            path: "/",
            component: _app2.default
        }), _react2.default.createElement(_reactRouterDom.Route, {
            path: "/login",
            component: _login2.default
        }), _react2.default.createElement(_reactRouterDom.Route, {
            path: "/house",
            component: _house2.default
        })));
    };
    var storeInstance = (0, _store2.default)();
    _reactDom2.default.render(_react2.default.createElement(_reactRedux.Provider, {
        store: storeInstance.Store
    }, _react2.default.createElement(_react3.PersistGate, {
        loading: null,
        persistor: storeInstance.Persistor
    }, _react2.default.createElement(Root, null))), document.getElementById("root"));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(global) {
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        __webpack_exports__["a"] = freeGlobal;
    }).call(this, __webpack_require__(12));
} ]);